{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hey, thanks for stopping by! Network Analysis Made Simple is a collection of Jupyter notebooks designed to help you get up and running with the NetworkX package in the Python programming langauge. It's written by programmers for programmers, and will give you a basic introduction to graph theory, applied network science, and advanced topics to help kickstart your learning journey. There's even case studies to help those of you for whom example narratives help a ton! We hope you enjoy learning from it. Introduction Videos At the beginning of each \"chapter\", there's an introduction video just like the one you'll see embedded below. Those videos will give you an overview of the chapter, particularly what to look out for and what the learning goals are, and are designed to orient you on the right path. If you're not the audio/visual kind, feel free to skip past them :). Because they're hosted on YouTube, if you need captions, hit the captions button to get access to them. Using the book There are three ways to use this website/web book. Firstly, you can view everything online at this site. Use the navigation to help you get around, or search for a specific topic that you're interested in. Secondly, you can launch a binder session . Binder lets you execute the notebook code inside the book. Click on the Binder button below to get started! Finally, you can pick up the official EPUB/MOBI/PDF version of the book on LeanPub ! Purchasing a copy helps support the authors, and funds future improvements and updates to the book, which you will continue to receive as we make updates! Feedback If you have feedback for the eBook, please head over to our GitHub repository and raise an issue there. Support us! If you find the book useful, you can support the creators in the following ways: Star the repository ! It costs you nothing, and helps raise the profile of the book. Share the website with your colleagues! It also costs you nothing, and helps share the good stuff with those you think might benefit from it. Take the official companion courses and projects on DataCamp! It does cost some money, so we totally understand if you'd prefer not to, but it does buy us coffee :). Support Eric Ma on Patreon with a monthly coffee pledge to keep him caffeinated, which helps him make other good material to share. Follow Eric and Mridul on Twitter at @ericmjl and @Mridul_Seth Purchase the companion book on LeanPub and fund coffee that way too!","title":"Welcome"},{"location":"#introduction-videos","text":"At the beginning of each \"chapter\", there's an introduction video just like the one you'll see embedded below. Those videos will give you an overview of the chapter, particularly what to look out for and what the learning goals are, and are designed to orient you on the right path. If you're not the audio/visual kind, feel free to skip past them :). Because they're hosted on YouTube, if you need captions, hit the captions button to get access to them.","title":"Introduction Videos"},{"location":"#using-the-book","text":"There are three ways to use this website/web book. Firstly, you can view everything online at this site. Use the navigation to help you get around, or search for a specific topic that you're interested in. Secondly, you can launch a binder session . Binder lets you execute the notebook code inside the book. Click on the Binder button below to get started! Finally, you can pick up the official EPUB/MOBI/PDF version of the book on LeanPub ! Purchasing a copy helps support the authors, and funds future improvements and updates to the book, which you will continue to receive as we make updates!","title":"Using the book"},{"location":"#feedback","text":"If you have feedback for the eBook, please head over to our GitHub repository and raise an issue there.","title":"Feedback"},{"location":"#support-us","text":"If you find the book useful, you can support the creators in the following ways: Star the repository ! It costs you nothing, and helps raise the profile of the book. Share the website with your colleagues! It also costs you nothing, and helps share the good stuff with those you think might benefit from it. Take the official companion courses and projects on DataCamp! It does cost some money, so we totally understand if you'd prefer not to, but it does buy us coffee :). Support Eric Ma on Patreon with a monthly coffee pledge to keep him caffeinated, which helps him make other good material to share. Follow Eric and Mridul on Twitter at @ericmjl and @Mridul_Seth Purchase the companion book on LeanPub and fund coffee that way too!","title":"Support us!"},{"location":"learn-more/","text":"Thank you for making it this far! We hope you've enjoyed the book. If you want to further your learning, here's a few resources to keep you going. Academic Books Statistics \"Statistical Analysis of Network Data\" is an incredible resource for learning how to analyze graph data from a statistical viewpoint. It is written by Boston University's professor of mathematics Eric D. Kolaczyck. I used it during graduate school as part of my personnal learning journey. The book's website can be found here , and is available on Amazon (click on the book link below). Network Science This is a book by Prof. Albert-Laszlo Barabasi, and is freely available online . In it, he explores network analysis from the perspective of an applied academic discipline, showing universal properties and processes that underly networks. Think Complexity This is a book by Prof. Allen Downey at the Olin College of Engineering. In fact, this was the first book that exposed me (Eric Ma) to network science and its ideas, which thus inspired my thesis topic, which then gave me the impetus to learn graph theory and make this tutorial. I hope it becomes a useful thing for you too. You can find the book at Green Tea Press for free, but do consider purchasing a copy to support Allen's work! Online Resources Snacks Snacks is a repository of network analysis learning tools curated in the same spirit as the \"Awesome-X\" repositories that show up on GitHub. You can find it here .","title":"Further Learning"},{"location":"learn-more/#academic-books","text":"Statistics \"Statistical Analysis of Network Data\" is an incredible resource for learning how to analyze graph data from a statistical viewpoint. It is written by Boston University's professor of mathematics Eric D. Kolaczyck. I used it during graduate school as part of my personnal learning journey. The book's website can be found here , and is available on Amazon (click on the book link below). Network Science This is a book by Prof. Albert-Laszlo Barabasi, and is freely available online . In it, he explores network analysis from the perspective of an applied academic discipline, showing universal properties and processes that underly networks. Think Complexity This is a book by Prof. Allen Downey at the Olin College of Engineering. In fact, this was the first book that exposed me (Eric Ma) to network science and its ideas, which thus inspired my thesis topic, which then gave me the impetus to learn graph theory and make this tutorial. I hope it becomes a useful thing for you too. You can find the book at Green Tea Press for free, but do consider purchasing a copy to support Allen's work!","title":"Academic Books"},{"location":"learn-more/#online-resources","text":"Snacks Snacks is a repository of network analysis learning tools curated in the same spirit as the \"Awesome-X\" repositories that show up on GitHub. You can find it here .","title":"Online Resources"},{"location":"00-preface/01-setup/","text":"Introduction In order to get the most of this book, you will want to be able to execute the examples in the notebooks, modify them, break the code, and fix it. Pedagogically, that is the best way for you to learn the concepts. Here are the recommended ways in which you can get set up. Binder We recommend the use of Binder! This is because Binder will automagically setup an isolated and ephemeral compute environment for you with all of the packages needed to run the code in your notebooks. As such, you won't have to wrestle with anything at the terminal. To go there, click on the following button: Once you're in there, do a final setup step, by opening up a terminal in the Jupyter session, and installing the custom package nams that we wrote, which contains data loaders and solutions. # In the root directory of the repository python setup.py develop conda environments We also recommend the use of conda environments! If you are feeling confident enough to set up a conda environment at the terminal, then follow along. (We'll be assuming you've already cloned the repository locally.) Leverage the Makefile We've provided a Makefile with a single command: make conda On most *nix systems, that should get you most of the way to having the environment setup. Alternative: Execute individual commands If you encounter errors, then you should know that the Makefile command make conda basically wraps the following steps. Firstly, it creates the conda environment based on the environment.yml file: conda env create -f environment.yml Next, it activates the environment: conda activate nams We have a custom module for the project, which is called nams , that you will have to install. # In the root directory of the cloned repository python setup.py develop Finally, it runs a check on the environment to make sure everything is installed correctly: python checkenv.py venv environments If you're not a conda user, then you can use venv to create your environment. Leverage the Makefile As with the conda commands, you should be able to execute a single Makefile command at your terminal: make venv Special heartfelt thanks goes out to GitHub user @matt-land who contributed the venv script.","title":"Get Setup"},{"location":"00-preface/01-setup/#introduction","text":"In order to get the most of this book, you will want to be able to execute the examples in the notebooks, modify them, break the code, and fix it. Pedagogically, that is the best way for you to learn the concepts. Here are the recommended ways in which you can get set up.","title":"Introduction"},{"location":"00-preface/01-setup/#binder","text":"We recommend the use of Binder! This is because Binder will automagically setup an isolated and ephemeral compute environment for you with all of the packages needed to run the code in your notebooks. As such, you won't have to wrestle with anything at the terminal. To go there, click on the following button: Once you're in there, do a final setup step, by opening up a terminal in the Jupyter session, and installing the custom package nams that we wrote, which contains data loaders and solutions. # In the root directory of the repository python setup.py develop","title":"Binder"},{"location":"00-preface/01-setup/#conda-environments","text":"We also recommend the use of conda environments! If you are feeling confident enough to set up a conda environment at the terminal, then follow along. (We'll be assuming you've already cloned the repository locally.)","title":"conda environments"},{"location":"00-preface/01-setup/#leverage-the-makefile","text":"We've provided a Makefile with a single command: make conda On most *nix systems, that should get you most of the way to having the environment setup.","title":"Leverage the Makefile"},{"location":"00-preface/01-setup/#alternative-execute-individual-commands","text":"If you encounter errors, then you should know that the Makefile command make conda basically wraps the following steps. Firstly, it creates the conda environment based on the environment.yml file: conda env create -f environment.yml Next, it activates the environment: conda activate nams We have a custom module for the project, which is called nams , that you will have to install. # In the root directory of the cloned repository python setup.py develop Finally, it runs a check on the environment to make sure everything is installed correctly: python checkenv.py","title":"Alternative: Execute individual commands"},{"location":"00-preface/01-setup/#venv-environments","text":"If you're not a conda user, then you can use venv to create your environment.","title":"venv environments"},{"location":"00-preface/01-setup/#leverage-the-makefile_1","text":"As with the conda commands, you should be able to execute a single Makefile command at your terminal: make venv Special heartfelt thanks goes out to GitHub user @matt-land who contributed the venv script.","title":"Leverage the Makefile"},{"location":"00-preface/02-prereqs/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); To get maximum benefit from this book, you should know how to program in Python. (Hint: it's an extremely useful skill to know!) In particular, knowing how to: use dictionaries, write list comprehensions, and handle pandas DataFrames, will help you a ton during the tutorial. Exercises We have a few exercises below that should help you get warmed up. Exercise 1 Given the following line of code: [ s for s in my_fav_things if s [ \u2018 name \u2019 ] == \u2018 raindrops on roses \u2019 ] What are plausible data structures for s and my_fav_things ? Exercise 2 Given the following data: names = [ { 'name' : 'Eric' , 'surname' : 'Ma' }, { 'name' : 'Jeffrey' , 'surname' : 'Elmer' }, { 'name' : 'Mike' , 'surname' : 'Lee' }, { 'name' : 'Jennifer' , 'surname' : 'Elmer' } ] Write a function that takes in the names list of dictionaries and returns the dictionaries in which the surname value matches exactly some query_surname . def find_persons_with_surname ( persons , query_surname ): # Assert that the persons parameter is a list. # This is a good defensive programming practice. assert isinstance ( persons , list ) results = [] for ______ in ______ : if ___________ == __________ : results . append ( ________ ) return results To test your implementation, check it with the following code. No errors should be raised. # Test your result below. # results = find_persons_with_surname(names, 'Lee') # assert len(results) == 1 # results = find_persons_with_surname(names, 'Elmer') # assert len(results) == 2","title":"Prerequisites"},{"location":"00-preface/02-prereqs/#exercises","text":"We have a few exercises below that should help you get warmed up.","title":"Exercises"},{"location":"00-preface/02-prereqs/#exercise-1","text":"Given the following line of code: [ s for s in my_fav_things if s [ \u2018 name \u2019 ] == \u2018 raindrops on roses \u2019 ] What are plausible data structures for s and my_fav_things ?","title":"Exercise 1"},{"location":"00-preface/02-prereqs/#exercise-2","text":"Given the following data: names = [ { 'name' : 'Eric' , 'surname' : 'Ma' }, { 'name' : 'Jeffrey' , 'surname' : 'Elmer' }, { 'name' : 'Mike' , 'surname' : 'Lee' }, { 'name' : 'Jennifer' , 'surname' : 'Elmer' } ] Write a function that takes in the names list of dictionaries and returns the dictionaries in which the surname value matches exactly some query_surname . def find_persons_with_surname ( persons , query_surname ): # Assert that the persons parameter is a list. # This is a good defensive programming practice. assert isinstance ( persons , list ) results = [] for ______ in ______ : if ___________ == __________ : results . append ( ________ ) return results To test your implementation, check it with the following code. No errors should be raised. # Test your result below. # results = find_persons_with_surname(names, 'Lee') # assert len(results) == 1 # results = find_persons_with_surname(names, 'Elmer') # assert len(results) == 2","title":"Exercise 2"},{"location":"00-preface/03-goals/","text":"Our learning goals for you with this book can be split into the technical and the intellectual. Technical Takeaways Firstly, we would like to equip you to be familiar with the NetworkX application programming interface (API). The reason for choosing NetworkX is because it is extremely beginner-friendly, and has an API that matches graph theory concepts very closely. Secondly, we would like to show you how you can visualize graph data in a fashion that doesn't involve showing mere hairballs. Throughout the book, you will see examples of what we call rational graph visualizations . One of our authors, Eric Ma, has developed a companion package, nxviz , that provides a declarative and convenient API (in other words an attempt at a \"grammar\") for graph visualization. Thirdly, in this book, you will be introduced to basic graph algorithms, such as finding special graph structures, or finding paths in a graph. Graph algorithms will show you how to \"think on graphs\", and knowing how to do so will broaden your ability to interact with graph data structures. Fourthly, you will also be equipped with the connection between graph theory and other areas of math and computing, such as statistical inference and linear algebra. Intellectual Goals Beyond the technical takeaways, we hope to broaden how you think about data. The first idea we hope to give you the ability to think about your data in terms of \"relationships\". As you will learn, relationships are what give rise to the interestingness of graphs. That's where relational insights can come to fore. The second idea we hope to give you is the ability to \"think on graphs\". This comes with practice. Once you master it, though, you will find yourself becoming more and more familiar with algorithmic thinking . which is where you look at a problem in terms of the algorithm that solves it.","title":"Learning Goals"},{"location":"00-preface/03-goals/#technical-takeaways","text":"Firstly, we would like to equip you to be familiar with the NetworkX application programming interface (API). The reason for choosing NetworkX is because it is extremely beginner-friendly, and has an API that matches graph theory concepts very closely. Secondly, we would like to show you how you can visualize graph data in a fashion that doesn't involve showing mere hairballs. Throughout the book, you will see examples of what we call rational graph visualizations . One of our authors, Eric Ma, has developed a companion package, nxviz , that provides a declarative and convenient API (in other words an attempt at a \"grammar\") for graph visualization. Thirdly, in this book, you will be introduced to basic graph algorithms, such as finding special graph structures, or finding paths in a graph. Graph algorithms will show you how to \"think on graphs\", and knowing how to do so will broaden your ability to interact with graph data structures. Fourthly, you will also be equipped with the connection between graph theory and other areas of math and computing, such as statistical inference and linear algebra.","title":"Technical Takeaways"},{"location":"00-preface/03-goals/#intellectual-goals","text":"Beyond the technical takeaways, we hope to broaden how you think about data. The first idea we hope to give you the ability to think about your data in terms of \"relationships\". As you will learn, relationships are what give rise to the interestingness of graphs. That's where relational insights can come to fore. The second idea we hope to give you is the ability to \"think on graphs\". This comes with practice. Once you master it, though, you will find yourself becoming more and more familiar with algorithmic thinking . which is where you look at a problem in terms of the algorithm that solves it.","title":"Intellectual Goals"},{"location":"00-preface/preface/","text":"Hey, thanks for picking up this e-Book. We had a ton of fun making the material, and we hope you have a ton of fun learning new things from it too. Applied network analysis, and graph theory concepts, are getting more and more relevant in our world. Graph problems are abound. Once you pick up how to use graphs in an applied setting, you'll find your view of data problems change tremendously. We hope this book can become part of your learning journey. The act of purchasing this book means you've chosen to support us, the authors. It means a ton to us, as this book is the culmination of 5 years of learning and teaching applied network analysis at conferences around the world. The reason we went with LeanPub to publish this book is this: For as long as we issue updates to the book, you will also receive an updated copy of it. And because the book is digital, it's easy for us to get updates out to you. Just so you know, the full text of the book is available online too, at the accompanying website, https://ericmjl.github.io/Network-Analysis-Made-Simple. On there, you'll find a link to Binder so you can interact with the code, and through the act of playing around with the code and breaking it yourself, learn new things. (Breaking code and fixing it is something you should be doing - it's one of the best ways to learn!) If you have questions about the content, or find an errata that you'd like to point out, please head over to https://github.com/ericmjl/Network-Analysis-Made-Simple/, and post an issue up there. We'll be sure to address it and acknowledge it appropriately. We hope that this book becomes a stepping stone in your learning journey. Enjoy! Eric & Mridul","title":"Preface"},{"location":"01-introduction/01-graphs/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Introduction from IPython.display import YouTubeVideo YouTubeVideo ( id = \"k4KHoLC7TFE\" , width = \"100%\" ) In our world, networks are an immensely useful data modelling tool to model complex relational problems. Building on top of a network-oriented data model, they have been put to great use in a wide variety of settings. A formal definition of networks Before we explore examples of networks, we want to first give you a more formal definition of what networks are. The reason is that knowing a formal definition helps us refine our application of networks. So bear with me for a moment. In the slightly more academic literature, networks are more formally referred to as graphs . Graphs are comprised of two sets of objects: A node set : the \"entities\" in a graph. An edge set : the record of \"relationships\" between the entities in the graph. For example, if a node set n n is comprised of elements: n = \\{a, b, c, d, ...\\} n = \\{a, b, c, d, ...\\} Then, the edge set e e would be represented as tuples of pairs of elements: e = \\{(a, b), (a, c), (c, d), ...\\} e = \\{(a, b), (a, c), (c, d), ...\\} If you extracted every node from the edge set e e , it should form at least a subset of the node set n n . (It is at least a subset because not every node in n n might participate in an edge.) If you draw out a network, the \"nodes\" are commonly represented as shapes, such as circles, while the \"edges\" are the lines between the shapes. Examples of Networks Now that we have a proper definition of a graph, let's move on to explore examples of graphs. One example I (Eric Ma) am fond of, based on my background as a biologist, is a protein-protein interaction network. Here, the graph can be defined in the following way: nodes/entities are the proteins, edges/relationships are defined as \"one protein is known to bind with another\". A more colloquial example of networks is an air transportation network. Here, the graph can be defined in the following way: nodes/entities are airports edges/relationships are defined as \"at least one flight carrier flies between the airports\". And another even more relatable example would be our ever-prevalent social networks! With Twitter, the graph can be defined in the following way: nodes/entities are individual users edges/relationships are defined as \"one user has decided to follow another\". Now that you've seen the framework for defining a graph, we'd like to invite you to answer the following question: What examples of networks have you seen before in your profession? Go ahead and list it out. Types of Graphs As you probably can see, graphs are a really flexible data model for modelling the world, as long as the nodes and edges are strictly defined. (If the nodes and edges are sloppily defined, well, we run into a lot of interpretability problems later on.) If you are a member of both LinkedIn and Twitter, you might intuitively think that there's a slight difference in the structure of the two \"social graphs\". You'd be absolutely correct on that count! Twitter is an example of what we would intuitively call a directed graph. Why is this so? The key here lies in how interactions are modelled. One user can follow another, but the other need not necessarily follow back. As such, there is a directionality to the relationship. LinkedIn is an example of what we would intuitively call an undirected graph. Why is this so? The key here is that when two users are LinkedIn connections, we automatically assign a bi-directional edge between them. As such, for convenience, we can collapse the bi-directional edge into an undirected edge, thus yielding an undirected graph. If we wanted to turn LinkedIn into a directed graph, we might want to keep information on who initiated the invitation. In that way, the relationship is automatically bi-directional. Edges define the interesting part of a graph While in graduate school, I (Eric Ma) once sat in a seminar organized by one of the professors on my thesis committee. The speaker that day was John Quackenbush, a faculty member of the Harvard School of Public Health. While the topic of the day remained fuzzy in my memory, one quote stood out: The heart of a graph lies in its edges, not in its nodes. (John Quackenbush, Harvard School of Public Health) Indeed, this is a key point to remember! Without edges, the nodes are merely collections of entities. In a data table, they would correspond to the rows. That alone can be interesting, but doesn't yield relational insights between the entities.","title":"Chapter 1: Introduction to Graphs"},{"location":"01-introduction/01-graphs/#introduction","text":"from IPython.display import YouTubeVideo YouTubeVideo ( id = \"k4KHoLC7TFE\" , width = \"100%\" ) In our world, networks are an immensely useful data modelling tool to model complex relational problems. Building on top of a network-oriented data model, they have been put to great use in a wide variety of settings.","title":"Introduction"},{"location":"01-introduction/01-graphs/#a-formal-definition-of-networks","text":"Before we explore examples of networks, we want to first give you a more formal definition of what networks are. The reason is that knowing a formal definition helps us refine our application of networks. So bear with me for a moment. In the slightly more academic literature, networks are more formally referred to as graphs . Graphs are comprised of two sets of objects: A node set : the \"entities\" in a graph. An edge set : the record of \"relationships\" between the entities in the graph. For example, if a node set n n is comprised of elements: n = \\{a, b, c, d, ...\\} n = \\{a, b, c, d, ...\\} Then, the edge set e e would be represented as tuples of pairs of elements: e = \\{(a, b), (a, c), (c, d), ...\\} e = \\{(a, b), (a, c), (c, d), ...\\} If you extracted every node from the edge set e e , it should form at least a subset of the node set n n . (It is at least a subset because not every node in n n might participate in an edge.) If you draw out a network, the \"nodes\" are commonly represented as shapes, such as circles, while the \"edges\" are the lines between the shapes.","title":"A formal definition of networks"},{"location":"01-introduction/01-graphs/#examples-of-networks","text":"Now that we have a proper definition of a graph, let's move on to explore examples of graphs. One example I (Eric Ma) am fond of, based on my background as a biologist, is a protein-protein interaction network. Here, the graph can be defined in the following way: nodes/entities are the proteins, edges/relationships are defined as \"one protein is known to bind with another\". A more colloquial example of networks is an air transportation network. Here, the graph can be defined in the following way: nodes/entities are airports edges/relationships are defined as \"at least one flight carrier flies between the airports\". And another even more relatable example would be our ever-prevalent social networks! With Twitter, the graph can be defined in the following way: nodes/entities are individual users edges/relationships are defined as \"one user has decided to follow another\". Now that you've seen the framework for defining a graph, we'd like to invite you to answer the following question: What examples of networks have you seen before in your profession? Go ahead and list it out.","title":"Examples of Networks"},{"location":"01-introduction/01-graphs/#types-of-graphs","text":"As you probably can see, graphs are a really flexible data model for modelling the world, as long as the nodes and edges are strictly defined. (If the nodes and edges are sloppily defined, well, we run into a lot of interpretability problems later on.) If you are a member of both LinkedIn and Twitter, you might intuitively think that there's a slight difference in the structure of the two \"social graphs\". You'd be absolutely correct on that count! Twitter is an example of what we would intuitively call a directed graph. Why is this so? The key here lies in how interactions are modelled. One user can follow another, but the other need not necessarily follow back. As such, there is a directionality to the relationship. LinkedIn is an example of what we would intuitively call an undirected graph. Why is this so? The key here is that when two users are LinkedIn connections, we automatically assign a bi-directional edge between them. As such, for convenience, we can collapse the bi-directional edge into an undirected edge, thus yielding an undirected graph. If we wanted to turn LinkedIn into a directed graph, we might want to keep information on who initiated the invitation. In that way, the relationship is automatically bi-directional.","title":"Types of Graphs"},{"location":"01-introduction/01-graphs/#edges-define-the-interesting-part-of-a-graph","text":"While in graduate school, I (Eric Ma) once sat in a seminar organized by one of the professors on my thesis committee. The speaker that day was John Quackenbush, a faculty member of the Harvard School of Public Health. While the topic of the day remained fuzzy in my memory, one quote stood out: The heart of a graph lies in its edges, not in its nodes. (John Quackenbush, Harvard School of Public Health) Indeed, this is a key point to remember! Without edges, the nodes are merely collections of entities. In a data table, they would correspond to the rows. That alone can be interesting, but doesn't yield relational insights between the entities.","title":"Edges define the interesting part of a graph"},{"location":"01-introduction/02-networkx-intro/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); % load_ext autoreload % autoreload 2 % matplotlib inline % config InlineBackend . figure_format = 'retina' Introduction from IPython.display import YouTubeVideo YouTubeVideo ( id = 'sdF0uJo2KdU' , width = \"100%\" ) In this chapter, we will introduce you to the NetworkX API. This will allow you to create and manipulate graphs in your computer memory, thus giving you a language to more concretely explore graph theory ideas. Throughout the book, we will be using different graph datasets to help us anchor ideas. In this section, we will work with a social network of seventh graders. Here, nodes are individual students, and edges represent their relationships. Edges between individuals show how often the seventh graders indicated other seventh graders as their favourite. The data are taken from the Konect graph data repository Data Model In NetworkX, graph data are stored in a dictionary-like fashion. They are placed under a Graph object, canonically instantiated with the variable G as follows: G = nx . Graph () Of course, you are free to name the graph anything you want! Nodes are part of the attribute G.nodes . There, the node data are housed in a dictionary-like container, where the key is the node ID and the values are a dictionary of attributes. Node data are accessible using syntax that looks like: G . nodes [ node1 ] Edges are part of the attribute G.edges , which is also stored in a dictionary-like container. Edge data are accessible using syntax that looks like: G . edges [ node1 , node2 ] Because of the dictionary-like implementation of the graph, any hashable object can be a node. This means strings and tuples, but not lists and sets. Load Data Let's load some real network data to get a feel for the NetworkX API. This dataset comes from a study of 7th grade students. This directed network contains proximity ratings between students from 29 seventh grade students from a school in Victoria. Among other questions the students were asked to nominate their preferred classmates for three different activities. A node represents a student. An edge between two nodes shows that the left student picked the right student as his or her answer. The edge weights are between 1 and 3 and show how often the left student chose the right student as his/her favourite. In the original dataset, students were from an all-boys school. However, I have modified the dataset to instead be a mixed-gender school. import networkx as nx from datetime import datetime import matplotlib.pyplot as plt import numpy as np import warnings from nams import load_data as cf warnings . filterwarnings ( 'ignore' ) G = cf . load_seventh_grader_network () Understanding a graph's basic statistics When you get graph data, one of the first things you'll want to do is to check its basic graph statistics: the number of nodes and the number of edges that are represented in the graph. This is a basic sanity-check on your data that you don't want to skip out on. Querying graph type The first thing you need to know is the type of the graph: type ( G ) networkx.classes.digraph.DiGraph Because the graph is a DiGraph , this tells us that the graph is a directed one. If it were undirected, the type would change: H = nx . Graph () type ( H ) networkx.classes.graph.Graph Querying node information Let's now query for the nodeset: list ( G . nodes ())[ 0 : 5 ] [1, 2, 3, 4, 5] G.nodes() returns a \"view\" on the nodes. We can't actually slice into the view and grab out a sub-selection, but we can at least see what nodes are present. For brevity, we have sliced into G.nodes() passed into a list() constructor, so that we don't pollute the output. Because a NodeView is iterable, though, we can query it for its length: len ( G . nodes ()) 29 If our nodes have metadata attached to them, we can view the metadata at the same time by passing in data=True : list ( G . nodes ( data = True ))[ 0 : 5 ] [(1, {'gender': 'male'}), (2, {'gender': 'male'}), (3, {'gender': 'male'}), (4, {'gender': 'male'}), (5, {'gender': 'male'})] G.nodes(data=True) returns a NodeDataView , which you can see is dictionary-like. Additionally, we can select out individual nodes: G . nodes [ 1 ] {'gender': 'male'} Now, because a NodeDataView is dictionary-like, looping over G.nodes(data=True) is very much like looping over key-value pairs of a dictionary. As such, we can write things like: for n , d in G . nodes ( data = True ): # n is the node # d is the metadata dictionary ... This is analogous to how we would loop over a dictionary: for k , v in dictionary . items (): # do stuff in the loop Naturally, this leads us to our first exercise. Exercise: Summarizing node metadata Can you count how many males and females are represented in the graph? from nams.solutions.intro import node_metadata #### REPLACE THE NEXT LINE WITH YOUR ANSWER mf_counts = node_metadata ( G ) Test your implementation by checking it against the test_answer function below. from typing import Dict def test_answer ( mf_counts : Dict ): assert mf_counts [ 'female' ] == 17 assert mf_counts [ 'male' ] == 12 test_answer ( mf_counts ) With this dictionary-like syntax, we can query back the metadata that's associated with any node. Querying edge information Now that you've learned how to query for node information, let's now see how to query for all of the edges in the graph: list ( G . edges ())[ 0 : 5 ] [(1, 2), (1, 3), (1, 4), (1, 5), (1, 6)] Similar to the NodeView , G.edges() returns an EdgeView that is also iterable. As with above, we have abbreviated the output inside a sliced list to keep things readable. Because G.edges() is iterable, we can get its length to see the number of edges that are present in a graph. len ( G . edges ()) 376 Likewise, we can also query for all of the edge's metadata: list ( G . edges ( data = True ))[ 0 : 5 ] [(1, 2, {'count': 1}), (1, 3, {'count': 1}), (1, 4, {'count': 2}), (1, 5, {'count': 2}), (1, 6, {'count': 3})] Additionally, it is possible for us to select out individual edges, as long as they exist in the graph: G . edges [ 15 , 10 ] {'count': 2} This yields the metadata dictionary for that edge. If the edge does not exist, then we get an error: >>> G . edges [ 15 , 16 ] --------------------------------------------------------------------------- KeyError Traceback ( most recent call last ) < ipython - input - 21 - ce014cab875a > in < module > ----> 1 G . edges [ 15 , 16 ] ~/ anaconda / envs / nams / lib / python3 . 7 / site - packages / networkx / classes / reportviews . py in __getitem__ ( self , e ) 928 def __getitem__ ( self , e ): 929 u , v = e --> 930 return self . _adjdict [ u ][ v ] 931 932 # EdgeDataView methods KeyError : 16 As with the NodeDataView , the EdgeDataView is dictionary-like, with the difference being that the keys are 2-tuple-like instead of being single hashable objects. Thus, we can write syntax like the following to loop over the edgelist: for n1 , n2 , d in G . edges ( data = True ): # n1, n2 are the nodes # d is the metadata dictionary ... Naturally, this leads us to our next exercise. Exercise: Summarizing edge metadata Can you write code to verify that the maximum times any student rated another student as their favourite is 3 times? from nams.solutions.intro import edge_metadata #### REPLACE THE NEXT LINE WITH YOUR ANSWER maxcount = edge_metadata ( G ) Likewise, you can test your answer using the test function below: def test_maxcount ( maxcount ): assert maxcount == 3 test_maxcount ( maxcount ) Manipulating the graph Great stuff! You now know how to query a graph for: its node set, optionally including metadata individual node metadata its edge set, optionally including metadata, and individual edges' metadata Now, let's learn how to manipulate the graph. Specifically, we'll learn how to add nodes and edges to a graph. Adding Nodes The NetworkX graph API lets you add a node easily: G . add_node ( node , node_data1 = some_value , node_data2 = some_value ) Adding Edges It also allows you to add an edge easily: G . add_edge ( node1 , node2 , edge_data1 = some_value , edge_data2 = some_value ) Metadata by Keyword Arguments In both cases, the keyword arguments that are passed into .add_node() are automatically collected into the metadata dictionary. Knowing this gives you enough knowledge to tackle the next exercise. Exercise: adding students to the graph We found out that there are two students that we left out of the network, student no. 30 and 31. They are one male (30) and one female (31), and they are a pair that just love hanging out with one another and with individual 7 (i.e. count=3 ), in both directions per pair. Add this information to the graph. from nams.solutions.intro import adding_students #### REPLACE THE NEXT LINE WITH YOUR ANSWER G = adding_students ( G ) You can verify that the graph has been correctly created by executing the test function below. def test_graph_integrity ( G ): assert 30 in G . nodes () assert 31 in G . nodes () assert G . nodes [ 30 ][ 'gender' ] == 'male' assert G . nodes [ 31 ][ 'gender' ] == 'female' assert G . has_edge ( 30 , 31 ) assert G . has_edge ( 30 , 7 ) assert G . has_edge ( 31 , 7 ) assert G . edges [ 30 , 7 ][ 'count' ] == 3 assert G . edges [ 7 , 30 ][ 'count' ] == 3 assert G . edges [ 31 , 7 ][ 'count' ] == 3 assert G . edges [ 7 , 31 ][ 'count' ] == 3 assert G . edges [ 30 , 31 ][ 'count' ] == 3 assert G . edges [ 31 , 30 ][ 'count' ] == 3 print ( 'All tests passed.' ) test_graph_integrity ( G ) All tests passed. Coding Patterns These are some recommended coding patterns when doing network analysis using NetworkX, which stem from my personal experience with the package. Iterating using List Comprehensions I would recommend that you use the following for compactness: [ d [ 'attr' ] for n , d in G . nodes ( data = True )] And if the node is unimportant, you can do: [ d [ 'attr' ] for _ , d in G . nodes ( data = True )] Iterating over Edges using List Comprehensions A similar pattern can be used for edges: [ n2 for n1 , n2 , d in G . edges ( data = True )] or [ n2 for _ , n2 , d in G . edges ( data = True )] If the graph you are constructing is a directed graph, with a \"source\" and \"sink\" available, then I would recommend the following naming of variables instead: [( sc , sk ) for sc , sk , d in G . edges ( data = True )] or [ d [ 'attr' ] for sc , sk , d in G . edges ( data = True )] Further Reading For a deeper look at the NetworkX API, be sure to check out the NetworkX docs . Further Exercises Here's some further exercises that you can use to get some practice. Exercise: Unrequited Friendships Try figuring out which students have \"unrequited\" friendships, that is, they have rated another student as their favourite at least once, but that other student has not rated them as their favourite at least once. Hint: the goal here is to get a list of edges for which the reverse edge is not present. Hint: You may need the class method G.has_edge(n1, n2) . This returns whether a graph has an edge between the nodes n1 and n2 . from nams.solutions.intro import unrequitted_friendships_v1 #### REPLACE THE NEXT LINE WITH YOUR ANSWER unrequitted_friendships = unrequitted_friendships_v1 ( G ) assert len ( unrequitted_friendships ) == 124 In a previous session at ODSC East 2018, a few other class participants provided the following solutions, which you can take a look at by uncommenting the following cells. This first one by @schwanne is the list comprehension version of the above solution: from nams.solutions.intro import unrequitted_friendships_v2 # unrequitted_friendships_v2?? This one by @end0 is a unique one involving sets. from nams.solutions.intro import unrequitted_friendships_v3 # unrequitted_friendships_v3?? Solution Answers Here are the answers to the exercises above. import nams.solutions.intro as solutions import inspect print ( inspect . getsource ( solutions )) \"\"\" Solutions to Intro Chapter. \"\"\" def node_metadata(G): \"\"\"Counts of students of each gender.\"\"\" from collections import Counter mf_counts = Counter([d[\"gender\"] for n, d in G.nodes(data=True)]) return mf_counts def edge_metadata(G): \"\"\"Maximum number of times that a student rated another student.\"\"\" counts = [d[\"count\"] for n1, n2, d in G.edges(data=True)] maxcount = max(counts) return maxcount def adding_students(G): \"\"\"How to nodes and edges to a graph.\"\"\" G = G.copy() G.add_node(30, gender=\"male\") G.add_node(31, gender=\"female\") G.add_edge(30, 31, count=3) G.add_edge(31, 30, count=3) # reverse is optional in undirected network G.add_edge(30, 7, count=3) # but this network is directed G.add_edge(7, 30, count=3) G.add_edge(31, 7, count=3) G.add_edge(7, 31, count=3) return G def unrequitted_friendships_v1(G): \"\"\"Answer to unrequitted friendships problem.\"\"\" unrequitted_friendships = [] for n1, n2 in G.edges(): if not G.has_edge(n2, n1): unrequitted_friendships.append((n1, n2)) return unrequitted_friendships def unrequitted_friendships_v2(G): \"\"\"Alternative answer to unrequitted friendships problem. By @schwanne.\"\"\" return len([(n1, n2) for n1, n2 in G.edges() if not G.has_edge(n2, n1)]) def unrequitted_friendships_v3(G): \"\"\"Alternative answer to unrequitted friendships problem. By @end0.\"\"\" links = ((n1, n2) for n1, n2, d in G.edges(data=True)) reverse_links = ((n2, n1) for n1, n2, d in G.edges(data=True)) return len(list(set(links) - set(reverse_links)))","title":"Chapter 2: The NetworkX API"},{"location":"01-introduction/02-networkx-intro/#introduction","text":"from IPython.display import YouTubeVideo YouTubeVideo ( id = 'sdF0uJo2KdU' , width = \"100%\" ) In this chapter, we will introduce you to the NetworkX API. This will allow you to create and manipulate graphs in your computer memory, thus giving you a language to more concretely explore graph theory ideas. Throughout the book, we will be using different graph datasets to help us anchor ideas. In this section, we will work with a social network of seventh graders. Here, nodes are individual students, and edges represent their relationships. Edges between individuals show how often the seventh graders indicated other seventh graders as their favourite. The data are taken from the Konect graph data repository","title":"Introduction"},{"location":"01-introduction/02-networkx-intro/#data-model","text":"In NetworkX, graph data are stored in a dictionary-like fashion. They are placed under a Graph object, canonically instantiated with the variable G as follows: G = nx . Graph () Of course, you are free to name the graph anything you want! Nodes are part of the attribute G.nodes . There, the node data are housed in a dictionary-like container, where the key is the node ID and the values are a dictionary of attributes. Node data are accessible using syntax that looks like: G . nodes [ node1 ] Edges are part of the attribute G.edges , which is also stored in a dictionary-like container. Edge data are accessible using syntax that looks like: G . edges [ node1 , node2 ] Because of the dictionary-like implementation of the graph, any hashable object can be a node. This means strings and tuples, but not lists and sets.","title":"Data Model"},{"location":"01-introduction/02-networkx-intro/#load-data","text":"Let's load some real network data to get a feel for the NetworkX API. This dataset comes from a study of 7th grade students. This directed network contains proximity ratings between students from 29 seventh grade students from a school in Victoria. Among other questions the students were asked to nominate their preferred classmates for three different activities. A node represents a student. An edge between two nodes shows that the left student picked the right student as his or her answer. The edge weights are between 1 and 3 and show how often the left student chose the right student as his/her favourite. In the original dataset, students were from an all-boys school. However, I have modified the dataset to instead be a mixed-gender school. import networkx as nx from datetime import datetime import matplotlib.pyplot as plt import numpy as np import warnings from nams import load_data as cf warnings . filterwarnings ( 'ignore' ) G = cf . load_seventh_grader_network ()","title":"Load Data"},{"location":"01-introduction/02-networkx-intro/#understanding-a-graphs-basic-statistics","text":"When you get graph data, one of the first things you'll want to do is to check its basic graph statistics: the number of nodes and the number of edges that are represented in the graph. This is a basic sanity-check on your data that you don't want to skip out on.","title":"Understanding a graph's basic statistics"},{"location":"01-introduction/02-networkx-intro/#querying-graph-type","text":"The first thing you need to know is the type of the graph: type ( G ) networkx.classes.digraph.DiGraph Because the graph is a DiGraph , this tells us that the graph is a directed one. If it were undirected, the type would change: H = nx . Graph () type ( H ) networkx.classes.graph.Graph","title":"Querying graph type"},{"location":"01-introduction/02-networkx-intro/#querying-node-information","text":"Let's now query for the nodeset: list ( G . nodes ())[ 0 : 5 ] [1, 2, 3, 4, 5] G.nodes() returns a \"view\" on the nodes. We can't actually slice into the view and grab out a sub-selection, but we can at least see what nodes are present. For brevity, we have sliced into G.nodes() passed into a list() constructor, so that we don't pollute the output. Because a NodeView is iterable, though, we can query it for its length: len ( G . nodes ()) 29 If our nodes have metadata attached to them, we can view the metadata at the same time by passing in data=True : list ( G . nodes ( data = True ))[ 0 : 5 ] [(1, {'gender': 'male'}), (2, {'gender': 'male'}), (3, {'gender': 'male'}), (4, {'gender': 'male'}), (5, {'gender': 'male'})] G.nodes(data=True) returns a NodeDataView , which you can see is dictionary-like. Additionally, we can select out individual nodes: G . nodes [ 1 ] {'gender': 'male'} Now, because a NodeDataView is dictionary-like, looping over G.nodes(data=True) is very much like looping over key-value pairs of a dictionary. As such, we can write things like: for n , d in G . nodes ( data = True ): # n is the node # d is the metadata dictionary ... This is analogous to how we would loop over a dictionary: for k , v in dictionary . items (): # do stuff in the loop Naturally, this leads us to our first exercise.","title":"Querying node information"},{"location":"01-introduction/02-networkx-intro/#exercise-summarizing-node-metadata","text":"Can you count how many males and females are represented in the graph? from nams.solutions.intro import node_metadata #### REPLACE THE NEXT LINE WITH YOUR ANSWER mf_counts = node_metadata ( G ) Test your implementation by checking it against the test_answer function below. from typing import Dict def test_answer ( mf_counts : Dict ): assert mf_counts [ 'female' ] == 17 assert mf_counts [ 'male' ] == 12 test_answer ( mf_counts ) With this dictionary-like syntax, we can query back the metadata that's associated with any node.","title":"Exercise: Summarizing node metadata"},{"location":"01-introduction/02-networkx-intro/#querying-edge-information","text":"Now that you've learned how to query for node information, let's now see how to query for all of the edges in the graph: list ( G . edges ())[ 0 : 5 ] [(1, 2), (1, 3), (1, 4), (1, 5), (1, 6)] Similar to the NodeView , G.edges() returns an EdgeView that is also iterable. As with above, we have abbreviated the output inside a sliced list to keep things readable. Because G.edges() is iterable, we can get its length to see the number of edges that are present in a graph. len ( G . edges ()) 376 Likewise, we can also query for all of the edge's metadata: list ( G . edges ( data = True ))[ 0 : 5 ] [(1, 2, {'count': 1}), (1, 3, {'count': 1}), (1, 4, {'count': 2}), (1, 5, {'count': 2}), (1, 6, {'count': 3})] Additionally, it is possible for us to select out individual edges, as long as they exist in the graph: G . edges [ 15 , 10 ] {'count': 2} This yields the metadata dictionary for that edge. If the edge does not exist, then we get an error: >>> G . edges [ 15 , 16 ] --------------------------------------------------------------------------- KeyError Traceback ( most recent call last ) < ipython - input - 21 - ce014cab875a > in < module > ----> 1 G . edges [ 15 , 16 ] ~/ anaconda / envs / nams / lib / python3 . 7 / site - packages / networkx / classes / reportviews . py in __getitem__ ( self , e ) 928 def __getitem__ ( self , e ): 929 u , v = e --> 930 return self . _adjdict [ u ][ v ] 931 932 # EdgeDataView methods KeyError : 16 As with the NodeDataView , the EdgeDataView is dictionary-like, with the difference being that the keys are 2-tuple-like instead of being single hashable objects. Thus, we can write syntax like the following to loop over the edgelist: for n1 , n2 , d in G . edges ( data = True ): # n1, n2 are the nodes # d is the metadata dictionary ... Naturally, this leads us to our next exercise.","title":"Querying edge information"},{"location":"01-introduction/02-networkx-intro/#exercise-summarizing-edge-metadata","text":"Can you write code to verify that the maximum times any student rated another student as their favourite is 3 times? from nams.solutions.intro import edge_metadata #### REPLACE THE NEXT LINE WITH YOUR ANSWER maxcount = edge_metadata ( G ) Likewise, you can test your answer using the test function below: def test_maxcount ( maxcount ): assert maxcount == 3 test_maxcount ( maxcount )","title":"Exercise: Summarizing edge metadata"},{"location":"01-introduction/02-networkx-intro/#manipulating-the-graph","text":"Great stuff! You now know how to query a graph for: its node set, optionally including metadata individual node metadata its edge set, optionally including metadata, and individual edges' metadata Now, let's learn how to manipulate the graph. Specifically, we'll learn how to add nodes and edges to a graph.","title":"Manipulating the graph"},{"location":"01-introduction/02-networkx-intro/#adding-nodes","text":"The NetworkX graph API lets you add a node easily: G . add_node ( node , node_data1 = some_value , node_data2 = some_value )","title":"Adding Nodes"},{"location":"01-introduction/02-networkx-intro/#adding-edges","text":"It also allows you to add an edge easily: G . add_edge ( node1 , node2 , edge_data1 = some_value , edge_data2 = some_value )","title":"Adding Edges"},{"location":"01-introduction/02-networkx-intro/#metadata-by-keyword-arguments","text":"In both cases, the keyword arguments that are passed into .add_node() are automatically collected into the metadata dictionary. Knowing this gives you enough knowledge to tackle the next exercise.","title":"Metadata by Keyword Arguments"},{"location":"01-introduction/02-networkx-intro/#exercise-adding-students-to-the-graph","text":"We found out that there are two students that we left out of the network, student no. 30 and 31. They are one male (30) and one female (31), and they are a pair that just love hanging out with one another and with individual 7 (i.e. count=3 ), in both directions per pair. Add this information to the graph. from nams.solutions.intro import adding_students #### REPLACE THE NEXT LINE WITH YOUR ANSWER G = adding_students ( G ) You can verify that the graph has been correctly created by executing the test function below. def test_graph_integrity ( G ): assert 30 in G . nodes () assert 31 in G . nodes () assert G . nodes [ 30 ][ 'gender' ] == 'male' assert G . nodes [ 31 ][ 'gender' ] == 'female' assert G . has_edge ( 30 , 31 ) assert G . has_edge ( 30 , 7 ) assert G . has_edge ( 31 , 7 ) assert G . edges [ 30 , 7 ][ 'count' ] == 3 assert G . edges [ 7 , 30 ][ 'count' ] == 3 assert G . edges [ 31 , 7 ][ 'count' ] == 3 assert G . edges [ 7 , 31 ][ 'count' ] == 3 assert G . edges [ 30 , 31 ][ 'count' ] == 3 assert G . edges [ 31 , 30 ][ 'count' ] == 3 print ( 'All tests passed.' ) test_graph_integrity ( G ) All tests passed.","title":"Exercise: adding students to the graph"},{"location":"01-introduction/02-networkx-intro/#coding-patterns","text":"These are some recommended coding patterns when doing network analysis using NetworkX, which stem from my personal experience with the package.","title":"Coding Patterns"},{"location":"01-introduction/02-networkx-intro/#iterating-using-list-comprehensions","text":"I would recommend that you use the following for compactness: [ d [ 'attr' ] for n , d in G . nodes ( data = True )] And if the node is unimportant, you can do: [ d [ 'attr' ] for _ , d in G . nodes ( data = True )]","title":"Iterating using List Comprehensions"},{"location":"01-introduction/02-networkx-intro/#iterating-over-edges-using-list-comprehensions","text":"A similar pattern can be used for edges: [ n2 for n1 , n2 , d in G . edges ( data = True )] or [ n2 for _ , n2 , d in G . edges ( data = True )] If the graph you are constructing is a directed graph, with a \"source\" and \"sink\" available, then I would recommend the following naming of variables instead: [( sc , sk ) for sc , sk , d in G . edges ( data = True )] or [ d [ 'attr' ] for sc , sk , d in G . edges ( data = True )]","title":"Iterating over Edges using List Comprehensions"},{"location":"01-introduction/02-networkx-intro/#further-reading","text":"For a deeper look at the NetworkX API, be sure to check out the NetworkX docs .","title":"Further Reading"},{"location":"01-introduction/02-networkx-intro/#further-exercises","text":"Here's some further exercises that you can use to get some practice.","title":"Further Exercises"},{"location":"01-introduction/02-networkx-intro/#exercise-unrequited-friendships","text":"Try figuring out which students have \"unrequited\" friendships, that is, they have rated another student as their favourite at least once, but that other student has not rated them as their favourite at least once. Hint: the goal here is to get a list of edges for which the reverse edge is not present. Hint: You may need the class method G.has_edge(n1, n2) . This returns whether a graph has an edge between the nodes n1 and n2 . from nams.solutions.intro import unrequitted_friendships_v1 #### REPLACE THE NEXT LINE WITH YOUR ANSWER unrequitted_friendships = unrequitted_friendships_v1 ( G ) assert len ( unrequitted_friendships ) == 124 In a previous session at ODSC East 2018, a few other class participants provided the following solutions, which you can take a look at by uncommenting the following cells. This first one by @schwanne is the list comprehension version of the above solution: from nams.solutions.intro import unrequitted_friendships_v2 # unrequitted_friendships_v2?? This one by @end0 is a unique one involving sets. from nams.solutions.intro import unrequitted_friendships_v3 # unrequitted_friendships_v3??","title":"Exercise: Unrequited Friendships"},{"location":"01-introduction/02-networkx-intro/#solution-answers","text":"Here are the answers to the exercises above. import nams.solutions.intro as solutions import inspect print ( inspect . getsource ( solutions )) \"\"\" Solutions to Intro Chapter. \"\"\" def node_metadata(G): \"\"\"Counts of students of each gender.\"\"\" from collections import Counter mf_counts = Counter([d[\"gender\"] for n, d in G.nodes(data=True)]) return mf_counts def edge_metadata(G): \"\"\"Maximum number of times that a student rated another student.\"\"\" counts = [d[\"count\"] for n1, n2, d in G.edges(data=True)] maxcount = max(counts) return maxcount def adding_students(G): \"\"\"How to nodes and edges to a graph.\"\"\" G = G.copy() G.add_node(30, gender=\"male\") G.add_node(31, gender=\"female\") G.add_edge(30, 31, count=3) G.add_edge(31, 30, count=3) # reverse is optional in undirected network G.add_edge(30, 7, count=3) # but this network is directed G.add_edge(7, 30, count=3) G.add_edge(31, 7, count=3) G.add_edge(7, 31, count=3) return G def unrequitted_friendships_v1(G): \"\"\"Answer to unrequitted friendships problem.\"\"\" unrequitted_friendships = [] for n1, n2 in G.edges(): if not G.has_edge(n2, n1): unrequitted_friendships.append((n1, n2)) return unrequitted_friendships def unrequitted_friendships_v2(G): \"\"\"Alternative answer to unrequitted friendships problem. By @schwanne.\"\"\" return len([(n1, n2) for n1, n2 in G.edges() if not G.has_edge(n2, n1)]) def unrequitted_friendships_v3(G): \"\"\"Alternative answer to unrequitted friendships problem. By @end0.\"\"\" links = ((n1, n2) for n1, n2, d in G.edges(data=True)) reverse_links = ((n2, n1) for n1, n2, d in G.edges(data=True)) return len(list(set(links) - set(reverse_links)))","title":"Solution Answers"},{"location":"01-introduction/03-viz/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); % load_ext autoreload % autoreload 2 % matplotlib inline % config InlineBackend . figure_format = 'retina' Introduction from IPython.display import YouTubeVideo YouTubeVideo ( id = \"v9HrR_AF5Zc\" , width = \"100%\" ) In this chapter, We want to introduce you to the wonderful world of graph visualization. You probably have seen graphs that are visualized as hairballs. Apart from communicating how complex the graph is, hairballs don't really communicate much else. As such, my goal by the end of this chapter is to introduce you to what I call rational graph visualization . But before we can do that, let's first make sure we understand how to use NetworkX's drawing facilities to draw graphs to the screen. In a pinch, and for small graphs, it's very handy to have. Hairballs The node-link diagram is the canonical diagram we will see in publications. Nodes are commonly drawn as circles, while edges are drawn s lines. Node-link diagrams are common, and there's a good reason for this: it's convenient to draw! In NetworkX, we can draw node-link diagrams using: from nams import load_data as cf import networkx as nx import matplotlib.pyplot as plt G = cf . load_seventh_grader_network () nx . draw ( G ) Nodes more tightly connected with one another are clustered together. Initial node placement is done typically at random, so really it's tough to deterministically generate the same figure. If the network is small enough to visualize, and the node labels are small enough to fit in a circle, then you can use the with_labels=True argument to bring some degree of informativeness to the drawing: G . is_directed () True nx . draw ( G , with_labels = True ) The downside to drawing graphs this way is that large graphs end up looking like hairballs. Can you imagine a graph with more than the 28 nodes that we have? As you probably can imagine, the default nx.draw(G) is probably not suitable for generating visual insights. Matrix Plot A different way that we can visualize a graph is by visualizing it in its matrix form. The nodes are on the x- and y- axes, and a filled square represent an edge between the nodes. We can draw a graph's matrix form conveniently by using nxviz.MatrixPlot : import nxviz as nv from nxviz import annotate nv . matrix ( G , group_by = \"gender\" , node_color_by = \"gender\" ) annotate . matrix_group ( G , group_by = \"gender\" ) /home/runner/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.0 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.6.3, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( What can you tell from the graph visualization? A few things are immediately obvious: The diagonal is empty: no student voted for themselves as their favourite. The matrix is asymmetric about the diagonal: this is a directed graph! (An undirected graph would be symmetric about the diagonal.) You might go on to suggest that there is some clustering happening, but without applying a proper clustering algorithm on the adjacency matrix, we would be hard-pressed to know for sure. After all, we can simply re-order the node ordering along the axes to produce a seemingly-random matrix. Arc Plot The Arc Plot is another rational graph visualization. Here, we line up the nodes along a horizontal axis, and draw arcs between nodes if they are connected by an edge. We can also optionally group and colour them by some metadata. In the case of this student graph, we group and colour them by \"gender\". # a = ArcPlot(G, node_color='gender', node_grouping='gender') nv . arc ( G , node_color_by = \"gender\" , group_by = \"gender\" ) annotate . arc_group ( G , group_by = \"gender\" ) The Arc Plot forms the basis of the next visualization, the highly popular Circos plot. Circos Plot The Circos Plot was developed by Martin Krzywinski at the BC Cancer Research Center. The nxviz.CircosPlot takes inspiration from the original by joining the two ends of the Arc Plot into a circle. Likewise, we can colour and order nodes by node metadata: nv . circos ( G , group_by = \"gender\" , node_color_by = \"gender\" ) annotate . circos_group ( G , group_by = \"gender\" ) Generally speaking, you can think of a Circos Plot as being a more compact and aesthetically pleasing version of Arc Plots. Hive Plot The final plot we'll show is, Hive Plots. from nxviz import plots import matplotlib.pyplot as plt nv . hive ( G , group_by = \"gender\" , node_color_by = \"gender\" ) annotate . hive_group ( G , group_by = \"gender\" ) As you can see, with Hive Plots, we first group nodes along two or three radial axes. In this case, we have the boys along one radial axis and the girls along the other. We can also order the nodes along each axis if we so choose to. In this case, no particular ordering is chosen. Next, we draw edges. We start first with edges between groups. That is shown on the left side of the figure, joining nodes in the \"yellow\" and \"green\" (boys/girls) groups. We then proceed to edges within groups. This is done by cloning the node radial axis before drawing edges. Principles of Rational Graph Viz While I was implementing these visualizations in nxviz , I learned an important lesson in implementing graph visualizations in general: To be most informative and communicative, a graph visualization should first prioritize node placement in a fashion that makes sense. In some ways, this makes a ton of sense. The nodes are the \"entities\" in a graph, corresponding to people, proteins, and ports. For \"entities\", we have natural ways to group, order and summarize (reduce). (An example of a \"reduction\" is counting the number of things.) Prioritizing node placement allows us to appeal to our audience's natural sense of grouping, ordering and reduction. So the next time you see a hairball, I hope you're able to critique it for what it doesn't communicate, and possibly use the same principle to design a better visualization!","title":"Chapter 3: Graph Visualization"},{"location":"01-introduction/03-viz/#introduction","text":"from IPython.display import YouTubeVideo YouTubeVideo ( id = \"v9HrR_AF5Zc\" , width = \"100%\" ) In this chapter, We want to introduce you to the wonderful world of graph visualization. You probably have seen graphs that are visualized as hairballs. Apart from communicating how complex the graph is, hairballs don't really communicate much else. As such, my goal by the end of this chapter is to introduce you to what I call rational graph visualization . But before we can do that, let's first make sure we understand how to use NetworkX's drawing facilities to draw graphs to the screen. In a pinch, and for small graphs, it's very handy to have.","title":"Introduction"},{"location":"01-introduction/03-viz/#hairballs","text":"The node-link diagram is the canonical diagram we will see in publications. Nodes are commonly drawn as circles, while edges are drawn s lines. Node-link diagrams are common, and there's a good reason for this: it's convenient to draw! In NetworkX, we can draw node-link diagrams using: from nams import load_data as cf import networkx as nx import matplotlib.pyplot as plt G = cf . load_seventh_grader_network () nx . draw ( G ) Nodes more tightly connected with one another are clustered together. Initial node placement is done typically at random, so really it's tough to deterministically generate the same figure. If the network is small enough to visualize, and the node labels are small enough to fit in a circle, then you can use the with_labels=True argument to bring some degree of informativeness to the drawing: G . is_directed () True nx . draw ( G , with_labels = True ) The downside to drawing graphs this way is that large graphs end up looking like hairballs. Can you imagine a graph with more than the 28 nodes that we have? As you probably can imagine, the default nx.draw(G) is probably not suitable for generating visual insights.","title":"Hairballs"},{"location":"01-introduction/03-viz/#matrix-plot","text":"A different way that we can visualize a graph is by visualizing it in its matrix form. The nodes are on the x- and y- axes, and a filled square represent an edge between the nodes. We can draw a graph's matrix form conveniently by using nxviz.MatrixPlot : import nxviz as nv from nxviz import annotate nv . matrix ( G , group_by = \"gender\" , node_color_by = \"gender\" ) annotate . matrix_group ( G , group_by = \"gender\" ) /home/runner/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.0 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.6.3, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( What can you tell from the graph visualization? A few things are immediately obvious: The diagonal is empty: no student voted for themselves as their favourite. The matrix is asymmetric about the diagonal: this is a directed graph! (An undirected graph would be symmetric about the diagonal.) You might go on to suggest that there is some clustering happening, but without applying a proper clustering algorithm on the adjacency matrix, we would be hard-pressed to know for sure. After all, we can simply re-order the node ordering along the axes to produce a seemingly-random matrix.","title":"Matrix Plot"},{"location":"01-introduction/03-viz/#arc-plot","text":"The Arc Plot is another rational graph visualization. Here, we line up the nodes along a horizontal axis, and draw arcs between nodes if they are connected by an edge. We can also optionally group and colour them by some metadata. In the case of this student graph, we group and colour them by \"gender\". # a = ArcPlot(G, node_color='gender', node_grouping='gender') nv . arc ( G , node_color_by = \"gender\" , group_by = \"gender\" ) annotate . arc_group ( G , group_by = \"gender\" ) The Arc Plot forms the basis of the next visualization, the highly popular Circos plot.","title":"Arc Plot"},{"location":"01-introduction/03-viz/#circos-plot","text":"The Circos Plot was developed by Martin Krzywinski at the BC Cancer Research Center. The nxviz.CircosPlot takes inspiration from the original by joining the two ends of the Arc Plot into a circle. Likewise, we can colour and order nodes by node metadata: nv . circos ( G , group_by = \"gender\" , node_color_by = \"gender\" ) annotate . circos_group ( G , group_by = \"gender\" ) Generally speaking, you can think of a Circos Plot as being a more compact and aesthetically pleasing version of Arc Plots.","title":"Circos Plot"},{"location":"01-introduction/03-viz/#hive-plot","text":"The final plot we'll show is, Hive Plots. from nxviz import plots import matplotlib.pyplot as plt nv . hive ( G , group_by = \"gender\" , node_color_by = \"gender\" ) annotate . hive_group ( G , group_by = \"gender\" ) As you can see, with Hive Plots, we first group nodes along two or three radial axes. In this case, we have the boys along one radial axis and the girls along the other. We can also order the nodes along each axis if we so choose to. In this case, no particular ordering is chosen. Next, we draw edges. We start first with edges between groups. That is shown on the left side of the figure, joining nodes in the \"yellow\" and \"green\" (boys/girls) groups. We then proceed to edges within groups. This is done by cloning the node radial axis before drawing edges.","title":"Hive Plot"},{"location":"01-introduction/03-viz/#principles-of-rational-graph-viz","text":"While I was implementing these visualizations in nxviz , I learned an important lesson in implementing graph visualizations in general: To be most informative and communicative, a graph visualization should first prioritize node placement in a fashion that makes sense. In some ways, this makes a ton of sense. The nodes are the \"entities\" in a graph, corresponding to people, proteins, and ports. For \"entities\", we have natural ways to group, order and summarize (reduce). (An example of a \"reduction\" is counting the number of things.) Prioritizing node placement allows us to appeal to our audience's natural sense of grouping, ordering and reduction. So the next time you see a hairball, I hope you're able to critique it for what it doesn't communicate, and possibly use the same principle to design a better visualization!","title":"Principles of Rational Graph Viz"},{"location":"02-algorithms/01-hubs/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); % load_ext autoreload % autoreload 2 % matplotlib inline % config InlineBackend . figure_format = 'retina' Introduction from IPython.display import YouTubeVideo YouTubeVideo ( id = \"-oimHbVDdDA\" , width = 560 , height = 315 ) Because of the relational structure in a graph, we can begin to think about \"importance\" of a node that is induced because of its relationships to the rest of the nodes in the graph. Before we go on, let's think about a pertinent and contemporary example. An example: contact tracing At the time of writing (April 2020), finding important nodes in a graph has actually taken on a measure of importance that we might not have appreciated before. With the COVID-19 virus spreading, contact tracing has become quite important. In an infectious disease contact network, where individuals are nodes and contact between individuals of some kind are the edges, an \"important\" node in this contact network would be an individual who was infected who also was in contact with many people during the time that they were infected. Our dataset: \"Sociopatterns\" The dataset that we will use in this chapter is the \" sociopatterns network \" dataset. Incidentally, it's also about infectious diseases. Note to readers: We originally obtained the dataset in 2014 from the Konect website. It is unfortunately no longer available. The sociopatterns.org website hosts an edge list of a slightly different format, so it will look different from what we have here. From the original description on Konect, here is the description of the dataset: This network describes the face-to-face behavior of people during the exhibition INFECTIOUS: STAY AWAY in 2009 at the Science Gallery in Dublin. Nodes represent exhibition visitors; edges represent face-to-face contacts that were active for at least 20 seconds. Multiple edges between two nodes are possible and denote multiple contacts. The network contains the data from the day with the most interactions. To simplify the network, we have represented only the last contact between individuals. from nams import load_data as cf G = cf . load_sociopatterns_network () It is loaded as an undirected graph object: type ( G ) networkx.classes.graph.Graph As usual, before proceeding with any analysis, we should know basic graph statistics. len ( G . nodes ()), len ( G . edges ()) (410, 2765) A Measure of Importance: \"Number of Neighbors\" One measure of importance of a node is the number of neighbors that the node has. What is a neighbor ? We will work with the following definition: The neighbor of a node is connected to that node by an edge. Let's explore this concept, using the NetworkX API. Every NetworkX graph provides a G.neighbors(node) class method, which lets us query a graph for the number of neighbors of a given node: G . neighbors ( 7 ) <dict_keyiterator at 0x7fe0f3dc1b30> It returns a generator that doesn't immediately return the exact neighbors list. This means we cannot know its exact length, as it is a generator. If you tried to do: len ( G . neighbors ( 7 )) you would get the following error: --------------------------------------------------------------------------- TypeError Traceback ( most recent call last ) < ipython - input - 13 - 72 c56971d077 > in < module > ----> 1 len ( G . neighbors ( 7 )) TypeError : object of type 'dict_keyiterator' has no len () Hence, we will need to cast it as a list in order to know both its length and its members: list ( G . neighbors ( 7 )) [5, 6, 21, 22, 37, 48, 51] In the event that some nodes have an extensive list of neighbors, then using the dict_keyiterator is potentially a good memory-saving technique, as it lazily yields the neighbors. Exercise: Rank-ordering the number of neighbors a node has Since we know how to get the list of nodes that are neighbors of a given node, try this following exercise: Can you create a ranked list of the importance of each individual, based on the number of neighbors they have? Here are a few hints to help: You could consider using a pandas Series . This would be a modern and idiomatic way of approaching the problem. You could also consider using Python's sorted function. from nams.solutions.hubs import rank_ordered_neighbors #### REPLACE THE NEXT FEW LINES WITH YOUR ANSWER # answer = rank_ordered_neighbors(G) # answer /home/runner/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.0 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.6.3, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( The original implementation looked like the following from nams.solutions.hubs import rank_ordered_neighbors_original # rank_ordered_neighbors_original?? And another implementation that uses generators: from nams.solutions.hubs import rank_ordered_neighbors_generator # rank_ordered_neighbors_generator?? Generalizing \"neighbors\" to arbitrarily-sized graphs The concept of neighbors is simple and appealing, but it leaves us with a slight point of dissatisfaction: it is difficult to compare graphs of different sizes. Is a node more important solely because it has more neighbors? What if it were situated in an extremely large graph? Would we not expect it to have more neighbors? As such, we need a normalization factor. One reasonable one, in fact, is the number of nodes that a given node could possibly be connected to. By taking the ratio of the number of neighbors a node has to the number of neighbors it could possibly have, we get the degree centrality metric. Formally defined, the degree centrality of a node (let's call it d d ) is the number of neighbors that a node has (let's call it n n ) divided by the number of neighbors it could possibly have (let's call it N N ): d = \\frac{n}{N} d = \\frac{n}{N} NetworkX provides a function for us to calculate degree centrality conveniently: import networkx as nx import pandas as pd dcs = pd . Series ( nx . degree_centrality ( G )) dcs 100 0.070905 101 0.031785 102 0.039120 103 0.063570 104 0.041565 ... 89 0.009780 91 0.051345 96 0.036675 99 0.034230 98 0.002445 Length: 410, dtype: float64 nx.degree_centrality(G) returns to us a dictionary of key-value pairs, where the keys are node IDs and values are the degree centrality score. To save on output length, I took the liberty of casting it as a pandas Series to make it easier to display. Incidentally, we can also sort the series to find the nodes with the highest degree centralities: dcs . sort_values ( ascending = False ) 51 0.122249 272 0.114914 235 0.105134 195 0.105134 265 0.083130 ... 390 0.002445 135 0.002445 398 0.002445 186 0.002445 98 0.002445 Length: 410, dtype: float64 Does the list order look familiar? It should, since the numerator of the degree centrality metric is identical to the number of neighbors, and the denominator is a constant. Distribution of graph metrics One important concept that you should come to know is that the distribution of node-centric values can characterize classes of graphs. What do we mean by \"distribution of node-centric values\"? One would be the degree distribution, that is, the collection of node degree values in a graph. Generally, you might be familiar with plotting a histogram to visualize distributions of values, but in this book, we are going to avoid histograms like the plague. I detail a lot of reasons in a blog post I wrote in 2018, but the main points are that: It's easier to lie with histograms. You get informative statistical information (median, IQR, extremes/outliers) more easily. Exercise: Degree distribution In this next exercise, we are going to get practice visualizing these values using empirical cumulative distribution function plots. I have written for you an ECDF function that you can use already. Its API looks like the following: x , y = ecdf ( list_of_values ) giving you x and y values that you can directly plot. The exercise prompt is this: Plot the ECDF of the degree centrality and degree distributions. First do it for degree centrality : from nams.functions import ecdf from nams.solutions.hubs import ecdf_degree_centrality #### REPLACE THE FUNCTION CALL WITH YOUR ANSWER ecdf_degree_centrality ( G ) Now do it for degree : from nams.solutions.hubs import ecdf_degree #### REPLACE THE FUNCTION CALL WITH YOUR ANSWER ecdf_degree ( G ) The fact that they are identically-shaped should not surprise you! Exercise: What about that denominator? The denominator N N in the degree centrality definition is \"the number of nodes that a node could possibly be connected to\". Can you think of two ways N N be defined? from nams.solutions.hubs import num_possible_neighbors #### UNCOMMENT TO SEE MY ANSWER # print(num_possible_neighbors()) Exercise: Circos Plotting Let's get some practice with the nxviz API. Visualize the graph G , while ordering and colouring them by the 'order' node attribute. from nams.solutions.hubs import circos_plot #### REPLACE THE NEXT LINE WITH YOUR ANSWER circos_plot ( G ) And here's an alternative view using an arc plot. import nxviz as nv nv . arc ( G , sort_by = \"order\" , node_color_by = \"order\" ) <AxesSubplot:> Exercise: Visual insights Since we know that node colour and order are by the \"order\" in which the person entered into the exhibit, what does this visualization tell you? from nams.solutions.hubs import visual_insights #### UNCOMMENT THE NEXT LINE TO SEE MY ANSWER # print(visual_insights()) Exercise: Investigating degree centrality and node order One of the insights that we might have gleaned from visualizing the graph is that the nodes that have a high degree centrality might also be responsible for the edges that criss-cross the Circos plot. To test this, plot the following: x-axis: node degree centrality y-axis: maximum difference between the neighbors' order s (a node attribute) and the node's order . from nams.solutions.hubs import dc_node_order dc_node_order ( G ) The somewhat positive correlation between the degree centrality might tell us that this trend holds true. A further applied question would be to ask what behaviour of these nodes would give rise to this pattern. Are these nodes actually exhibit staff? Or is there some other reason why they are staying so long? This, of course, would require joining in further information that we would overlay on top of the graph (by adding them as node or edge attributes) before we might make further statements. Reflections In this chapter, we defined a metric of node importance: the degree centrality metric. In the example we looked at, it could help us identify potential infectious agent superspreaders in a disease contact network. In other settings, it might help us spot: message amplifiers/influencers in a social network, and potentially crowded airports that have lots of connections into and out of it (still relevant to infectious disease spread!) and many more! What other settings can you think of in which the number of neighbors that a node has can become a metric of importance for the node? Solutions Here are the solutions to the exercises above. from nams.solutions import hubs import inspect print ( inspect . getsource ( hubs )) \"\"\"Solutions to Hubs chapter.\"\"\" import matplotlib.pyplot as plt import networkx as nx import pandas as pd import nxviz as nv from nxviz import annotate from nams import ecdf def rank_ordered_neighbors(G): \"\"\" Uses a pandas Series to help with sorting. \"\"\" s = pd.Series({n: len(list(G.neighbors(n))) for n in G.nodes()}) return s.sort_values(ascending=False) def rank_ordered_neighbors_original(G): \"\"\"Original implementation of rank-ordered number of neighbors.\"\"\" return sorted(G.nodes(), key=lambda x: len(list(G.neighbors(x))), reverse=True) def rank_ordered_neighbors_generator(G): \"\"\" Rank-ordered generator of neighbors. Contributed by @dgerlanc. Ref: https://github.com/ericmjl/Network-Analysis-Made-Simple/issues/75 \"\"\" gen = ((len(list(G.neighbors(x))), x) for x in G.nodes()) return sorted(gen, reverse=True) def ecdf_degree_centrality(G): \"\"\"ECDF of degree centrality.\"\"\" x, y = ecdf(list(nx.degree_centrality(G).values())) plt.scatter(x, y) plt.xlabel(\"degree centrality\") plt.ylabel(\"cumulative fraction\") def ecdf_degree(G): \"\"\"ECDF of degree.\"\"\" num_neighbors = [len(list(G.neighbors(n))) for n in G.nodes()] x, y = ecdf(num_neighbors) plt.scatter(x, y) plt.xlabel(\"degree\") plt.ylabel(\"cumulative fraction\") def num_possible_neighbors(): \"\"\"Answer to the number of possible neighbors for a node.\"\"\" return r\"\"\" The number of possible neighbors can either be defined as: 1. All other nodes but myself 2. All other nodes and myself If $K$ is the number of nodes in the graph, then if defined as (1), $N$ (the denominator) is $K - 1$. If defined as (2), $N$ is equal to $K$. \"\"\" def circos_plot(G): \"\"\"Draw a Circos Plot of the graph.\"\"\" # c = CircosPlot(G, node_order=\"order\", node_color=\"order\") # c.draw() nv.circos(G, sort_by=\"order\", node_color_by=\"order\") annotate.node_colormapping(G, color_by=\"order\") def visual_insights(): \"\"\"Visual insights from the Circos Plot.\"\"\" return \"\"\" We see that most edges are \"local\" with nodes that are proximal in order. The nodes that are weird are the ones that have connections with individuals much later than itself, crossing larger jumps in order/time. Additionally, if you recall the ranked list of degree centralities, it appears that these nodes that have the highest degree centrality scores are also the ones that have edges that cross the circos plot. \"\"\" def dc_node_order(G): \"\"\"Comparison of degree centrality by maximum difference in node order.\"\"\" import matplotlib.pyplot as plt import pandas as pd import networkx as nx # Degree centralities dcs = pd.Series(nx.degree_centrality(G)) # Maximum node order difference maxdiffs = dict() for n, d in G.nodes(data=True): diffs = [] for nbr in G.neighbors(n): diffs.append(abs(G.nodes[nbr][\"order\"] - d[\"order\"])) maxdiffs[n] = max(diffs) maxdiffs = pd.Series(maxdiffs) ax = pd.DataFrame(dict(degree_centrality=dcs, max_diff=maxdiffs)).plot( x=\"degree_centrality\", y=\"max_diff\", kind=\"scatter\" )","title":"Chapter 4: Hubs"},{"location":"02-algorithms/01-hubs/#introduction","text":"from IPython.display import YouTubeVideo YouTubeVideo ( id = \"-oimHbVDdDA\" , width = 560 , height = 315 ) Because of the relational structure in a graph, we can begin to think about \"importance\" of a node that is induced because of its relationships to the rest of the nodes in the graph. Before we go on, let's think about a pertinent and contemporary example.","title":"Introduction"},{"location":"02-algorithms/01-hubs/#an-example-contact-tracing","text":"At the time of writing (April 2020), finding important nodes in a graph has actually taken on a measure of importance that we might not have appreciated before. With the COVID-19 virus spreading, contact tracing has become quite important. In an infectious disease contact network, where individuals are nodes and contact between individuals of some kind are the edges, an \"important\" node in this contact network would be an individual who was infected who also was in contact with many people during the time that they were infected.","title":"An example: contact tracing"},{"location":"02-algorithms/01-hubs/#our-dataset-sociopatterns","text":"The dataset that we will use in this chapter is the \" sociopatterns network \" dataset. Incidentally, it's also about infectious diseases. Note to readers: We originally obtained the dataset in 2014 from the Konect website. It is unfortunately no longer available. The sociopatterns.org website hosts an edge list of a slightly different format, so it will look different from what we have here. From the original description on Konect, here is the description of the dataset: This network describes the face-to-face behavior of people during the exhibition INFECTIOUS: STAY AWAY in 2009 at the Science Gallery in Dublin. Nodes represent exhibition visitors; edges represent face-to-face contacts that were active for at least 20 seconds. Multiple edges between two nodes are possible and denote multiple contacts. The network contains the data from the day with the most interactions. To simplify the network, we have represented only the last contact between individuals. from nams import load_data as cf G = cf . load_sociopatterns_network () It is loaded as an undirected graph object: type ( G ) networkx.classes.graph.Graph As usual, before proceeding with any analysis, we should know basic graph statistics. len ( G . nodes ()), len ( G . edges ()) (410, 2765)","title":"Our dataset: \"Sociopatterns\""},{"location":"02-algorithms/01-hubs/#a-measure-of-importance-number-of-neighbors","text":"One measure of importance of a node is the number of neighbors that the node has. What is a neighbor ? We will work with the following definition: The neighbor of a node is connected to that node by an edge. Let's explore this concept, using the NetworkX API. Every NetworkX graph provides a G.neighbors(node) class method, which lets us query a graph for the number of neighbors of a given node: G . neighbors ( 7 ) <dict_keyiterator at 0x7fe0f3dc1b30> It returns a generator that doesn't immediately return the exact neighbors list. This means we cannot know its exact length, as it is a generator. If you tried to do: len ( G . neighbors ( 7 )) you would get the following error: --------------------------------------------------------------------------- TypeError Traceback ( most recent call last ) < ipython - input - 13 - 72 c56971d077 > in < module > ----> 1 len ( G . neighbors ( 7 )) TypeError : object of type 'dict_keyiterator' has no len () Hence, we will need to cast it as a list in order to know both its length and its members: list ( G . neighbors ( 7 )) [5, 6, 21, 22, 37, 48, 51] In the event that some nodes have an extensive list of neighbors, then using the dict_keyiterator is potentially a good memory-saving technique, as it lazily yields the neighbors.","title":"A Measure of Importance: \"Number of Neighbors\""},{"location":"02-algorithms/01-hubs/#exercise-rank-ordering-the-number-of-neighbors-a-node-has","text":"Since we know how to get the list of nodes that are neighbors of a given node, try this following exercise: Can you create a ranked list of the importance of each individual, based on the number of neighbors they have? Here are a few hints to help: You could consider using a pandas Series . This would be a modern and idiomatic way of approaching the problem. You could also consider using Python's sorted function. from nams.solutions.hubs import rank_ordered_neighbors #### REPLACE THE NEXT FEW LINES WITH YOUR ANSWER # answer = rank_ordered_neighbors(G) # answer /home/runner/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.0 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.6.3, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( The original implementation looked like the following from nams.solutions.hubs import rank_ordered_neighbors_original # rank_ordered_neighbors_original?? And another implementation that uses generators: from nams.solutions.hubs import rank_ordered_neighbors_generator # rank_ordered_neighbors_generator??","title":"Exercise: Rank-ordering the number of neighbors a node has"},{"location":"02-algorithms/01-hubs/#generalizing-neighbors-to-arbitrarily-sized-graphs","text":"The concept of neighbors is simple and appealing, but it leaves us with a slight point of dissatisfaction: it is difficult to compare graphs of different sizes. Is a node more important solely because it has more neighbors? What if it were situated in an extremely large graph? Would we not expect it to have more neighbors? As such, we need a normalization factor. One reasonable one, in fact, is the number of nodes that a given node could possibly be connected to. By taking the ratio of the number of neighbors a node has to the number of neighbors it could possibly have, we get the degree centrality metric. Formally defined, the degree centrality of a node (let's call it d d ) is the number of neighbors that a node has (let's call it n n ) divided by the number of neighbors it could possibly have (let's call it N N ): d = \\frac{n}{N} d = \\frac{n}{N} NetworkX provides a function for us to calculate degree centrality conveniently: import networkx as nx import pandas as pd dcs = pd . Series ( nx . degree_centrality ( G )) dcs 100 0.070905 101 0.031785 102 0.039120 103 0.063570 104 0.041565 ... 89 0.009780 91 0.051345 96 0.036675 99 0.034230 98 0.002445 Length: 410, dtype: float64 nx.degree_centrality(G) returns to us a dictionary of key-value pairs, where the keys are node IDs and values are the degree centrality score. To save on output length, I took the liberty of casting it as a pandas Series to make it easier to display. Incidentally, we can also sort the series to find the nodes with the highest degree centralities: dcs . sort_values ( ascending = False ) 51 0.122249 272 0.114914 235 0.105134 195 0.105134 265 0.083130 ... 390 0.002445 135 0.002445 398 0.002445 186 0.002445 98 0.002445 Length: 410, dtype: float64 Does the list order look familiar? It should, since the numerator of the degree centrality metric is identical to the number of neighbors, and the denominator is a constant.","title":"Generalizing \"neighbors\" to arbitrarily-sized graphs"},{"location":"02-algorithms/01-hubs/#distribution-of-graph-metrics","text":"One important concept that you should come to know is that the distribution of node-centric values can characterize classes of graphs. What do we mean by \"distribution of node-centric values\"? One would be the degree distribution, that is, the collection of node degree values in a graph. Generally, you might be familiar with plotting a histogram to visualize distributions of values, but in this book, we are going to avoid histograms like the plague. I detail a lot of reasons in a blog post I wrote in 2018, but the main points are that: It's easier to lie with histograms. You get informative statistical information (median, IQR, extremes/outliers) more easily.","title":"Distribution of graph metrics"},{"location":"02-algorithms/01-hubs/#exercise-degree-distribution","text":"In this next exercise, we are going to get practice visualizing these values using empirical cumulative distribution function plots. I have written for you an ECDF function that you can use already. Its API looks like the following: x , y = ecdf ( list_of_values ) giving you x and y values that you can directly plot. The exercise prompt is this: Plot the ECDF of the degree centrality and degree distributions. First do it for degree centrality : from nams.functions import ecdf from nams.solutions.hubs import ecdf_degree_centrality #### REPLACE THE FUNCTION CALL WITH YOUR ANSWER ecdf_degree_centrality ( G ) Now do it for degree : from nams.solutions.hubs import ecdf_degree #### REPLACE THE FUNCTION CALL WITH YOUR ANSWER ecdf_degree ( G ) The fact that they are identically-shaped should not surprise you!","title":"Exercise: Degree distribution"},{"location":"02-algorithms/01-hubs/#exercise-what-about-that-denominator","text":"The denominator N N in the degree centrality definition is \"the number of nodes that a node could possibly be connected to\". Can you think of two ways N N be defined? from nams.solutions.hubs import num_possible_neighbors #### UNCOMMENT TO SEE MY ANSWER # print(num_possible_neighbors())","title":"Exercise: What about that denominator?"},{"location":"02-algorithms/01-hubs/#exercise-circos-plotting","text":"Let's get some practice with the nxviz API. Visualize the graph G , while ordering and colouring them by the 'order' node attribute. from nams.solutions.hubs import circos_plot #### REPLACE THE NEXT LINE WITH YOUR ANSWER circos_plot ( G ) And here's an alternative view using an arc plot. import nxviz as nv nv . arc ( G , sort_by = \"order\" , node_color_by = \"order\" ) <AxesSubplot:>","title":"Exercise: Circos Plotting"},{"location":"02-algorithms/01-hubs/#exercise-visual-insights","text":"Since we know that node colour and order are by the \"order\" in which the person entered into the exhibit, what does this visualization tell you? from nams.solutions.hubs import visual_insights #### UNCOMMENT THE NEXT LINE TO SEE MY ANSWER # print(visual_insights())","title":"Exercise: Visual insights"},{"location":"02-algorithms/01-hubs/#exercise-investigating-degree-centrality-and-node-order","text":"One of the insights that we might have gleaned from visualizing the graph is that the nodes that have a high degree centrality might also be responsible for the edges that criss-cross the Circos plot. To test this, plot the following: x-axis: node degree centrality y-axis: maximum difference between the neighbors' order s (a node attribute) and the node's order . from nams.solutions.hubs import dc_node_order dc_node_order ( G ) The somewhat positive correlation between the degree centrality might tell us that this trend holds true. A further applied question would be to ask what behaviour of these nodes would give rise to this pattern. Are these nodes actually exhibit staff? Or is there some other reason why they are staying so long? This, of course, would require joining in further information that we would overlay on top of the graph (by adding them as node or edge attributes) before we might make further statements.","title":"Exercise: Investigating degree centrality and node order"},{"location":"02-algorithms/01-hubs/#reflections","text":"In this chapter, we defined a metric of node importance: the degree centrality metric. In the example we looked at, it could help us identify potential infectious agent superspreaders in a disease contact network. In other settings, it might help us spot: message amplifiers/influencers in a social network, and potentially crowded airports that have lots of connections into and out of it (still relevant to infectious disease spread!) and many more! What other settings can you think of in which the number of neighbors that a node has can become a metric of importance for the node?","title":"Reflections"},{"location":"02-algorithms/01-hubs/#solutions","text":"Here are the solutions to the exercises above. from nams.solutions import hubs import inspect print ( inspect . getsource ( hubs )) \"\"\"Solutions to Hubs chapter.\"\"\" import matplotlib.pyplot as plt import networkx as nx import pandas as pd import nxviz as nv from nxviz import annotate from nams import ecdf def rank_ordered_neighbors(G): \"\"\" Uses a pandas Series to help with sorting. \"\"\" s = pd.Series({n: len(list(G.neighbors(n))) for n in G.nodes()}) return s.sort_values(ascending=False) def rank_ordered_neighbors_original(G): \"\"\"Original implementation of rank-ordered number of neighbors.\"\"\" return sorted(G.nodes(), key=lambda x: len(list(G.neighbors(x))), reverse=True) def rank_ordered_neighbors_generator(G): \"\"\" Rank-ordered generator of neighbors. Contributed by @dgerlanc. Ref: https://github.com/ericmjl/Network-Analysis-Made-Simple/issues/75 \"\"\" gen = ((len(list(G.neighbors(x))), x) for x in G.nodes()) return sorted(gen, reverse=True) def ecdf_degree_centrality(G): \"\"\"ECDF of degree centrality.\"\"\" x, y = ecdf(list(nx.degree_centrality(G).values())) plt.scatter(x, y) plt.xlabel(\"degree centrality\") plt.ylabel(\"cumulative fraction\") def ecdf_degree(G): \"\"\"ECDF of degree.\"\"\" num_neighbors = [len(list(G.neighbors(n))) for n in G.nodes()] x, y = ecdf(num_neighbors) plt.scatter(x, y) plt.xlabel(\"degree\") plt.ylabel(\"cumulative fraction\") def num_possible_neighbors(): \"\"\"Answer to the number of possible neighbors for a node.\"\"\" return r\"\"\" The number of possible neighbors can either be defined as: 1. All other nodes but myself 2. All other nodes and myself If $K$ is the number of nodes in the graph, then if defined as (1), $N$ (the denominator) is $K - 1$. If defined as (2), $N$ is equal to $K$. \"\"\" def circos_plot(G): \"\"\"Draw a Circos Plot of the graph.\"\"\" # c = CircosPlot(G, node_order=\"order\", node_color=\"order\") # c.draw() nv.circos(G, sort_by=\"order\", node_color_by=\"order\") annotate.node_colormapping(G, color_by=\"order\") def visual_insights(): \"\"\"Visual insights from the Circos Plot.\"\"\" return \"\"\" We see that most edges are \"local\" with nodes that are proximal in order. The nodes that are weird are the ones that have connections with individuals much later than itself, crossing larger jumps in order/time. Additionally, if you recall the ranked list of degree centralities, it appears that these nodes that have the highest degree centrality scores are also the ones that have edges that cross the circos plot. \"\"\" def dc_node_order(G): \"\"\"Comparison of degree centrality by maximum difference in node order.\"\"\" import matplotlib.pyplot as plt import pandas as pd import networkx as nx # Degree centralities dcs = pd.Series(nx.degree_centrality(G)) # Maximum node order difference maxdiffs = dict() for n, d in G.nodes(data=True): diffs = [] for nbr in G.neighbors(n): diffs.append(abs(G.nodes[nbr][\"order\"] - d[\"order\"])) maxdiffs[n] = max(diffs) maxdiffs = pd.Series(maxdiffs) ax = pd.DataFrame(dict(degree_centrality=dcs, max_diff=maxdiffs)).plot( x=\"degree_centrality\", y=\"max_diff\", kind=\"scatter\" )","title":"Solutions"},{"location":"02-algorithms/02-paths/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); % load_ext autoreload % autoreload 2 % matplotlib inline % config InlineBackend . figure_format = 'retina' Introduction from IPython.display import YouTubeVideo YouTubeVideo ( id = \"JjpbztqP9_0\" , width = \"100%\" ) Graph traversal is akin to walking along the graph, node by node, constrained by the edges that connect the nodes. Graph traversal is particularly useful for understanding the local structure of certain portions of the graph and for finding paths that connect two nodes in the network. In this chapter, we are going to learn how to perform pathfinding in a graph, specifically by looking for shortest paths via the breadth-first search algorithm. Breadth-First Search The BFS algorithm is a staple of computer science curricula, and for good reason: it teaches learners how to \"think on\" a graph, putting one in the position of \"the dumb computer\" that can't use a visual cortex to \" just know \" how to trace a path from one node to another. As a topic, learning how to do BFS additionally imparts algorithmic thinking to the learner. Exercise: Design the algorithm Try out this exercise to get some practice with algorithmic thinking. On a piece of paper, conjure up a graph that has 15-20 nodes. Connect them any way you like. Pick two nodes. Pretend that you're standing on one of the nodes, but you can't see any further beyond one neighbor away. Work out how you can find a path from the node you're standing on to the other node, given that you can only see nodes that are one neighbor away but have an infinitely good memory. If you are successful at designing the algorithm, you should get the answer below. from nams import load_data as cf G = cf . load_sociopatterns_network () from nams.solutions.paths import bfs_algorithm # UNCOMMENT NEXT LINE TO GET THE ANSWER. # bfs_algorithm() /home/runner/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.0 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.6.3, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( Exercise: Implement the algorithm Now that you've seen how the algorithm works, try implementing it! # FILL IN THE BLANKS BELOW def path_exists ( node1 , node2 , G ): \"\"\" This function checks whether a path exists between two nodes (node1, node2) in graph G. \"\"\" visited_nodes = _____ queue = [ _____ ] while len ( queue ) > 0 : node = ___________ neighbors = list ( _________________ ) if _____ in _________ : # print('Path exists between nodes {0} and {1}'.format(node1, node2)) return True else : visited_nodes . ___ ( ____ ) nbrs = [ _ for _ in _________ if _ not in _____________ ] queue = ____ + _____ # print('Path does not exist between nodes {0} and {1}'.format(node1, node2)) return False # UNCOMMENT THE FOLLOWING TWO LINES TO SEE THE ANSWER from nams.solutions.paths import path_exists # path_exists?? # CHECK YOUR ANSWER AGAINST THE TEST FUNCTION BELOW from random import sample import networkx as nx def test_path_exists ( N ): \"\"\" N: The number of times to spot-check. \"\"\" for i in range ( N ): n1 , n2 = sample ( G . nodes (), 2 ) assert path_exists ( n1 , n2 , G ) == bool ( nx . shortest_path ( G , n1 , n2 )) return True assert test_path_exists ( 10 ) Visualizing Paths One of the objectives of that exercise before was to help you \"think on graphs\". Now that you've learned how to do so, you might be wondering, \"How do I visualize that path through the graph?\" Well first off, if you inspect the test_path_exists function above, you'll notice that NetworkX provides a shortest_path() function that you can use. Here's what using nx.shortest_path() looks like. path = nx . shortest_path ( G , 7 , 400 ) path [7, 51, 188, 230, 335, 400] As you can see, it returns the nodes along the shortest path, incidentally in the exact order that you would traverse. One thing to note, though! If there are multiple shortest paths from one node to another, NetworkX will only return one of them. So how do you draw those nodes only ? You can use the G.subgraph(nodes) to return a new graph that only has nodes in nodes and only the edges that exist between them. After that, you can use any plotting library you like. We will show an example here that uses nxviz's matrix plot. Let's see it in action: import nxviz as nv g = G . subgraph ( path ) nv . matrix ( g , sort_by = \"order\" ) <AxesSubplot:> Voila! Now we have the subgraph (1) extracted and (2) drawn to screen! In this case, the matrix plot is a suitable visualization for its compactness. The off-diagonals also show that each node is a neighbor to the next one. You'll also notice that if you try to modify the graph g , say by adding a node: g . add_node ( 2048 ) you will get an error: --------------------------------------------------------------------------- NetworkXError Traceback ( most recent call last ) < ipython - input - 10 - ca6aa4c26819 > in < module > ----> 1 g . add_node ( 2048 ) ~/ anaconda / envs / nams / lib / python3 . 7 / site - packages / networkx / classes / function . py in frozen ( * args , ** kwargs ) 156 def frozen ( * args , ** kwargs ): 157 \"\"\"Dummy method for raising errors when trying to modify frozen graphs\"\"\" --> 158 raise nx . NetworkXError ( \"Frozen graph can't be modified\" ) 159 160 NetworkXError : Frozen graph can 't be modified From the perspective of semantics, this makes a ton of sense: the subgraph g is a perfect subset of the larger graph G , and should not be allowed to be modified unless the larger container graph is modified. Exercise: Draw path with neighbors one degree out Try out this next exercise: Extend graph drawing with the neighbors of each of those nodes. Use any of the nxviz plots ( nv.matrix , nv.arc , nv.circos ); try to see which one helps you tell the best story. from nams.solutions.paths import plot_path_with_neighbors ### YOUR SOLUTION BELOW plot_path_with_neighbors ( G , 7 , 400 ) In this case, we opted for an Arc plot because we only have one grouping of nodes but have a logical way to order them. Because the path follows the order, the edges being highlighted automatically look like hops through the graph. Bottleneck nodes We're now going to revisit the concept of an \"important node\", this time now leveraging what we know about paths. In the \"hubs\" chapter, we saw how a node that is \"important\" could be so because it is connected to many other nodes. Paths give us an alternative definition. If we imagine that we have to pass a message on a graph from one node to another, then there may be \"bottleneck\" nodes for which if they are removed, then messages have a harder time flowing through the graph. One metric that measures this form of importance is the \"betweenness centrality\" metric. On a graph through which a generic \"message\" is flowing, a node with a high betweenness centrality is one that has a high proportion of shortest paths flowing through it. In other words, it behaves like a bottleneck . Betweenness centrality in NetworkX NetworkX provides a \"betweenness centrality\" function that behaves consistently with the \"degree centrality\" function, in that it returns a mapping from node to metric: import pandas as pd pd . Series ( nx . betweenness_centrality ( G )) 100 0.014809 101 0.001398 102 0.000748 103 0.006735 104 0.001198 ... 89 0.000004 91 0.006415 96 0.000323 99 0.000322 98 0.000000 Length: 410, dtype: float64 Exercise: compare degree and betweenness centrality Make a scatterplot of degree centrality on the x-axis and betweenness centrality on the y-axis. Do they correlate with one another? import matplotlib.pyplot as plt import seaborn as sns # YOUR ANSWER HERE: from nams.solutions.paths import plot_degree_betweenness plot_degree_betweenness ( G ) Think about it... ...does it make sense that degree centrality and betweenness centrality are not well-correlated? Can you think of a scenario where a node has a \"high\" betweenness centrality but a \"low\" degree centrality? Before peeking at the graph below, think about your answer for a moment. nx . draw ( nx . barbell_graph ( 5 , 1 )) Recap In this chapter, you learned the following things: You figured out how to implement the breadth-first-search algorithm to find shortest paths. You learned how to extract subgraphs from a larger graph. You implemented visualizations of subgraphs, which should help you as you communicate with colleagues. You calculated betweenness centrality metrics for a graph, and visualized how they correlated with degree centrality. Solutions Here are the solutions to the exercises above. from nams.solutions import paths import inspect print ( inspect . getsource ( paths )) \"\"\"Solutions to Paths chapter.\"\"\" import matplotlib.pyplot as plt import networkx as nx import pandas as pd import seaborn as sns from nams.functions import render_html def bfs_algorithm(): \"\"\" How to design a BFS algorithm. \"\"\" ans = \"\"\" How does the breadth-first search work? It essentially is as follows: 1. Begin with a queue that has only one element in it: the starting node. 2. Add the neighbors of that node to the queue. 1. If destination node is present in the queue, end. 2. If destination node is not present, proceed. 3. For each node in the queue: 1. Remove node from the queue. 2. Add neighbors of the node to the queue. Check if destination node is present or not. 3. If destination node is present, end. <!--Credit: @cavaunpeu for finding bug in pseudocode.--> 4. If destination node is not present, continue. \"\"\" return render_html(ans) def path_exists(node1, node2, G): \"\"\" This function checks whether a path exists between two nodes (node1, node2) in graph G. \"\"\" visited_nodes = set() queue = [node1] while len(queue) > 0: node = queue.pop() neighbors = list(G.neighbors(node)) if node2 in neighbors: return True else: visited_nodes.add(node) nbrs = [n for n in neighbors if n not in visited_nodes] queue = nbrs + queue return False def path_exists_for_loop(node1, node2, G): \"\"\" This function checks whether a path exists between two nodes (node1, node2) in graph G. Special thanks to @ghirlekar for suggesting that we keep track of the \"visited nodes\" to prevent infinite loops from happening. This also removes the need to remove nodes from queue. Reference: https://github.com/ericmjl/Network-Analysis-Made-Simple/issues/3 With thanks to @joshporter1 for the second bug fix. Originally there was an extraneous \"if\" statement that guaranteed that the \"False\" case would never be returned - because queue never changes in shape. Discovered at PyCon 2017. With thanks to @chendaniely for pointing out the extraneous \"break\". If you would like to see @dgerlanc's implementation, see https://github.com/ericmjl/Network-Analysis-Made-Simple/issues/76 \"\"\" visited_nodes = set() queue = [node1] for node in queue: neighbors = list(G.neighbors(node)) if node2 in neighbors: return True else: visited_nodes.add(node) queue.extend([n for n in neighbors if n not in visited_nodes]) return False def path_exists_deque(node1, node2, G): \"\"\"An alternative implementation.\"\"\" from collections import deque visited_nodes = set() queue = deque([node1]) while len(queue) > 0: node = queue.popleft() neighbors = list(G.neighbors(node)) if node2 in neighbors: return True else: visited_nodes.add(node) queue.extend([n for n in neighbors if n not in visited_nodes]) return False import nxviz as nv from nxviz import annotate, highlights def plot_path_with_neighbors(G, n1, n2): \"\"\"Plot a path with the heighbors of of the nodes along that path.\"\"\" path = nx.shortest_path(G, n1, n2) nodes = [*path] for node in path: nodes.extend(list(G.neighbors(node))) nodes = list(set(nodes)) g = G.subgraph(nodes) nv.arc( g, sort_by=\"order\", node_color_by=\"order\", edge_aes_kwargs={\"alpha_scale\": 0.5} ) for n in path: highlights.arc_node(g, n, sort_by=\"order\") for n1, n2 in zip(path[:-1], path[1:]): highlights.arc_edge(g, n1, n2, sort_by=\"order\") def plot_degree_betweenness(G): \"\"\"Plot scatterplot between degree and betweenness centrality.\"\"\" bc = pd.Series(nx.betweenness_centrality(G)) dc = pd.Series(nx.degree_centrality(G)) df = pd.DataFrame(dict(bc=bc, dc=dc)) ax = df.plot(x=\"dc\", y=\"bc\", kind=\"scatter\") ax.set_ylabel(\"Betweenness\\nCentrality\") ax.set_xlabel(\"Degree Centrality\") sns.despine()","title":"Chapter 5: Paths"},{"location":"02-algorithms/02-paths/#introduction","text":"from IPython.display import YouTubeVideo YouTubeVideo ( id = \"JjpbztqP9_0\" , width = \"100%\" ) Graph traversal is akin to walking along the graph, node by node, constrained by the edges that connect the nodes. Graph traversal is particularly useful for understanding the local structure of certain portions of the graph and for finding paths that connect two nodes in the network. In this chapter, we are going to learn how to perform pathfinding in a graph, specifically by looking for shortest paths via the breadth-first search algorithm.","title":"Introduction"},{"location":"02-algorithms/02-paths/#breadth-first-search","text":"The BFS algorithm is a staple of computer science curricula, and for good reason: it teaches learners how to \"think on\" a graph, putting one in the position of \"the dumb computer\" that can't use a visual cortex to \" just know \" how to trace a path from one node to another. As a topic, learning how to do BFS additionally imparts algorithmic thinking to the learner.","title":"Breadth-First Search"},{"location":"02-algorithms/02-paths/#exercise-design-the-algorithm","text":"Try out this exercise to get some practice with algorithmic thinking. On a piece of paper, conjure up a graph that has 15-20 nodes. Connect them any way you like. Pick two nodes. Pretend that you're standing on one of the nodes, but you can't see any further beyond one neighbor away. Work out how you can find a path from the node you're standing on to the other node, given that you can only see nodes that are one neighbor away but have an infinitely good memory. If you are successful at designing the algorithm, you should get the answer below. from nams import load_data as cf G = cf . load_sociopatterns_network () from nams.solutions.paths import bfs_algorithm # UNCOMMENT NEXT LINE TO GET THE ANSWER. # bfs_algorithm() /home/runner/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.0 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.6.3, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn(","title":"Exercise: Design the algorithm"},{"location":"02-algorithms/02-paths/#exercise-implement-the-algorithm","text":"Now that you've seen how the algorithm works, try implementing it! # FILL IN THE BLANKS BELOW def path_exists ( node1 , node2 , G ): \"\"\" This function checks whether a path exists between two nodes (node1, node2) in graph G. \"\"\" visited_nodes = _____ queue = [ _____ ] while len ( queue ) > 0 : node = ___________ neighbors = list ( _________________ ) if _____ in _________ : # print('Path exists between nodes {0} and {1}'.format(node1, node2)) return True else : visited_nodes . ___ ( ____ ) nbrs = [ _ for _ in _________ if _ not in _____________ ] queue = ____ + _____ # print('Path does not exist between nodes {0} and {1}'.format(node1, node2)) return False # UNCOMMENT THE FOLLOWING TWO LINES TO SEE THE ANSWER from nams.solutions.paths import path_exists # path_exists?? # CHECK YOUR ANSWER AGAINST THE TEST FUNCTION BELOW from random import sample import networkx as nx def test_path_exists ( N ): \"\"\" N: The number of times to spot-check. \"\"\" for i in range ( N ): n1 , n2 = sample ( G . nodes (), 2 ) assert path_exists ( n1 , n2 , G ) == bool ( nx . shortest_path ( G , n1 , n2 )) return True assert test_path_exists ( 10 )","title":"Exercise: Implement the algorithm"},{"location":"02-algorithms/02-paths/#visualizing-paths","text":"One of the objectives of that exercise before was to help you \"think on graphs\". Now that you've learned how to do so, you might be wondering, \"How do I visualize that path through the graph?\" Well first off, if you inspect the test_path_exists function above, you'll notice that NetworkX provides a shortest_path() function that you can use. Here's what using nx.shortest_path() looks like. path = nx . shortest_path ( G , 7 , 400 ) path [7, 51, 188, 230, 335, 400] As you can see, it returns the nodes along the shortest path, incidentally in the exact order that you would traverse. One thing to note, though! If there are multiple shortest paths from one node to another, NetworkX will only return one of them. So how do you draw those nodes only ? You can use the G.subgraph(nodes) to return a new graph that only has nodes in nodes and only the edges that exist between them. After that, you can use any plotting library you like. We will show an example here that uses nxviz's matrix plot. Let's see it in action: import nxviz as nv g = G . subgraph ( path ) nv . matrix ( g , sort_by = \"order\" ) <AxesSubplot:> Voila! Now we have the subgraph (1) extracted and (2) drawn to screen! In this case, the matrix plot is a suitable visualization for its compactness. The off-diagonals also show that each node is a neighbor to the next one. You'll also notice that if you try to modify the graph g , say by adding a node: g . add_node ( 2048 ) you will get an error: --------------------------------------------------------------------------- NetworkXError Traceback ( most recent call last ) < ipython - input - 10 - ca6aa4c26819 > in < module > ----> 1 g . add_node ( 2048 ) ~/ anaconda / envs / nams / lib / python3 . 7 / site - packages / networkx / classes / function . py in frozen ( * args , ** kwargs ) 156 def frozen ( * args , ** kwargs ): 157 \"\"\"Dummy method for raising errors when trying to modify frozen graphs\"\"\" --> 158 raise nx . NetworkXError ( \"Frozen graph can't be modified\" ) 159 160 NetworkXError : Frozen graph can 't be modified From the perspective of semantics, this makes a ton of sense: the subgraph g is a perfect subset of the larger graph G , and should not be allowed to be modified unless the larger container graph is modified.","title":"Visualizing Paths"},{"location":"02-algorithms/02-paths/#exercise-draw-path-with-neighbors-one-degree-out","text":"Try out this next exercise: Extend graph drawing with the neighbors of each of those nodes. Use any of the nxviz plots ( nv.matrix , nv.arc , nv.circos ); try to see which one helps you tell the best story. from nams.solutions.paths import plot_path_with_neighbors ### YOUR SOLUTION BELOW plot_path_with_neighbors ( G , 7 , 400 ) In this case, we opted for an Arc plot because we only have one grouping of nodes but have a logical way to order them. Because the path follows the order, the edges being highlighted automatically look like hops through the graph.","title":"Exercise: Draw path with neighbors one degree out"},{"location":"02-algorithms/02-paths/#bottleneck-nodes","text":"We're now going to revisit the concept of an \"important node\", this time now leveraging what we know about paths. In the \"hubs\" chapter, we saw how a node that is \"important\" could be so because it is connected to many other nodes. Paths give us an alternative definition. If we imagine that we have to pass a message on a graph from one node to another, then there may be \"bottleneck\" nodes for which if they are removed, then messages have a harder time flowing through the graph. One metric that measures this form of importance is the \"betweenness centrality\" metric. On a graph through which a generic \"message\" is flowing, a node with a high betweenness centrality is one that has a high proportion of shortest paths flowing through it. In other words, it behaves like a bottleneck .","title":"Bottleneck nodes"},{"location":"02-algorithms/02-paths/#betweenness-centrality-in-networkx","text":"NetworkX provides a \"betweenness centrality\" function that behaves consistently with the \"degree centrality\" function, in that it returns a mapping from node to metric: import pandas as pd pd . Series ( nx . betweenness_centrality ( G )) 100 0.014809 101 0.001398 102 0.000748 103 0.006735 104 0.001198 ... 89 0.000004 91 0.006415 96 0.000323 99 0.000322 98 0.000000 Length: 410, dtype: float64","title":"Betweenness centrality in NetworkX"},{"location":"02-algorithms/02-paths/#exercise-compare-degree-and-betweenness-centrality","text":"Make a scatterplot of degree centrality on the x-axis and betweenness centrality on the y-axis. Do they correlate with one another? import matplotlib.pyplot as plt import seaborn as sns # YOUR ANSWER HERE: from nams.solutions.paths import plot_degree_betweenness plot_degree_betweenness ( G )","title":"Exercise: compare degree and betweenness centrality"},{"location":"02-algorithms/02-paths/#think-about-it","text":"...does it make sense that degree centrality and betweenness centrality are not well-correlated? Can you think of a scenario where a node has a \"high\" betweenness centrality but a \"low\" degree centrality? Before peeking at the graph below, think about your answer for a moment. nx . draw ( nx . barbell_graph ( 5 , 1 ))","title":"Think about it..."},{"location":"02-algorithms/02-paths/#recap","text":"In this chapter, you learned the following things: You figured out how to implement the breadth-first-search algorithm to find shortest paths. You learned how to extract subgraphs from a larger graph. You implemented visualizations of subgraphs, which should help you as you communicate with colleagues. You calculated betweenness centrality metrics for a graph, and visualized how they correlated with degree centrality.","title":"Recap"},{"location":"02-algorithms/02-paths/#solutions","text":"Here are the solutions to the exercises above. from nams.solutions import paths import inspect print ( inspect . getsource ( paths )) \"\"\"Solutions to Paths chapter.\"\"\" import matplotlib.pyplot as plt import networkx as nx import pandas as pd import seaborn as sns from nams.functions import render_html def bfs_algorithm(): \"\"\" How to design a BFS algorithm. \"\"\" ans = \"\"\" How does the breadth-first search work? It essentially is as follows: 1. Begin with a queue that has only one element in it: the starting node. 2. Add the neighbors of that node to the queue. 1. If destination node is present in the queue, end. 2. If destination node is not present, proceed. 3. For each node in the queue: 1. Remove node from the queue. 2. Add neighbors of the node to the queue. Check if destination node is present or not. 3. If destination node is present, end. <!--Credit: @cavaunpeu for finding bug in pseudocode.--> 4. If destination node is not present, continue. \"\"\" return render_html(ans) def path_exists(node1, node2, G): \"\"\" This function checks whether a path exists between two nodes (node1, node2) in graph G. \"\"\" visited_nodes = set() queue = [node1] while len(queue) > 0: node = queue.pop() neighbors = list(G.neighbors(node)) if node2 in neighbors: return True else: visited_nodes.add(node) nbrs = [n for n in neighbors if n not in visited_nodes] queue = nbrs + queue return False def path_exists_for_loop(node1, node2, G): \"\"\" This function checks whether a path exists between two nodes (node1, node2) in graph G. Special thanks to @ghirlekar for suggesting that we keep track of the \"visited nodes\" to prevent infinite loops from happening. This also removes the need to remove nodes from queue. Reference: https://github.com/ericmjl/Network-Analysis-Made-Simple/issues/3 With thanks to @joshporter1 for the second bug fix. Originally there was an extraneous \"if\" statement that guaranteed that the \"False\" case would never be returned - because queue never changes in shape. Discovered at PyCon 2017. With thanks to @chendaniely for pointing out the extraneous \"break\". If you would like to see @dgerlanc's implementation, see https://github.com/ericmjl/Network-Analysis-Made-Simple/issues/76 \"\"\" visited_nodes = set() queue = [node1] for node in queue: neighbors = list(G.neighbors(node)) if node2 in neighbors: return True else: visited_nodes.add(node) queue.extend([n for n in neighbors if n not in visited_nodes]) return False def path_exists_deque(node1, node2, G): \"\"\"An alternative implementation.\"\"\" from collections import deque visited_nodes = set() queue = deque([node1]) while len(queue) > 0: node = queue.popleft() neighbors = list(G.neighbors(node)) if node2 in neighbors: return True else: visited_nodes.add(node) queue.extend([n for n in neighbors if n not in visited_nodes]) return False import nxviz as nv from nxviz import annotate, highlights def plot_path_with_neighbors(G, n1, n2): \"\"\"Plot a path with the heighbors of of the nodes along that path.\"\"\" path = nx.shortest_path(G, n1, n2) nodes = [*path] for node in path: nodes.extend(list(G.neighbors(node))) nodes = list(set(nodes)) g = G.subgraph(nodes) nv.arc( g, sort_by=\"order\", node_color_by=\"order\", edge_aes_kwargs={\"alpha_scale\": 0.5} ) for n in path: highlights.arc_node(g, n, sort_by=\"order\") for n1, n2 in zip(path[:-1], path[1:]): highlights.arc_edge(g, n1, n2, sort_by=\"order\") def plot_degree_betweenness(G): \"\"\"Plot scatterplot between degree and betweenness centrality.\"\"\" bc = pd.Series(nx.betweenness_centrality(G)) dc = pd.Series(nx.degree_centrality(G)) df = pd.DataFrame(dict(bc=bc, dc=dc)) ax = df.plot(x=\"dc\", y=\"bc\", kind=\"scatter\") ax.set_ylabel(\"Betweenness\\nCentrality\") ax.set_xlabel(\"Degree Centrality\") sns.despine()","title":"Solutions"},{"location":"02-algorithms/03-structures/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); % load_ext autoreload % autoreload 2 % matplotlib inline % config InlineBackend . figure_format = 'retina' Introduction from IPython.display import YouTubeVideo YouTubeVideo ( id = \"3DWSRCbPPJs\" , width = \"100%\" ) If you remember, at the beginning of this book, we saw a quote from John Quackenbush that essentially said that the reason a graph is interesting is because of its edges. In this chapter, we'll see this in action once again, as we are going to figure out how to leverage the edges to find special structures in a graph. Triangles The first structure that we are going to learn about is triangles . Triangles are super interesting! They are what one might consider to be \"the simplest complex structure\" in a graph. Triangles can also have semantically-rich meaning depending on the application. To borrow a bad example, love triangles in social networks are generally frowned upon, while on the other hand, when we connect two people that we know together, we instead complete a triangle. Load Data To learn about triangles, we are going to leverage a physician trust network. Here's the data description: This directed network captures innovation spread among 246 physicians for towns in Illinois, Peoria, Bloomington, Quincy and Galesburg. The data was collected in 1966. A node represents a physician and an edge between two physicians shows that the left physician told that the right physician is his friend or that he turns to the right physician if he needs advice or is interested in a discussion. There always only exists one edge between two nodes even if more than one of the listed conditions are true. from nams import load_data as cf G = cf . load_physicians_network () Exercise: Finding triangles in a graph This exercise is going to flex your ability to \"think on a graph\", just as you did in the previous chapters. Leveraging what you know, can you think of a few strategies to find triangles in a graph? from nams.solutions.structures import triangle_finding_strategies # triangle_finding_strategies() /home/runner/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.0 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.6.3, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( Exercise: Identify whether a node is in a triangle relationship or not Let's now get down to implementing this next piece of code. Write a function that identifies whether a node is or is not in a triangle relationship. It should take in a graph G and a node n , and return a boolean True if the node n is in any triangle relationship and boolean False if the node n is not in any triangle relationship. A hint that may help you: Every graph object G has a G.has_edge(n1, n2) method that you can use to identify whether a graph has an edge between n1 and n2 . Also: itertools.combinations lets you iterate over every K-combination of items in an iterable. def in_triangle ( G , node ): # Your answer here pass # COMMENT OUT THE IMPORT LINE TO TEST YOUR ANSWER from nams.solutions.structures import in_triangle # UNCOMMENT THE NEXT LINE TO SEE MY ANSWER # in_triangle?? Now, test your implementation below! The code cell will not error out if your answer is correct. from random import sample import networkx as nx def test_in_triangle (): nodes = sample ( G . nodes (), 10 ) for node in nodes : assert in_triangle ( G , 3 ) == bool ( nx . triangles ( G , 3 )) test_in_triangle () As you can see from the test function above, NetworkX provides an nx.triangles(G, node) function. It returns the number of triangles that a node is involved in. We convert it to boolean as a hack to check whether or not a node is involved in a triangle relationship because 0 is equivalent to boolean False , while any non-zero number is equivalent to boolean True . Exercise: Extract triangles for plotting We're going to leverage another piece of knowledge that you already have: the ability to extract subgraphs. We'll be plotting all of the triangles that a node is involved in. Given a node, write a function that extracts out all of the neighbors that it is in a triangle relationship with. Then, in a new function, implement code that plots only the subgraph that contains those nodes. def get_triangle_neighbors ( G , n ): # Your answer here pass # COMMENT OUT THE IMPORT LINE TO TEST YOUR ANSWER from nams.solutions.structures import get_triangle_neighbors # UNCOMMENT THE NEXT LINE TO SEE MY ANSWER # get_triangle_neighbors?? def plot_triangle_relations ( G , n ): # Your answer here pass # COMMENT OUT THE IMPORT LINE TO TEST YOUR ANSWER from nams.solutions.structures import plot_triangle_relations plot_triangle_relations ( G , 3 ) Triadic Closure In professional circles, making connections between two people is one of the most valuable things you can do professionally. What you do in that moment is what we would call triadic closure . Algorithmically, we can do the same thing if we maintain a graph of connections! Essentially, what we are looking for are \"open\" or \"unfinished\" triangles\". In this section, we'll try our hand at implementing a rudimentary triadic closure system. Exercise: Design the algorithm What graph logic would you use to identify triadic closure opportunities? Try writing out your general strategy, or discuss it with someone. from nams.solutions.structures import triadic_closure_algorithm # UNCOMMENT FOR MY ANSWER # triadic_closure_algorithm() Exercise: Implement triadic closure. Now, try your hand at implementing triadic closure. Write a function that takes in a graph G and a node n , and returns all of the neighbors that are potential triadic closures with n being the center node. def get_open_triangles_neighbors ( G , n ): # Your answer here pass # COMMENT OUT THE IMPORT LINE TO TEST YOUR ANSWER from nams.solutions.structures import get_open_triangles_neighbors # UNCOMMENT THE NEXT LINE TO SEE MY ANSWER # get_open_triangles_neighbors?? Exercise: Plot the open triangles Now, write a function that takes in a graph G and a node n , and plots out that node n and all of the neighbors that it could help close triangles with. def plot_open_triangle_relations ( G , n ): # Your answer here pass # COMMENT OUT THE IMPORT LINE TO TEST YOUR ANSWER from nams.solutions.structures import plot_open_triangle_relations plot_open_triangle_relations ( G , 3 ) Cliques Triangles are interesting in a graph theoretic setting because triangles are the simplest complex clique that exist. But wait! What is the definition of a \"clique\"? A \"clique\" is a set of nodes in a graph that are fully connected with one another by edges between them. Exercise: Simplest cliques Given this definition, what is the simplest \"clique\" possible? from nams.solutions.structures import simplest_clique # UNCOMMENT THE NEXT LINE TO SEE MY ANSWER # simplest_clique() k k -Cliques Cliques are identified by their size k k , which is the number of nodes that are present in the clique. A triangle is what we would consider to be a k k -clique where k=3 k=3 . A square with cross-diagonal connections is what we would consider to be a k k -clique where k=4 k=4 . By now, you should get the gist of the idea. Maximal Cliques Related to this idea of a k k -clique is another idea called \"maximal cliques\". Maximal cliques are defined as follows: A maximal clique is a subgraph of nodes in a graph to which no other node can be added to it and still remain a clique. NetworkX provides a way to find all maximal cliques: # I have truncated the output to the first 5 maximal cliques. list ( nx . find_cliques ( G ))[ 0 : 5 ] [[1, 2], [1, 3], [1, 4, 5, 6], [1, 7], [1, 72]] Exercise: finding sized- k k maximal cliques Write a generator function that yields all maximal cliques of size k k . I'm requesting a generator as a matter of good practice; you never know when the list you return might explode in memory consumption, so generators are a cheap and easy way to reduce memory usage. def size_k_maximal_cliques ( G , k ): # Your answer here pass # COMMENT OUT THE IMPORT LINE TO TEST YOUR ANSWER from nams.solutions.structures import size_k_maximal_cliques Now, test your implementation against the test function below. def test_size_k_maximal_cliques ( G , k ): clique_generator = size_k_maximal_cliques ( G , k ) for clique in clique_generator : assert len ( clique ) == k test_size_k_maximal_cliques ( G , 5 ) Clique Decomposition One super neat property of cliques is that every clique of size k k can be decomposed to the set of cliques of size k-1 k-1 . Does this make sense to you? If not, think about triangles (3-cliques). They can be decomposed to three edges (2-cliques). Think again about 4-cliques. Housed within 4-cliques are four 3-cliques. Draw it out if you're still not convinced! Exercise: finding all k k -cliques in a graph Knowing this property of k k -cliques, write a generator function that yields all k k -cliques in a graph, leveraging the nx.find_cliques(G) function. Some hints to help you along: If a k k -clique can be decomposed to its k-1 k-1 cliques, it follows that the k-1 k-1 cliques can be decomposed into k-2 k-2 cliques, and so on until you hit 2-cliques. This implies that all cliques of size k k house cliques of size n < k n < k , where n >= 2 n >= 2 . def find_k_cliques ( G , k ): # your answer here pass # COMMENT OUT THE IMPORT LINE TO TEST YOUR ANSWER from nams.solutions.structures import find_k_cliques def test_find_k_cliques ( G , k ): for clique in find_k_cliques ( G , k ): assert len ( clique ) == k test_find_k_cliques ( G , 3 ) Connected Components Now that we've explored a lot around cliques, we're now going to explore this idea of \"connected components\". To do so, I am going to have you draw the graph that we are working with. import nxviz as nv nv . circos ( G ) <AxesSubplot:> Exercise: Visual insights From this rendering of the CircosPlot, what visual insights do you have about the structure of the graph? from nams.solutions.structures import visual_insights # UNCOMMENT TO SEE MY ANSWER # visual_insights() Defining connected components From Wikipedia : In graph theory, a connected component (or just component) of an undirected graph is a subgraph in which any two vertices are connected to each other by paths, and which is connected to no additional vertices in the supergraph. NetworkX provides a function to let us find all of the connected components: ccsubgraph_nodes = list ( nx . connected_components ( G )) Let's see how many connected component subgraphs are present: len ( ccsubgraph_nodes ) 4 Exercise: visualizing connected component subgraphs In this exercise, we're going to draw a circos plot of the graph, but colour and order the nodes by their connected component subgraph. Recall Circos API: c = CircosPlot ( G , node_order = 'node_attribute' , node_color = 'node_attribute' ) c . draw () plt . show () # or plt.savefig(...) Follow the steps along here to accomplish this. Firstly, label the nodes with a unique identifier for connected component subgraph that it resides in. Use subgraph to store this piece of metadata. def label_connected_component_subgraphs ( G ): # Your answer here return G # COMMENT OUT THE IMPORT LINE TO TEST YOUR ANSWER from nams.solutions.structures import label_connected_component_subgraphs G_labelled = label_connected_component_subgraphs ( G ) # UNCOMMENT TO SEE THE ANSWER # label_connected_component_subgraphs?? Now, draw a CircosPlot with the node order and colouring dictated by the subgraph key. def plot_cc_subgraph ( G ): # Your answer here pass # COMMENT OUT THE IMPORT LINE TO TEST YOUR ANSWER from nams.solutions.structures import plot_cc_subgraph from nxviz import annotate plot_cc_subgraph ( G_labelled ) annotate . circos_group ( G_labelled , group_by = \"subgraph\" ) Using an arc plot will also clearly illuminate for us that there are no inter-group connections. nv . arc ( G_labelled , group_by = \"subgraph\" , node_color_by = \"subgraph\" ) annotate . arc_group ( G_labelled , group_by = \"subgraph\" , rotation = 0 ) Voila! It looks quite clear that there are indeed four disjoint group of physicians. Solutions from nams.solutions import structures import inspect print ( inspect . getsource ( structures )) \"\"\"Solutions to Structures chapter.\"\"\" from itertools import combinations import networkx as nx from nxviz import circos from nams.functions import render_html def triangle_finding_strategies(): \"\"\" How to find triangles. \"\"\" ans = \"\"\" One way would be to take one node, and look at its neighbors. If its neighbors are also connected to one another, then we have found a triangle. Another way would be to start at a given node, and walk out two nodes. If the starting node is the neighbor of the node two hops away, then the path we traced traces out the nodes in a triangle. \"\"\" return render_html(ans) def in_triangle(G, node): \"\"\" Return whether a given node is present in a triangle relationship. \"\"\" for nbr1, nbr2 in combinations(G.neighbors(node), 2): if G.has_edge(nbr1, nbr2): return True return False def get_triangle_neighbors(G, node) -> set: \"\"\" Return neighbors involved in triangle relationship with node. \"\"\" neighbors1 = set(G.neighbors(node)) triangle_nodes = set() for nbr1, nbr2 in combinations(neighbors1, 2): if G.has_edge(nbr1, nbr2): triangle_nodes.add(nbr1) triangle_nodes.add(nbr2) return triangle_nodes def plot_triangle_relations(G, node): \"\"\" Plot all triangle relationships for a given node. \"\"\" triangle_nbrs = get_triangle_neighbors(G, node) triangle_nbrs.add(node) nx.draw(G.subgraph(triangle_nbrs), with_labels=True) def triadic_closure_algorithm(): \"\"\" How to do triadic closure. \"\"\" ans = \"\"\" I would suggest the following strategy: 1. Pick a node 1. For every pair of neighbors: 1. If neighbors are not connected, then this is a potential triangle to close. This strategy gives you potential triadic closures given a \"center\" node `n`. The other way is to trace out a path two degrees out and ask whether the terminal node is a neighbor of the starting node. If not, then we have another triadic closure to make. \"\"\" return render_html(ans) def get_open_triangles_neighbors(G, node) -> set: \"\"\" Return neighbors involved in open triangle relationships with a node. \"\"\" open_triangle_nodes = set() neighbors = list(G.neighbors(node)) for n1, n2 in combinations(neighbors, 2): if not G.has_edge(n1, n2): open_triangle_nodes.add(n1) open_triangle_nodes.add(n2) return open_triangle_nodes def plot_open_triangle_relations(G, node): \"\"\" Plot open triangle relationships for a given node. \"\"\" open_triangle_nbrs = get_open_triangles_neighbors(G, node) open_triangle_nbrs.add(node) nx.draw(G.subgraph(open_triangle_nbrs), with_labels=True) def simplest_clique(): \"\"\" Answer to \"what is the simplest clique\". \"\"\" return render_html(\"The simplest clique is an edge.\") def size_k_maximal_cliques(G, k): \"\"\" Return all size-k maximal cliques. \"\"\" for clique in nx.find_cliques(G): if len(clique) == k: yield clique def find_k_cliques(G, k): \"\"\" Find all cliques of size k. \"\"\" for clique in nx.find_cliques(G): if len(clique) >= k: for nodeset in combinations(clique, k): yield nodeset def visual_insights(): \"\"\" Answer to visual insights exercise. \"\"\" ans = \"\"\" We might hypothesize that there are 3, maybe 4 different \"communities\" of nodes that are completely disjoint with one another, i.e. there is no path between them. \"\"\" print(ans) def label_connected_component_subgraphs(G): \"\"\"Label all connected component subgraphs.\"\"\" G = G.copy() for i, nodeset in enumerate(nx.connected_components(G)): for n in nodeset: G.nodes[n][\"subgraph\"] = i return G def plot_cc_subgraph(G): \"\"\"Plot all connected component subgraphs.\"\"\" c = circos(G, node_color_by=\"subgraph\", group_by=\"subgraph\")","title":"Chapter 6: Structures"},{"location":"02-algorithms/03-structures/#introduction","text":"from IPython.display import YouTubeVideo YouTubeVideo ( id = \"3DWSRCbPPJs\" , width = \"100%\" ) If you remember, at the beginning of this book, we saw a quote from John Quackenbush that essentially said that the reason a graph is interesting is because of its edges. In this chapter, we'll see this in action once again, as we are going to figure out how to leverage the edges to find special structures in a graph.","title":"Introduction"},{"location":"02-algorithms/03-structures/#triangles","text":"The first structure that we are going to learn about is triangles . Triangles are super interesting! They are what one might consider to be \"the simplest complex structure\" in a graph. Triangles can also have semantically-rich meaning depending on the application. To borrow a bad example, love triangles in social networks are generally frowned upon, while on the other hand, when we connect two people that we know together, we instead complete a triangle.","title":"Triangles"},{"location":"02-algorithms/03-structures/#load-data","text":"To learn about triangles, we are going to leverage a physician trust network. Here's the data description: This directed network captures innovation spread among 246 physicians for towns in Illinois, Peoria, Bloomington, Quincy and Galesburg. The data was collected in 1966. A node represents a physician and an edge between two physicians shows that the left physician told that the right physician is his friend or that he turns to the right physician if he needs advice or is interested in a discussion. There always only exists one edge between two nodes even if more than one of the listed conditions are true. from nams import load_data as cf G = cf . load_physicians_network ()","title":"Load Data"},{"location":"02-algorithms/03-structures/#exercise-finding-triangles-in-a-graph","text":"This exercise is going to flex your ability to \"think on a graph\", just as you did in the previous chapters. Leveraging what you know, can you think of a few strategies to find triangles in a graph? from nams.solutions.structures import triangle_finding_strategies # triangle_finding_strategies() /home/runner/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.0 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.6.3, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn(","title":"Exercise: Finding triangles in a graph"},{"location":"02-algorithms/03-structures/#exercise-identify-whether-a-node-is-in-a-triangle-relationship-or-not","text":"Let's now get down to implementing this next piece of code. Write a function that identifies whether a node is or is not in a triangle relationship. It should take in a graph G and a node n , and return a boolean True if the node n is in any triangle relationship and boolean False if the node n is not in any triangle relationship. A hint that may help you: Every graph object G has a G.has_edge(n1, n2) method that you can use to identify whether a graph has an edge between n1 and n2 . Also: itertools.combinations lets you iterate over every K-combination of items in an iterable. def in_triangle ( G , node ): # Your answer here pass # COMMENT OUT THE IMPORT LINE TO TEST YOUR ANSWER from nams.solutions.structures import in_triangle # UNCOMMENT THE NEXT LINE TO SEE MY ANSWER # in_triangle?? Now, test your implementation below! The code cell will not error out if your answer is correct. from random import sample import networkx as nx def test_in_triangle (): nodes = sample ( G . nodes (), 10 ) for node in nodes : assert in_triangle ( G , 3 ) == bool ( nx . triangles ( G , 3 )) test_in_triangle () As you can see from the test function above, NetworkX provides an nx.triangles(G, node) function. It returns the number of triangles that a node is involved in. We convert it to boolean as a hack to check whether or not a node is involved in a triangle relationship because 0 is equivalent to boolean False , while any non-zero number is equivalent to boolean True .","title":"Exercise: Identify whether a node is in a triangle relationship or not"},{"location":"02-algorithms/03-structures/#exercise-extract-triangles-for-plotting","text":"We're going to leverage another piece of knowledge that you already have: the ability to extract subgraphs. We'll be plotting all of the triangles that a node is involved in. Given a node, write a function that extracts out all of the neighbors that it is in a triangle relationship with. Then, in a new function, implement code that plots only the subgraph that contains those nodes. def get_triangle_neighbors ( G , n ): # Your answer here pass # COMMENT OUT THE IMPORT LINE TO TEST YOUR ANSWER from nams.solutions.structures import get_triangle_neighbors # UNCOMMENT THE NEXT LINE TO SEE MY ANSWER # get_triangle_neighbors?? def plot_triangle_relations ( G , n ): # Your answer here pass # COMMENT OUT THE IMPORT LINE TO TEST YOUR ANSWER from nams.solutions.structures import plot_triangle_relations plot_triangle_relations ( G , 3 )","title":"Exercise: Extract triangles for plotting"},{"location":"02-algorithms/03-structures/#triadic-closure","text":"In professional circles, making connections between two people is one of the most valuable things you can do professionally. What you do in that moment is what we would call triadic closure . Algorithmically, we can do the same thing if we maintain a graph of connections! Essentially, what we are looking for are \"open\" or \"unfinished\" triangles\". In this section, we'll try our hand at implementing a rudimentary triadic closure system.","title":"Triadic Closure"},{"location":"02-algorithms/03-structures/#exercise-design-the-algorithm","text":"What graph logic would you use to identify triadic closure opportunities? Try writing out your general strategy, or discuss it with someone. from nams.solutions.structures import triadic_closure_algorithm # UNCOMMENT FOR MY ANSWER # triadic_closure_algorithm()","title":"Exercise: Design the algorithm"},{"location":"02-algorithms/03-structures/#exercise-implement-triadic-closure","text":"Now, try your hand at implementing triadic closure. Write a function that takes in a graph G and a node n , and returns all of the neighbors that are potential triadic closures with n being the center node. def get_open_triangles_neighbors ( G , n ): # Your answer here pass # COMMENT OUT THE IMPORT LINE TO TEST YOUR ANSWER from nams.solutions.structures import get_open_triangles_neighbors # UNCOMMENT THE NEXT LINE TO SEE MY ANSWER # get_open_triangles_neighbors??","title":"Exercise: Implement triadic closure."},{"location":"02-algorithms/03-structures/#exercise-plot-the-open-triangles","text":"Now, write a function that takes in a graph G and a node n , and plots out that node n and all of the neighbors that it could help close triangles with. def plot_open_triangle_relations ( G , n ): # Your answer here pass # COMMENT OUT THE IMPORT LINE TO TEST YOUR ANSWER from nams.solutions.structures import plot_open_triangle_relations plot_open_triangle_relations ( G , 3 )","title":"Exercise: Plot the open triangles"},{"location":"02-algorithms/03-structures/#cliques","text":"Triangles are interesting in a graph theoretic setting because triangles are the simplest complex clique that exist. But wait! What is the definition of a \"clique\"? A \"clique\" is a set of nodes in a graph that are fully connected with one another by edges between them.","title":"Cliques"},{"location":"02-algorithms/03-structures/#exercise-simplest-cliques","text":"Given this definition, what is the simplest \"clique\" possible? from nams.solutions.structures import simplest_clique # UNCOMMENT THE NEXT LINE TO SEE MY ANSWER # simplest_clique()","title":"Exercise: Simplest cliques"},{"location":"02-algorithms/03-structures/#kk-cliques","text":"Cliques are identified by their size k k , which is the number of nodes that are present in the clique. A triangle is what we would consider to be a k k -clique where k=3 k=3 . A square with cross-diagonal connections is what we would consider to be a k k -clique where k=4 k=4 . By now, you should get the gist of the idea.","title":"kk-Cliques"},{"location":"02-algorithms/03-structures/#maximal-cliques","text":"Related to this idea of a k k -clique is another idea called \"maximal cliques\". Maximal cliques are defined as follows: A maximal clique is a subgraph of nodes in a graph to which no other node can be added to it and still remain a clique. NetworkX provides a way to find all maximal cliques: # I have truncated the output to the first 5 maximal cliques. list ( nx . find_cliques ( G ))[ 0 : 5 ] [[1, 2], [1, 3], [1, 4, 5, 6], [1, 7], [1, 72]]","title":"Maximal Cliques"},{"location":"02-algorithms/03-structures/#exercise-finding-sized-kk-maximal-cliques","text":"Write a generator function that yields all maximal cliques of size k k . I'm requesting a generator as a matter of good practice; you never know when the list you return might explode in memory consumption, so generators are a cheap and easy way to reduce memory usage. def size_k_maximal_cliques ( G , k ): # Your answer here pass # COMMENT OUT THE IMPORT LINE TO TEST YOUR ANSWER from nams.solutions.structures import size_k_maximal_cliques Now, test your implementation against the test function below. def test_size_k_maximal_cliques ( G , k ): clique_generator = size_k_maximal_cliques ( G , k ) for clique in clique_generator : assert len ( clique ) == k test_size_k_maximal_cliques ( G , 5 )","title":"Exercise: finding sized-kk maximal cliques"},{"location":"02-algorithms/03-structures/#clique-decomposition","text":"One super neat property of cliques is that every clique of size k k can be decomposed to the set of cliques of size k-1 k-1 . Does this make sense to you? If not, think about triangles (3-cliques). They can be decomposed to three edges (2-cliques). Think again about 4-cliques. Housed within 4-cliques are four 3-cliques. Draw it out if you're still not convinced!","title":"Clique Decomposition"},{"location":"02-algorithms/03-structures/#exercise-finding-all-kk-cliques-in-a-graph","text":"Knowing this property of k k -cliques, write a generator function that yields all k k -cliques in a graph, leveraging the nx.find_cliques(G) function. Some hints to help you along: If a k k -clique can be decomposed to its k-1 k-1 cliques, it follows that the k-1 k-1 cliques can be decomposed into k-2 k-2 cliques, and so on until you hit 2-cliques. This implies that all cliques of size k k house cliques of size n < k n < k , where n >= 2 n >= 2 . def find_k_cliques ( G , k ): # your answer here pass # COMMENT OUT THE IMPORT LINE TO TEST YOUR ANSWER from nams.solutions.structures import find_k_cliques def test_find_k_cliques ( G , k ): for clique in find_k_cliques ( G , k ): assert len ( clique ) == k test_find_k_cliques ( G , 3 )","title":"Exercise: finding all kk-cliques in a graph"},{"location":"02-algorithms/03-structures/#connected-components","text":"Now that we've explored a lot around cliques, we're now going to explore this idea of \"connected components\". To do so, I am going to have you draw the graph that we are working with. import nxviz as nv nv . circos ( G ) <AxesSubplot:>","title":"Connected Components"},{"location":"02-algorithms/03-structures/#exercise-visual-insights","text":"From this rendering of the CircosPlot, what visual insights do you have about the structure of the graph? from nams.solutions.structures import visual_insights # UNCOMMENT TO SEE MY ANSWER # visual_insights()","title":"Exercise: Visual insights"},{"location":"02-algorithms/03-structures/#defining-connected-components","text":"From Wikipedia : In graph theory, a connected component (or just component) of an undirected graph is a subgraph in which any two vertices are connected to each other by paths, and which is connected to no additional vertices in the supergraph. NetworkX provides a function to let us find all of the connected components: ccsubgraph_nodes = list ( nx . connected_components ( G )) Let's see how many connected component subgraphs are present: len ( ccsubgraph_nodes ) 4","title":"Defining connected components"},{"location":"02-algorithms/03-structures/#exercise-visualizing-connected-component-subgraphs","text":"In this exercise, we're going to draw a circos plot of the graph, but colour and order the nodes by their connected component subgraph. Recall Circos API: c = CircosPlot ( G , node_order = 'node_attribute' , node_color = 'node_attribute' ) c . draw () plt . show () # or plt.savefig(...) Follow the steps along here to accomplish this. Firstly, label the nodes with a unique identifier for connected component subgraph that it resides in. Use subgraph to store this piece of metadata. def label_connected_component_subgraphs ( G ): # Your answer here return G # COMMENT OUT THE IMPORT LINE TO TEST YOUR ANSWER from nams.solutions.structures import label_connected_component_subgraphs G_labelled = label_connected_component_subgraphs ( G ) # UNCOMMENT TO SEE THE ANSWER # label_connected_component_subgraphs?? Now, draw a CircosPlot with the node order and colouring dictated by the subgraph key. def plot_cc_subgraph ( G ): # Your answer here pass # COMMENT OUT THE IMPORT LINE TO TEST YOUR ANSWER from nams.solutions.structures import plot_cc_subgraph from nxviz import annotate plot_cc_subgraph ( G_labelled ) annotate . circos_group ( G_labelled , group_by = \"subgraph\" ) Using an arc plot will also clearly illuminate for us that there are no inter-group connections. nv . arc ( G_labelled , group_by = \"subgraph\" , node_color_by = \"subgraph\" ) annotate . arc_group ( G_labelled , group_by = \"subgraph\" , rotation = 0 ) Voila! It looks quite clear that there are indeed four disjoint group of physicians.","title":"Exercise: visualizing connected component subgraphs"},{"location":"02-algorithms/03-structures/#solutions","text":"from nams.solutions import structures import inspect print ( inspect . getsource ( structures )) \"\"\"Solutions to Structures chapter.\"\"\" from itertools import combinations import networkx as nx from nxviz import circos from nams.functions import render_html def triangle_finding_strategies(): \"\"\" How to find triangles. \"\"\" ans = \"\"\" One way would be to take one node, and look at its neighbors. If its neighbors are also connected to one another, then we have found a triangle. Another way would be to start at a given node, and walk out two nodes. If the starting node is the neighbor of the node two hops away, then the path we traced traces out the nodes in a triangle. \"\"\" return render_html(ans) def in_triangle(G, node): \"\"\" Return whether a given node is present in a triangle relationship. \"\"\" for nbr1, nbr2 in combinations(G.neighbors(node), 2): if G.has_edge(nbr1, nbr2): return True return False def get_triangle_neighbors(G, node) -> set: \"\"\" Return neighbors involved in triangle relationship with node. \"\"\" neighbors1 = set(G.neighbors(node)) triangle_nodes = set() for nbr1, nbr2 in combinations(neighbors1, 2): if G.has_edge(nbr1, nbr2): triangle_nodes.add(nbr1) triangle_nodes.add(nbr2) return triangle_nodes def plot_triangle_relations(G, node): \"\"\" Plot all triangle relationships for a given node. \"\"\" triangle_nbrs = get_triangle_neighbors(G, node) triangle_nbrs.add(node) nx.draw(G.subgraph(triangle_nbrs), with_labels=True) def triadic_closure_algorithm(): \"\"\" How to do triadic closure. \"\"\" ans = \"\"\" I would suggest the following strategy: 1. Pick a node 1. For every pair of neighbors: 1. If neighbors are not connected, then this is a potential triangle to close. This strategy gives you potential triadic closures given a \"center\" node `n`. The other way is to trace out a path two degrees out and ask whether the terminal node is a neighbor of the starting node. If not, then we have another triadic closure to make. \"\"\" return render_html(ans) def get_open_triangles_neighbors(G, node) -> set: \"\"\" Return neighbors involved in open triangle relationships with a node. \"\"\" open_triangle_nodes = set() neighbors = list(G.neighbors(node)) for n1, n2 in combinations(neighbors, 2): if not G.has_edge(n1, n2): open_triangle_nodes.add(n1) open_triangle_nodes.add(n2) return open_triangle_nodes def plot_open_triangle_relations(G, node): \"\"\" Plot open triangle relationships for a given node. \"\"\" open_triangle_nbrs = get_open_triangles_neighbors(G, node) open_triangle_nbrs.add(node) nx.draw(G.subgraph(open_triangle_nbrs), with_labels=True) def simplest_clique(): \"\"\" Answer to \"what is the simplest clique\". \"\"\" return render_html(\"The simplest clique is an edge.\") def size_k_maximal_cliques(G, k): \"\"\" Return all size-k maximal cliques. \"\"\" for clique in nx.find_cliques(G): if len(clique) == k: yield clique def find_k_cliques(G, k): \"\"\" Find all cliques of size k. \"\"\" for clique in nx.find_cliques(G): if len(clique) >= k: for nodeset in combinations(clique, k): yield nodeset def visual_insights(): \"\"\" Answer to visual insights exercise. \"\"\" ans = \"\"\" We might hypothesize that there are 3, maybe 4 different \"communities\" of nodes that are completely disjoint with one another, i.e. there is no path between them. \"\"\" print(ans) def label_connected_component_subgraphs(G): \"\"\"Label all connected component subgraphs.\"\"\" G = G.copy() for i, nodeset in enumerate(nx.connected_components(G)): for n in nodeset: G.nodes[n][\"subgraph\"] = i return G def plot_cc_subgraph(G): \"\"\"Plot all connected component subgraphs.\"\"\" c = circos(G, node_color_by=\"subgraph\", group_by=\"subgraph\")","title":"Solutions"},{"location":"03-practical/01-io/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); % load_ext autoreload % autoreload 2 % matplotlib inline % config InlineBackend . figure_format = 'retina' Introduction from IPython.display import YouTubeVideo YouTubeVideo ( id = \"3sJnTpeFXZ4\" , width = \"100%\" ) In order to get you familiar with graph ideas, I have deliberately chosen to steer away from the more pedantic matters of loading graph data to and from disk. That said, the following scenario will eventually happen, where a graph dataset lands on your lap, and you'll need to load it in memory and start analyzing it. Thus, we're going to go through graph I/O, specifically the APIs on how to convert graph data that comes to you into that magical NetworkX object G . Let's get going! Graph Data as Tables Let's recall what we've learned in the introductory chapters. Graphs can be represented using two sets : Node set Edge set Node set as tables Let's say we had a graph with 3 nodes in it: A, B, C . We could represent it in plain text, computer-readable format: A B C Suppose the nodes also had metadata. Then, we could tag on metadata as well: A, circle, 5 B, circle, 7 C, square, 9 Does this look familiar to you? Yes, node sets can be stored in CSV format, with one of the columns being node ID, and the rest of the columns being metadata. Edge set as tables If, between the nodes, we had 4 edges (this is a directed graph), we can also represent those edges in plain text, computer-readable format: A, C B, C A, B C, A And let's say we also had other metadata, we can represent it in the same CSV format: A, C, red B, C, orange A, B, yellow C, A, green If you've been in the data world for a while, this should not look foreign to you. Yes, edge sets can be stored in CSV format too! Two of the columns represent the nodes involved in an edge, and the rest of the columns represent the metadata. Combined Representation In fact, one might also choose to combine the node set and edge set tables together in a merged format: n1, n2, colour, shape1, num1, shape2, num2 A, C, red, circle, 5, square, 9 B, C, orange, circle, 7, square, 9 A, B, yellow, circle, 5, circle, 7 C, A, green, square, 9, circle, 5 In this chapter, the datasets that we will be looking at are going to be formatted in both ways. Let's get going. Dataset We will be working with the Divvy bike sharing dataset. Divvy is a bike sharing service in Chicago. Since 2013, Divvy has released their bike sharing dataset to the public. The 2013 dataset is comprised of two files: - Divvy_Stations_2013.csv , containing the stations in the system, and - DivvyTrips_2013.csv , containing the trips. Let's dig into the data! from pyprojroot import here Firstly, we need to unzip the dataset: import zipfile import os from nams.load_data import datasets # This block of code checks to make sure that a particular directory is present. if \"divvy_2013\" not in os . listdir ( datasets ): print ( 'Unzipping the divvy_2013.zip file in the datasets folder.' ) with zipfile . ZipFile ( datasets / \"divvy_2013.zip\" , \"r\" ) as zip_ref : zip_ref . extractall ( datasets ) Now, let's load in both tables. First is the stations table: import pandas as pd stations = pd . read_csv ( datasets / 'divvy_2013/Divvy_Stations_2013.csv' , parse_dates = [ 'online date' ], encoding = 'utf-8' ) stations . head () id name latitude longitude dpcapacity landmark online date 0 5 State St & Harrison St 41.874 -87.6277 19 30 2013-06-28 1 13 Wilton Ave & Diversey Pkwy 41.9325 -87.6527 19 66 2013-06-28 2 14 Morgan St & 18th St 41.8581 -87.6511 15 163 2013-06-28 3 15 Racine Ave & 18th St 41.8582 -87.6565 15 164 2013-06-28 4 16 Wood St & North Ave 41.9103 -87.6725 15 223 2013-08-12 stations . describe () id latitude longitude dpcapacity landmark count 300 300 300 300 300 mean 189.063 41.8963 -87.6482 16.8 192.013 std 99.4845 0.0409522 0.0230011 4.67399 120.535 min 5 41.7887 -87.7079 11 1 25% 108.75 41.8718 -87.6658 15 83.75 50% 196.5 41.8946 -87.6486 15 184.5 75% 276.25 41.9264 -87.6318 19 288.25 max 351 41.9784 -87.5807 47 440 Now, let's load in the trips table. trips = pd . read_csv ( datasets / 'divvy_2013/Divvy_Trips_2013.csv' , parse_dates = [ 'starttime' , 'stoptime' ]) trips . head () /home/runner/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/IPython/core/interactiveshell.py:3165: DtypeWarning: Columns (10) have mixed types.Specify dtype option on import or set low_memory=False. has_raised = await self.run_ast_nodes(code_ast.body, cell_name, trip_id starttime stoptime bikeid tripduration from_station_id from_station_name to_station_id to_station_name usertype gender birthday 0 4118 2013-06-27 12:11:00 2013-06-27 12:16:00 480 316 85 Michigan Ave & Oak St 28 Larrabee St & Menomonee St Customer nan nan 1 4275 2013-06-27 14:44:00 2013-06-27 14:45:00 77 64 32 Racine Ave & Congress Pkwy 32 Racine Ave & Congress Pkwy Customer nan nan 2 4291 2013-06-27 14:58:00 2013-06-27 15:05:00 77 433 32 Racine Ave & Congress Pkwy 19 Loomis St & Taylor St Customer nan nan 3 4316 2013-06-27 15:06:00 2013-06-27 15:09:00 77 123 19 Loomis St & Taylor St 19 Loomis St & Taylor St Customer nan nan 4 4342 2013-06-27 15:13:00 2013-06-27 15:27:00 77 852 19 Loomis St & Taylor St 55 Halsted St & James M Rochford St Customer nan nan import janitor trips_summary = ( trips . groupby ([ \"from_station_id\" , \"to_station_id\" ]) . count () . reset_index () . select_columns ( [ \"from_station_id\" , \"to_station_id\" , \"trip_id\" ] ) . rename_column ( \"trip_id\" , \"num_trips\" ) ) trips_summary . head () from_station_id to_station_id num_trips 0 5 5 232 1 5 13 1 2 5 14 15 3 5 15 9 4 5 16 4 Graph Model Given the data, if we wished to use a graph as a data model for the number of trips between stations, then naturally, nodes would be the stations, and edges would be trips between them. This graph would be directed, as one could have more trips from station A to B and less in the reverse. With this definition, we can begin graph construction! Create NetworkX graph from pandas edgelist NetworkX provides an extremely convenient way to load data from a pandas DataFrame: import networkx as nx G = nx . from_pandas_edgelist ( df = trips_summary , source = \"from_station_id\" , target = \"to_station_id\" , edge_attr = [ \"num_trips\" ], create_using = nx . DiGraph ) Inspect the graph Once the graph is in memory, we can inspect it to get out summary graph statistics. print ( nx . info ( G )) Name: Type: DiGraph Number of nodes: 300 Number of edges: 44422 Average in degree: 148.0733 Average out degree: 148.0733 You'll notice that the edge metadata have been added correctly: we have recorded in there the number of trips between stations. list ( G . edges ( data = True ))[ 0 : 5 ] [(5, 5, {'num_trips': 232}), (5, 13, {'num_trips': 1}), (5, 14, {'num_trips': 15}), (5, 15, {'num_trips': 9}), (5, 16, {'num_trips': 4})] However, the node metadata is not present: list ( G . nodes ( data = True ))[ 0 : 5 ] [(5, {}), (13, {}), (14, {}), (15, {}), (16, {})] Annotate node metadata We have rich station data on hand, such as the longitude and latitude of each station, and it would be a pity to discard it, especially when we can potentially use it as part of the analysis or for visualization purposes. Let's see how we can add this information in. Firstly, recall what the stations dataframe looked like: stations . head () id name latitude longitude dpcapacity landmark online date 0 5 State St & Harrison St 41.874 -87.6277 19 30 2013-06-28 1 13 Wilton Ave & Diversey Pkwy 41.9325 -87.6527 19 66 2013-06-28 2 14 Morgan St & 18th St 41.8581 -87.6511 15 163 2013-06-28 3 15 Racine Ave & 18th St 41.8582 -87.6565 15 164 2013-06-28 4 16 Wood St & North Ave 41.9103 -87.6725 15 223 2013-08-12 The id column gives us the node ID in the graph, so if we set id to be the index, if we then also loop over each row, we can treat the rest of the columns as dictionary keys and values as dictionary values, and add the information into the graph. Let's see this in action. for node , metadata in stations . set_index ( \"id\" ) . iterrows (): for key , val in metadata . items (): G . nodes [ node ][ key ] = val Now, our node metadata should be populated. list ( G . nodes ( data = True ))[ 0 : 5 ] [(5, {'name': 'State St & Harrison St', 'latitude': 41.87395806, 'longitude': -87.62773949, 'dpcapacity': 19, 'landmark': 30, 'online date': Timestamp('2013-06-28 00:00:00')}), (13, {'name': 'Wilton Ave & Diversey Pkwy', 'latitude': 41.93250008, 'longitude': -87.65268082, 'dpcapacity': 19, 'landmark': 66, 'online date': Timestamp('2013-06-28 00:00:00')}), (14, {'name': 'Morgan St & 18th St', 'latitude': 41.858086, 'longitude': -87.651073, 'dpcapacity': 15, 'landmark': 163, 'online date': Timestamp('2013-06-28 00:00:00')}), (15, {'name': 'Racine Ave & 18th St', 'latitude': 41.85818061, 'longitude': -87.65648665, 'dpcapacity': 15, 'landmark': 164, 'online date': Timestamp('2013-06-28 00:00:00')}), (16, {'name': 'Wood St & North Ave', 'latitude': 41.910329, 'longitude': -87.672516, 'dpcapacity': 15, 'landmark': 223, 'online date': Timestamp('2013-08-12 00:00:00')})] In nxviz , a GeoPlot object is available that allows you to quickly visualize a graph that has geographic data. However, being matplotlib -based, it is going to be quickly overwhelmed by the sheer number of edges. As such, we are going to first filter the edges. Exercise: Filter graph edges Leveraging what you know about how to manipulate graphs, now try filtering edges. Hint: NetworkX graph objects can be deep-copied using G.copy() : G_copy = G . copy () Hint: NetworkX graph objects also let you remove edges: G . remove_edge ( node1 , node2 ) # does not return anything def filter_graph ( G , minimum_num_trips ): \"\"\" Filter the graph such that only edges that have minimum_num_trips or more are present. \"\"\" G_filtered = G . ____ () for _ , _ , _ in G . _____ ( data = ____ ): if d [ ___________ ] < ___ : G_________ . ___________ ( _ , _ ) return G_filtered from nams.solutions.io import filter_graph G_filtered = filter_graph ( G , 50 ) Visualize using GeoPlot nxviz provides a GeoPlot object that lets you quickly visualize geospatial graph data. A note on geospatial visualizations: As the creator of nxviz , I would recommend using proper geospatial packages to build custom geospatial graph viz, such as pysal .) That said, nxviz can probably do what you need for a quick-and-dirty view of the data. import nxviz as nv c = nv . geo ( G_filtered , node_color_by = \"dpcapacity\" ) /home/runner/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.0 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.6.3, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( Does that look familiar to you? Looks quite a bit like Chicago, I'd say :) Jesting aside, this visualization does help illustrate that the majority of trips occur between stations that are near the city center. Pickling Graphs Since NetworkX graphs are Python objects, the canonical way to save them is by pickling them. You can do this using: nx . write_gpickle ( G , file_path ) Here's an example in action: nx . write_gpickle ( G , \"/tmp/divvy.pkl\" ) And just to show that it can be loaded back into memory: G_loaded = nx . read_gpickle ( \"/tmp/divvy.pkl\" ) Exercise: checking graph integrity If you get a graph dataset as a pickle, you should always check it against reference properties to make sure of its data integrity. Write a function that tests that the graph has the correct number of nodes and edges inside it. def test_graph_integrity ( G ): \"\"\"Test integrity of raw Divvy graph.\"\"\" # Your solution here pass from nams.solutions.io import test_graph_integrity test_graph_integrity ( G ) Other text formats CSV files and pandas DataFrames give us a convenient way to store graph data, and if possible, do insist with your data collaborators that they provide you with graph data that are in this format. If they don't, however, no sweat! After all, Python is super versatile. In this ebook, we have loaded data in from non-CSV sources, sometimes by parsing text files raw, sometimes by treating special characters as delimiters in a CSV-like file, and sometimes by resorting to parsing JSON. You can see other examples of how we load data by browsing through the source file of load_data.py and studying how we construct graph objects. Solutions The solutions to this chapter's exercises are below from nams.solutions import io import inspect print ( inspect . getsource ( io )) \"\"\"Solutions to I/O chapter\"\"\" def filter_graph(G, minimum_num_trips): \"\"\" Filter the graph such that only edges that have minimum_num_trips or more are present. \"\"\" G_filtered = G.copy() for u, v, d in G.edges(data=True): if d[\"num_trips\"] < minimum_num_trips: G_filtered.remove_edge(u, v) return G_filtered def test_graph_integrity(G): \"\"\"Test integrity of raw Divvy graph.\"\"\" assert len(G.nodes()) == 300 assert len(G.edges()) == 44422","title":"Chapter 7: Graph I/O"},{"location":"03-practical/01-io/#introduction","text":"from IPython.display import YouTubeVideo YouTubeVideo ( id = \"3sJnTpeFXZ4\" , width = \"100%\" ) In order to get you familiar with graph ideas, I have deliberately chosen to steer away from the more pedantic matters of loading graph data to and from disk. That said, the following scenario will eventually happen, where a graph dataset lands on your lap, and you'll need to load it in memory and start analyzing it. Thus, we're going to go through graph I/O, specifically the APIs on how to convert graph data that comes to you into that magical NetworkX object G . Let's get going!","title":"Introduction"},{"location":"03-practical/01-io/#graph-data-as-tables","text":"Let's recall what we've learned in the introductory chapters. Graphs can be represented using two sets : Node set Edge set","title":"Graph Data as Tables"},{"location":"03-practical/01-io/#node-set-as-tables","text":"Let's say we had a graph with 3 nodes in it: A, B, C . We could represent it in plain text, computer-readable format: A B C Suppose the nodes also had metadata. Then, we could tag on metadata as well: A, circle, 5 B, circle, 7 C, square, 9 Does this look familiar to you? Yes, node sets can be stored in CSV format, with one of the columns being node ID, and the rest of the columns being metadata.","title":"Node set as tables"},{"location":"03-practical/01-io/#edge-set-as-tables","text":"If, between the nodes, we had 4 edges (this is a directed graph), we can also represent those edges in plain text, computer-readable format: A, C B, C A, B C, A And let's say we also had other metadata, we can represent it in the same CSV format: A, C, red B, C, orange A, B, yellow C, A, green If you've been in the data world for a while, this should not look foreign to you. Yes, edge sets can be stored in CSV format too! Two of the columns represent the nodes involved in an edge, and the rest of the columns represent the metadata.","title":"Edge set as tables"},{"location":"03-practical/01-io/#combined-representation","text":"In fact, one might also choose to combine the node set and edge set tables together in a merged format: n1, n2, colour, shape1, num1, shape2, num2 A, C, red, circle, 5, square, 9 B, C, orange, circle, 7, square, 9 A, B, yellow, circle, 5, circle, 7 C, A, green, square, 9, circle, 5 In this chapter, the datasets that we will be looking at are going to be formatted in both ways. Let's get going.","title":"Combined Representation"},{"location":"03-practical/01-io/#dataset","text":"We will be working with the Divvy bike sharing dataset. Divvy is a bike sharing service in Chicago. Since 2013, Divvy has released their bike sharing dataset to the public. The 2013 dataset is comprised of two files: - Divvy_Stations_2013.csv , containing the stations in the system, and - DivvyTrips_2013.csv , containing the trips. Let's dig into the data! from pyprojroot import here Firstly, we need to unzip the dataset: import zipfile import os from nams.load_data import datasets # This block of code checks to make sure that a particular directory is present. if \"divvy_2013\" not in os . listdir ( datasets ): print ( 'Unzipping the divvy_2013.zip file in the datasets folder.' ) with zipfile . ZipFile ( datasets / \"divvy_2013.zip\" , \"r\" ) as zip_ref : zip_ref . extractall ( datasets ) Now, let's load in both tables. First is the stations table: import pandas as pd stations = pd . read_csv ( datasets / 'divvy_2013/Divvy_Stations_2013.csv' , parse_dates = [ 'online date' ], encoding = 'utf-8' ) stations . head () id name latitude longitude dpcapacity landmark online date 0 5 State St & Harrison St 41.874 -87.6277 19 30 2013-06-28 1 13 Wilton Ave & Diversey Pkwy 41.9325 -87.6527 19 66 2013-06-28 2 14 Morgan St & 18th St 41.8581 -87.6511 15 163 2013-06-28 3 15 Racine Ave & 18th St 41.8582 -87.6565 15 164 2013-06-28 4 16 Wood St & North Ave 41.9103 -87.6725 15 223 2013-08-12 stations . describe () id latitude longitude dpcapacity landmark count 300 300 300 300 300 mean 189.063 41.8963 -87.6482 16.8 192.013 std 99.4845 0.0409522 0.0230011 4.67399 120.535 min 5 41.7887 -87.7079 11 1 25% 108.75 41.8718 -87.6658 15 83.75 50% 196.5 41.8946 -87.6486 15 184.5 75% 276.25 41.9264 -87.6318 19 288.25 max 351 41.9784 -87.5807 47 440 Now, let's load in the trips table. trips = pd . read_csv ( datasets / 'divvy_2013/Divvy_Trips_2013.csv' , parse_dates = [ 'starttime' , 'stoptime' ]) trips . head () /home/runner/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/IPython/core/interactiveshell.py:3165: DtypeWarning: Columns (10) have mixed types.Specify dtype option on import or set low_memory=False. has_raised = await self.run_ast_nodes(code_ast.body, cell_name, trip_id starttime stoptime bikeid tripduration from_station_id from_station_name to_station_id to_station_name usertype gender birthday 0 4118 2013-06-27 12:11:00 2013-06-27 12:16:00 480 316 85 Michigan Ave & Oak St 28 Larrabee St & Menomonee St Customer nan nan 1 4275 2013-06-27 14:44:00 2013-06-27 14:45:00 77 64 32 Racine Ave & Congress Pkwy 32 Racine Ave & Congress Pkwy Customer nan nan 2 4291 2013-06-27 14:58:00 2013-06-27 15:05:00 77 433 32 Racine Ave & Congress Pkwy 19 Loomis St & Taylor St Customer nan nan 3 4316 2013-06-27 15:06:00 2013-06-27 15:09:00 77 123 19 Loomis St & Taylor St 19 Loomis St & Taylor St Customer nan nan 4 4342 2013-06-27 15:13:00 2013-06-27 15:27:00 77 852 19 Loomis St & Taylor St 55 Halsted St & James M Rochford St Customer nan nan import janitor trips_summary = ( trips . groupby ([ \"from_station_id\" , \"to_station_id\" ]) . count () . reset_index () . select_columns ( [ \"from_station_id\" , \"to_station_id\" , \"trip_id\" ] ) . rename_column ( \"trip_id\" , \"num_trips\" ) ) trips_summary . head () from_station_id to_station_id num_trips 0 5 5 232 1 5 13 1 2 5 14 15 3 5 15 9 4 5 16 4","title":"Dataset"},{"location":"03-practical/01-io/#graph-model","text":"Given the data, if we wished to use a graph as a data model for the number of trips between stations, then naturally, nodes would be the stations, and edges would be trips between them. This graph would be directed, as one could have more trips from station A to B and less in the reverse. With this definition, we can begin graph construction!","title":"Graph Model"},{"location":"03-practical/01-io/#create-networkx-graph-from-pandas-edgelist","text":"NetworkX provides an extremely convenient way to load data from a pandas DataFrame: import networkx as nx G = nx . from_pandas_edgelist ( df = trips_summary , source = \"from_station_id\" , target = \"to_station_id\" , edge_attr = [ \"num_trips\" ], create_using = nx . DiGraph )","title":"Create NetworkX graph from pandas edgelist"},{"location":"03-practical/01-io/#inspect-the-graph","text":"Once the graph is in memory, we can inspect it to get out summary graph statistics. print ( nx . info ( G )) Name: Type: DiGraph Number of nodes: 300 Number of edges: 44422 Average in degree: 148.0733 Average out degree: 148.0733 You'll notice that the edge metadata have been added correctly: we have recorded in there the number of trips between stations. list ( G . edges ( data = True ))[ 0 : 5 ] [(5, 5, {'num_trips': 232}), (5, 13, {'num_trips': 1}), (5, 14, {'num_trips': 15}), (5, 15, {'num_trips': 9}), (5, 16, {'num_trips': 4})] However, the node metadata is not present: list ( G . nodes ( data = True ))[ 0 : 5 ] [(5, {}), (13, {}), (14, {}), (15, {}), (16, {})]","title":"Inspect the graph"},{"location":"03-practical/01-io/#annotate-node-metadata","text":"We have rich station data on hand, such as the longitude and latitude of each station, and it would be a pity to discard it, especially when we can potentially use it as part of the analysis or for visualization purposes. Let's see how we can add this information in. Firstly, recall what the stations dataframe looked like: stations . head () id name latitude longitude dpcapacity landmark online date 0 5 State St & Harrison St 41.874 -87.6277 19 30 2013-06-28 1 13 Wilton Ave & Diversey Pkwy 41.9325 -87.6527 19 66 2013-06-28 2 14 Morgan St & 18th St 41.8581 -87.6511 15 163 2013-06-28 3 15 Racine Ave & 18th St 41.8582 -87.6565 15 164 2013-06-28 4 16 Wood St & North Ave 41.9103 -87.6725 15 223 2013-08-12 The id column gives us the node ID in the graph, so if we set id to be the index, if we then also loop over each row, we can treat the rest of the columns as dictionary keys and values as dictionary values, and add the information into the graph. Let's see this in action. for node , metadata in stations . set_index ( \"id\" ) . iterrows (): for key , val in metadata . items (): G . nodes [ node ][ key ] = val Now, our node metadata should be populated. list ( G . nodes ( data = True ))[ 0 : 5 ] [(5, {'name': 'State St & Harrison St', 'latitude': 41.87395806, 'longitude': -87.62773949, 'dpcapacity': 19, 'landmark': 30, 'online date': Timestamp('2013-06-28 00:00:00')}), (13, {'name': 'Wilton Ave & Diversey Pkwy', 'latitude': 41.93250008, 'longitude': -87.65268082, 'dpcapacity': 19, 'landmark': 66, 'online date': Timestamp('2013-06-28 00:00:00')}), (14, {'name': 'Morgan St & 18th St', 'latitude': 41.858086, 'longitude': -87.651073, 'dpcapacity': 15, 'landmark': 163, 'online date': Timestamp('2013-06-28 00:00:00')}), (15, {'name': 'Racine Ave & 18th St', 'latitude': 41.85818061, 'longitude': -87.65648665, 'dpcapacity': 15, 'landmark': 164, 'online date': Timestamp('2013-06-28 00:00:00')}), (16, {'name': 'Wood St & North Ave', 'latitude': 41.910329, 'longitude': -87.672516, 'dpcapacity': 15, 'landmark': 223, 'online date': Timestamp('2013-08-12 00:00:00')})] In nxviz , a GeoPlot object is available that allows you to quickly visualize a graph that has geographic data. However, being matplotlib -based, it is going to be quickly overwhelmed by the sheer number of edges. As such, we are going to first filter the edges.","title":"Annotate node metadata"},{"location":"03-practical/01-io/#exercise-filter-graph-edges","text":"Leveraging what you know about how to manipulate graphs, now try filtering edges. Hint: NetworkX graph objects can be deep-copied using G.copy() : G_copy = G . copy () Hint: NetworkX graph objects also let you remove edges: G . remove_edge ( node1 , node2 ) # does not return anything def filter_graph ( G , minimum_num_trips ): \"\"\" Filter the graph such that only edges that have minimum_num_trips or more are present. \"\"\" G_filtered = G . ____ () for _ , _ , _ in G . _____ ( data = ____ ): if d [ ___________ ] < ___ : G_________ . ___________ ( _ , _ ) return G_filtered from nams.solutions.io import filter_graph G_filtered = filter_graph ( G , 50 )","title":"Exercise: Filter graph edges"},{"location":"03-practical/01-io/#visualize-using-geoplot","text":"nxviz provides a GeoPlot object that lets you quickly visualize geospatial graph data. A note on geospatial visualizations: As the creator of nxviz , I would recommend using proper geospatial packages to build custom geospatial graph viz, such as pysal .) That said, nxviz can probably do what you need for a quick-and-dirty view of the data. import nxviz as nv c = nv . geo ( G_filtered , node_color_by = \"dpcapacity\" ) /home/runner/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.0 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.6.3, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( Does that look familiar to you? Looks quite a bit like Chicago, I'd say :) Jesting aside, this visualization does help illustrate that the majority of trips occur between stations that are near the city center.","title":"Visualize using GeoPlot"},{"location":"03-practical/01-io/#pickling-graphs","text":"Since NetworkX graphs are Python objects, the canonical way to save them is by pickling them. You can do this using: nx . write_gpickle ( G , file_path ) Here's an example in action: nx . write_gpickle ( G , \"/tmp/divvy.pkl\" ) And just to show that it can be loaded back into memory: G_loaded = nx . read_gpickle ( \"/tmp/divvy.pkl\" )","title":"Pickling Graphs"},{"location":"03-practical/01-io/#exercise-checking-graph-integrity","text":"If you get a graph dataset as a pickle, you should always check it against reference properties to make sure of its data integrity. Write a function that tests that the graph has the correct number of nodes and edges inside it. def test_graph_integrity ( G ): \"\"\"Test integrity of raw Divvy graph.\"\"\" # Your solution here pass from nams.solutions.io import test_graph_integrity test_graph_integrity ( G )","title":"Exercise: checking graph integrity"},{"location":"03-practical/01-io/#other-text-formats","text":"CSV files and pandas DataFrames give us a convenient way to store graph data, and if possible, do insist with your data collaborators that they provide you with graph data that are in this format. If they don't, however, no sweat! After all, Python is super versatile. In this ebook, we have loaded data in from non-CSV sources, sometimes by parsing text files raw, sometimes by treating special characters as delimiters in a CSV-like file, and sometimes by resorting to parsing JSON. You can see other examples of how we load data by browsing through the source file of load_data.py and studying how we construct graph objects.","title":"Other text formats"},{"location":"03-practical/01-io/#solutions","text":"The solutions to this chapter's exercises are below from nams.solutions import io import inspect print ( inspect . getsource ( io )) \"\"\"Solutions to I/O chapter\"\"\" def filter_graph(G, minimum_num_trips): \"\"\" Filter the graph such that only edges that have minimum_num_trips or more are present. \"\"\" G_filtered = G.copy() for u, v, d in G.edges(data=True): if d[\"num_trips\"] < minimum_num_trips: G_filtered.remove_edge(u, v) return G_filtered def test_graph_integrity(G): \"\"\"Test integrity of raw Divvy graph.\"\"\" assert len(G.nodes()) == 300 assert len(G.edges()) == 44422","title":"Solutions"},{"location":"03-practical/02-testing/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Introduction from IPython.display import YouTubeVideo YouTubeVideo ( id = \"SdbKs-crm-g\" , width = \"100%\" ) By this point in the book, you should have observed that we have written a number of tests for our data. Why test? If you like it, put a ring on it... ...and if you rely on it, test it. I am personally a proponent of writing tests for our data because as data scientists, the fields of our data, and their correct values, form the \"data programming interface\" (DPI) much like function signatures form the \"application programming interface\" (API). Since we test the APIs that we rely on, we probably should test the DPIs that we rely on too. What to test When thinking about what part of the data to test, it can be confusing. After all, data are seemingly generated from random processes (my Bayesian foxtail has been revealed), and it seems difficult to test random processes. That said, from my experience handling data, I can suggest a few principles. Test invariants Firstly, we test invariant properties of the data. Put in plain language, things we know ought to be true. Using the Divvy bike dataset example, we know that every node ought to have a station name. Thus, the minimum that we can test is that the station_name attribute is present on every node. As an example: def test_divvy_nodes ( G ): \"\"\"Test node metadata on Divvy dataset.\"\"\" for n , d in G . nodes ( data = True ): assert \"station_name\" in d . keys () Test nullity Secondly, we can test that values that ought not to be null should not be null. Using the Divvy bike dataset example again, if we also know that the station name cannot be null or an empty string, then we can bake that into the test. def test_divvy_nodes ( G ): \"\"\"Test node metadata on Divvy dataset.\"\"\" for n , d in G . nodes ( data = True ): assert \"station_name\" in d . keys () assert bool ( d [ \"station_name\" ]) Test boundaries We can also test boundary values. For example, within the city of Chicago, we know that latitude and longitude values ought to be within the vicinity of 41.85003, -87.65005 . If we get data values that are, say, outside the range of [41, 42]; [-88, -87] , then we know that we have data issues as well. Here's an example: def test_divvy_nodes ( G ): \"\"\"Test node metadata on Divvy dataset.\"\"\" for n , d in G . nodes ( data = True ): # Test for station names. assert \"station_name\" in d . keys () assert bool ( d [ \"station_name\" ]) # Test for longitude/latitude assert d [ \"latitude\" ] >= 41 and d [ \"latitude\" ] <= 42 assert d [ \"longitude\" ] >= - 88 and d [ \"longitude\" ] <= - 87 An apology to geospatial experts: I genuinely don't know the bounding box lat/lon coordinates of Chicago, so if you know those coordinates, please reach out so I can update the test. Continuous data testing The key idea with testing is to have tests that continuously run all the time in the background without you ever needing to intervene to kickstart it off. It's like having a bot in the background always running checks for you so you don't have to kickstart them. To do so, you should be equipped with a few tools. I won't go into them in-depth here, as I will be writing a \"continuous data testing\" essay in the near future. That said, here is the gist. Firstly, use pytest to get set up with testing. You essentially write a test_something.py file in which you write your test suite, and your test functions are all nothinng more than simple functions. # test_data.py def test_divvy_nodes ( G ): \"\"\"Test node metadata on Divvy dataset.\"\"\" for n , d in G . nodes ( data = True ): # Test for station names. assert \"station_name\" in d . keys () assert bool ( d [ \"station_name\" ]) # Test for longitude/latitude assert d [ \"latitude\" ] >= 41 and d [ \"latitude\" ] <= 42 assert d [ \"longitude\" ] >= - 88 and d [ \"longitude\" ] <= - 87 At the command line, if you ran pytest , it will automatically discover all functions prefixed with test_ in all .py files underneath the current working directory. Secondly, set up a continuous pipelining system to continuously run data tests. For example, you can set up Jenkins , Travis , Azure Pipelines , Prefect , and more, depending on what your organization has bought into. Sometimes data tests take longer than software tests, especially if you are pulling dumps from a database, so you might want to run this portion of tests in a separate pipeline instead. Further reading In my essays collection, I wrote about testing data . Itamar Turner-Trauring has written about keeping tests quick and speedy , which is extremely crucial to keeping yourself motivated to write tests.","title":"Chapter 8: Testing"},{"location":"03-practical/02-testing/#introduction","text":"from IPython.display import YouTubeVideo YouTubeVideo ( id = \"SdbKs-crm-g\" , width = \"100%\" ) By this point in the book, you should have observed that we have written a number of tests for our data.","title":"Introduction"},{"location":"03-practical/02-testing/#why-test","text":"","title":"Why test?"},{"location":"03-practical/02-testing/#if-you-like-it-put-a-ring-on-it","text":"...and if you rely on it, test it. I am personally a proponent of writing tests for our data because as data scientists, the fields of our data, and their correct values, form the \"data programming interface\" (DPI) much like function signatures form the \"application programming interface\" (API). Since we test the APIs that we rely on, we probably should test the DPIs that we rely on too.","title":"If you like it, put a ring on it..."},{"location":"03-practical/02-testing/#what-to-test","text":"When thinking about what part of the data to test, it can be confusing. After all, data are seemingly generated from random processes (my Bayesian foxtail has been revealed), and it seems difficult to test random processes. That said, from my experience handling data, I can suggest a few principles.","title":"What to test"},{"location":"03-practical/02-testing/#test-invariants","text":"Firstly, we test invariant properties of the data. Put in plain language, things we know ought to be true. Using the Divvy bike dataset example, we know that every node ought to have a station name. Thus, the minimum that we can test is that the station_name attribute is present on every node. As an example: def test_divvy_nodes ( G ): \"\"\"Test node metadata on Divvy dataset.\"\"\" for n , d in G . nodes ( data = True ): assert \"station_name\" in d . keys ()","title":"Test invariants"},{"location":"03-practical/02-testing/#test-nullity","text":"Secondly, we can test that values that ought not to be null should not be null. Using the Divvy bike dataset example again, if we also know that the station name cannot be null or an empty string, then we can bake that into the test. def test_divvy_nodes ( G ): \"\"\"Test node metadata on Divvy dataset.\"\"\" for n , d in G . nodes ( data = True ): assert \"station_name\" in d . keys () assert bool ( d [ \"station_name\" ])","title":"Test nullity"},{"location":"03-practical/02-testing/#test-boundaries","text":"We can also test boundary values. For example, within the city of Chicago, we know that latitude and longitude values ought to be within the vicinity of 41.85003, -87.65005 . If we get data values that are, say, outside the range of [41, 42]; [-88, -87] , then we know that we have data issues as well. Here's an example: def test_divvy_nodes ( G ): \"\"\"Test node metadata on Divvy dataset.\"\"\" for n , d in G . nodes ( data = True ): # Test for station names. assert \"station_name\" in d . keys () assert bool ( d [ \"station_name\" ]) # Test for longitude/latitude assert d [ \"latitude\" ] >= 41 and d [ \"latitude\" ] <= 42 assert d [ \"longitude\" ] >= - 88 and d [ \"longitude\" ] <= - 87 An apology to geospatial experts: I genuinely don't know the bounding box lat/lon coordinates of Chicago, so if you know those coordinates, please reach out so I can update the test.","title":"Test boundaries"},{"location":"03-practical/02-testing/#continuous-data-testing","text":"The key idea with testing is to have tests that continuously run all the time in the background without you ever needing to intervene to kickstart it off. It's like having a bot in the background always running checks for you so you don't have to kickstart them. To do so, you should be equipped with a few tools. I won't go into them in-depth here, as I will be writing a \"continuous data testing\" essay in the near future. That said, here is the gist. Firstly, use pytest to get set up with testing. You essentially write a test_something.py file in which you write your test suite, and your test functions are all nothinng more than simple functions. # test_data.py def test_divvy_nodes ( G ): \"\"\"Test node metadata on Divvy dataset.\"\"\" for n , d in G . nodes ( data = True ): # Test for station names. assert \"station_name\" in d . keys () assert bool ( d [ \"station_name\" ]) # Test for longitude/latitude assert d [ \"latitude\" ] >= 41 and d [ \"latitude\" ] <= 42 assert d [ \"longitude\" ] >= - 88 and d [ \"longitude\" ] <= - 87 At the command line, if you ran pytest , it will automatically discover all functions prefixed with test_ in all .py files underneath the current working directory. Secondly, set up a continuous pipelining system to continuously run data tests. For example, you can set up Jenkins , Travis , Azure Pipelines , Prefect , and more, depending on what your organization has bought into. Sometimes data tests take longer than software tests, especially if you are pulling dumps from a database, so you might want to run this portion of tests in a separate pipeline instead.","title":"Continuous data testing"},{"location":"03-practical/02-testing/#further-reading","text":"In my essays collection, I wrote about testing data . Itamar Turner-Trauring has written about keeping tests quick and speedy , which is extremely crucial to keeping yourself motivated to write tests.","title":"Further reading"},{"location":"04-advanced/01-bipartite/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); % load_ext autoreload % autoreload 2 % matplotlib inline % config InlineBackend . figure_format = 'retina' Introduction from IPython.display import YouTubeVideo YouTubeVideo ( id = \"BYOK12I9vgI\" , width = \"100%\" ) In this chapter, we will look at bipartite graphs and their applications. What are bipartite graphs? As the name suggests, bipartite have two (bi) node partitions (partite). In other words, we can assign nodes to one of the two partitions. (By contrast, all of the graphs that we have seen before are unipartite : they only have a single partition.) Rules for bipartite graphs With unipartite graphs, you might remember a few rules that apply. Firstly, nodes and edges belong to a set . This means the node set contains only unique members, i.e. no node can be duplicated. The same applies for the edge set. On top of those two basic rules, bipartite graphs add an additional rule: Edges can only occur between nodes of different partitions. In other words, nodes within the same partition are not allowed to be connected to one another. Applications of bipartite graphs Where do we see bipartite graphs being used? Here's one that is very relevant to e-commerce, which touches our daily lives: We can model customer purchases of products using a bipartite graph. Here, the two node sets are customer nodes and product nodes, and edges indicate that a customer C C purchased a product P P . On the basis of this graph, we can do interesting analyses, such as finding customers that are similar to one another on the basis of their shared product purchases. Can you think of other situations where a bipartite graph model can be useful? Dataset Here's another application in crime analysis, which is relevant to the example that we will use in this chapter: This bipartite network contains persons who appeared in at least one crime case as either a suspect, a victim, a witness or both a suspect and victim at the same time. A left node represents a person and a right node represents a crime. An edge between two nodes shows that the left node was involved in the crime represented by the right node. This crime dataset was also sourced from Konect. from nams import load_data as cf G = cf . load_crime_network () for n , d in G . nodes ( data = True ): G . nodes [ n ][ \"degree\" ] = G . degree ( n ) If you inspect the nodes, you will see that they contain a special metadata keyword: bipartite . This is a special keyword that NetworkX can use to identify nodes of a given partition. Visualize the crime network To help us get our bearings right, let's visualize the crime network. import nxviz as nv import matplotlib.pyplot as plt fig , ax = plt . subplots ( figsize = ( 7 , 7 )) nv . circos ( G , sort_by = \"degree\" , group_by = \"bipartite\" , node_color_by = \"bipartite\" , node_aes_kwargs = { \"size_scale\" : 3 }) /home/runner/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.0 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.6.3, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( <AxesSubplot:> Exercise: Extract each node set A useful thing to be able to do is to extract each partition's node set. This will become handy when interacting with NetworkX's bipartite algorithms later on. Write a function that extracts all of the nodes from specified node partition. It should also raise a plain Exception if no nodes exist in that specified partition. (as a precuation against users putting in invalid partition names). import networkx as nx def extract_partition_nodes ( G : nx . Graph , partition : str ): nodeset = [ _ for _ , _ in _______ if ____________ ] if _____________ : raise Exception ( f \"No nodes exist in the partition { partition } !\" ) return nodeset from nams.solutions.bipartite import extract_partition_nodes # Uncomment the next line to see the answer. # extract_partition_nodes?? Bipartite Graph Projections In a bipartite graph, one task that can be useful to do is to calculate the projection of a graph onto one of its nodes. What do we mean by the \"projection of a graph\"? It is best visualized using this figure: from nams.solutions.bipartite import draw_bipartite_graph_example , bipartite_example_graph from nxviz import annotate import matplotlib.pyplot as plt bG = bipartite_example_graph () pG = nx . bipartite . projection . projected_graph ( bG , \"abcd\" ) ax = draw_bipartite_graph_example () plt . sca ( ax [ 0 ]) annotate . parallel_labels ( bG , group_by = \"bipartite\" ) plt . sca ( ax [ 1 ]) annotate . arc_labels ( pG ) As shown in the figure above, we start first with a bipartite graph with two node sets, the \"alphabet\" set and the \"numeric\" set. The projection of this bipartite graph onto the \"alphabet\" node set is a graph that is constructed such that it only contains the \"alphabet\" nodes, and edges join the \"alphabet\" nodes because they share a connection to a \"numeric\" node. The red edge on the right is basically the red path traced on the left. Computing graph projections How does one compute graph projections using NetworkX? Turns out, NetworkX has a bipartite submodule, which gives us all of the facilities that we need to interact with bipartite algorithms. First of all, we need to check that the graph is indeed a bipartite graph. NetworkX provides a function for us to do so: from networkx.algorithms import bipartite bipartite . is_bipartite ( G ) True Now that we've confirmed that the graph is indeed bipartite, we can use the NetworkX bipartite submodule functions to generate the bipartite projection onto one of the node partitions. First off, we need to extract nodes from a particular partition. person_nodes = extract_partition_nodes ( G , \"person\" ) crime_nodes = extract_partition_nodes ( G , \"crime\" ) Next, we can compute the projection: person_graph = bipartite . projected_graph ( G , person_nodes ) crime_graph = bipartite . projected_graph ( G , crime_nodes ) And with that, we have our projected graphs! Go ahead and inspect them: list ( person_graph . edges ( data = True ))[ 0 : 5 ] [('p1', 'p336', {}), ('p1', 'p756', {}), ('p1', 'p93', {}), ('p1', 'p694', {}), ('p2', 'p768', {})] list ( crime_graph . edges ( data = True ))[ 0 : 5 ] [('c1', 'c2', {}), ('c1', 'c4', {}), ('c1', 'c3', {}), ('c2', 'c3', {}), ('c2', 'c4', {})] Now, what is the interpretation of these projected graphs? For person_graph , we have found individuals who are linked by shared participation (whether witness or suspect) in a crime. For crime_graph , we have found crimes that are linked by shared involvement by people. Just by this graph, we already can find out pretty useful information. Let's use an exercise that leverages what you already know to extract useful information from the projected graph. Exercise: find the crime(s) that have the most shared connections with other crimes Find crimes that are most similar to one another on the basis of the number of shared connections to individuals. Hint: This is a degree centrality problem! import pandas as pd def find_most_similar_crimes ( cG : nx . Graph ): \"\"\" Find the crimes that are most similar to other crimes. \"\"\" dcs = ______________ return ___________________ from nams.solutions.bipartite import find_most_similar_crimes find_most_similar_crimes ( crime_graph ) c110 0.136364 c47 0.070909 c23 0.070909 c95 0.063636 c14 0.061818 c352 0.060000 c432 0.060000 c160 0.058182 c417 0.058182 c525 0.058182 dtype: float64 Exercise: find the individual(s) that have the most shared connections with other individuals Now do the analogous thing for individuals! def find_most_similar_people ( pG : nx . Graph ): \"\"\" Find the persons that are most similar to other persons. \"\"\" dcs = ______________ return ___________________ from nams.solutions.bipartite import find_most_similar_people find_most_similar_people ( person_graph ) p425 0.061594 p2 0.057971 p356 0.053140 p56 0.039855 p695 0.039855 p497 0.036232 p715 0.035024 p10 0.033816 p815 0.032609 p74 0.030193 dtype: float64 Weighted Projection Though we were able to find out which graphs were connected with one another, we did not record in the resulting projected graph the strength by which the two nodes were connected. To preserve this information, we need another function: weighted_person_graph = bipartite . weighted_projected_graph ( G , person_nodes ) list ( weighted_person_graph . edges ( data = True ))[ 0 : 5 ] [('p1', 'p336', {'weight': 1}), ('p1', 'p756', {'weight': 1}), ('p1', 'p93', {'weight': 1}), ('p1', 'p694', {'weight': 1}), ('p2', 'p287', {'weight': 1})] Exercise: Find the people that can help with investigating a crime 's person . Let's pretend that we are a detective trying to solve a crime, and that we right now need to find other individuals who were not implicated in the same exact crime as an individual was, but who might be able to give us information about that individual because they were implicated in other crimes with that individual. Implement a function that takes in a bipartite graph G , a string person and a string crime , and returns a list of other person s that were not implicated in the crime , but were connected to the person via other crimes. It should return a ranked list , based on the number of shared crimes (from highest to lowest) because the ranking will help with triage. list ( G . neighbors ( 'p1' )) ['c1', 'c2', 'c3', 'c4'] def find_connected_persons ( G , person , crime ): # Step 0: Check that the given \"person\" and \"crime\" are connected. if _____________________________ : raise ValueError ( f \"Graph does not have a connection between { person } and { crime } !\" ) # Step 1: calculate weighted projection for person nodes. person_nodes = ____________________________________ person_graph = bipartite . ________________________ ( _ , ____________ ) # Step 2: Find neighbors of the given `person` node in projected graph. candidate_neighbors = ___________________________________ # Step 3: Remove candidate neighbors from the set if they are implicated in the given crime. for p in G . neighbors ( crime ): if ________________________ : _____________________________ # Step 4: Rank-order the candidate neighbors by number of shared connections. _________ = [] ## You might need a for-loop here return pd . DataFrame ( __________ ) . sort_values ( \"________\" , ascending = False ) from nams.solutions.bipartite import find_connected_persons find_connected_persons ( G , 'p2' , 'c10' ) node weight 38 p67 4 25 p338 2 45 p356 2 9 p361 2 34 p5 1 26 p495 1 27 p820 1 28 p563 1 29 p499 1 30 p223 1 31 p773 1 32 p4 1 33 p782 1 0 p287 1 35 p401 1 24 p603 1 37 p320 1 39 p211 1 40 p300 1 41 p661 1 42 p449 1 43 p286 1 44 p690 1 36 p90 1 23 p439 1 1 p768 1 22 p710 1 2 p660 1 3 p498 1 4 p578 1 5 p48 1 6 p528 1 7 p304 1 8 p305 1 10 p39 1 11 p620 1 12 p360 1 13 p781 1 14 p665 1 15 p608 1 16 p309 1 17 p806 1 18 p186 1 19 p587 1 20 p716 1 21 p475 1 46 p471 1 Degree Centrality The degree centrality metric is something we can calculate for bipartite graphs. Recall that the degree centrality metric is the number of neighbors of a node divided by the total number of possible neighbors. In a unipartite graph, the denominator can be the total number of nodes less one (if self-loops are not allowed) or simply the total number of nodes (if self loops are allowed). Exercise: What is the denominator for bipartite graphs? Think about it for a moment, then write down your answer. from nams.solutions.bipartite import bipartite_degree_centrality_denominator from nams.functions import render_html render_html ( bipartite_degree_centrality_denominator ()) The total number of neighbors that a node can possibly have is the number of nodes in the other partition. This comes naturally from the definition of a bipartite graph, where nodes can only be connected to nodes in the other partition. Exercise: Which persons are implicated in the most number of crimes? Find the persons (singular or plural) who are connected to the most number of crimes. To do so, you will need to use nx.bipartite.degree_centrality , rather than the regular nx.degree_centrality function. nx.bipartite.degree_centrality requires that you pass in a node set from one of the partitions so that it can correctly partition nodes on the other set. What is returned, though, is the degree centrality for nodes in both sets. Here is an example to show you how the function is used: dcs = nx . bipartite . degree_centrality ( my_graph , nodes_from_one_partition ) def find_most_crime_person ( G , person_nodes ): dcs = __________________________ return ___________________________ from nams.solutions.bipartite import find_most_crime_person find_most_crime_person ( G , person_nodes ) 'p815' Solutions Here are the solutions to the exercises above. from nams.solutions import bipartite import inspect print ( inspect . getsource ( bipartite )) import networkx as nx import pandas as pd from nams.functions import render_html def extract_partition_nodes(G: nx.Graph, partition: str): nodeset = [n for n, d in G.nodes(data=True) if d[\"bipartite\"] == partition] if len(nodeset) == 0: raise Exception(f\"No nodes exist in the partition {partition}!\") return nodeset def bipartite_example_graph(): bG = nx.Graph() bG.add_nodes_from(\"abcd\", bipartite=\"letters\") bG.add_nodes_from(range(1, 4), bipartite=\"numbers\") bG.add_edges_from([(\"a\", 1), (\"b\", 1), (\"b\", 3), (\"c\", 2), (\"c\", 3), (\"d\", 1)]) return bG def draw_bipartite_graph_example(): \"\"\"Draw an example bipartite graph and its corresponding projection.\"\"\" import matplotlib.pyplot as plt import nxviz as nv from nxviz import annotate, plots, highlights fig, ax = plt.subplots(nrows=1, ncols=2, figsize=(8, 4)) plt.sca(ax[0]) bG = bipartite_example_graph() nv.parallel(bG, group_by=\"bipartite\", node_color_by=\"bipartite\") annotate.parallel_group(bG, group_by=\"bipartite\", y_offset=-0.5) highlights.parallel_edge(bG, \"a\", 1, group_by=\"bipartite\") highlights.parallel_edge(bG, \"b\", 1, group_by=\"bipartite\") pG = nx.bipartite.projected_graph(bG, nodes=list(\"abcd\")) plt.sca(ax[1]) nv.arc(pG) highlights.arc_edge(pG, \"a\", \"b\") return ax def find_most_similar_crimes(cG: nx.Graph): \"\"\" Find the crimes that are most similar to other crimes. \"\"\" dcs = pd.Series(nx.degree_centrality(cG)) return dcs.sort_values(ascending=False).head(10) def find_most_similar_people(pG: nx.Graph): \"\"\" Find the persons that are most similar to other persons. \"\"\" dcs = pd.Series(nx.degree_centrality(pG)) return dcs.sort_values(ascending=False).head(10) def find_connected_persons(G, person, crime): \"\"\"Answer to exercise on people implicated in crimes\"\"\" # Step 0: Check that the given \"person\" and \"crime\" are connected. if not G.has_edge(person, crime): raise ValueError( f\"Graph does not have a connection between {person} and {crime}!\" ) # Step 1: calculate weighted projection for person nodes. person_nodes = extract_partition_nodes(G, \"person\") person_graph = nx.bipartite.weighted_projected_graph(G, person_nodes) # Step 2: Find neighbors of the given `person` node in projected graph. candidate_neighbors = set(person_graph.neighbors(person)) # Step 3: Remove candidate neighbors from the set if they are implicated in the given crime. for p in G.neighbors(crime): if p in candidate_neighbors: candidate_neighbors.remove(p) # Step 4: Rank-order the candidate neighbors by number of shared connections. data = [] for nbr in candidate_neighbors: data.append(dict(node=nbr, weight=person_graph.edges[person, nbr][\"weight\"])) return pd.DataFrame(data).sort_values(\"weight\", ascending=False) def bipartite_degree_centrality_denominator(): \"\"\"Answer to bipartite graph denominator for degree centrality.\"\"\" ans = \"\"\" The total number of neighbors that a node can _possibly_ have is the number of nodes in the other partition. This comes naturally from the definition of a bipartite graph, where nodes can _only_ be connected to nodes in the other partition. \"\"\" return ans def find_most_crime_person(G, person_nodes): dcs = ( pd.Series(nx.bipartite.degree_centrality(G, person_nodes)) .sort_values(ascending=False) .to_frame() ) return dcs.reset_index().query(\"index.str.contains('p')\").iloc[0][\"index\"]","title":"Chapter 9: Bipartite Graphs"},{"location":"04-advanced/01-bipartite/#introduction","text":"from IPython.display import YouTubeVideo YouTubeVideo ( id = \"BYOK12I9vgI\" , width = \"100%\" ) In this chapter, we will look at bipartite graphs and their applications.","title":"Introduction"},{"location":"04-advanced/01-bipartite/#what-are-bipartite-graphs","text":"As the name suggests, bipartite have two (bi) node partitions (partite). In other words, we can assign nodes to one of the two partitions. (By contrast, all of the graphs that we have seen before are unipartite : they only have a single partition.)","title":"What are bipartite graphs?"},{"location":"04-advanced/01-bipartite/#rules-for-bipartite-graphs","text":"With unipartite graphs, you might remember a few rules that apply. Firstly, nodes and edges belong to a set . This means the node set contains only unique members, i.e. no node can be duplicated. The same applies for the edge set. On top of those two basic rules, bipartite graphs add an additional rule: Edges can only occur between nodes of different partitions. In other words, nodes within the same partition are not allowed to be connected to one another.","title":"Rules for bipartite graphs"},{"location":"04-advanced/01-bipartite/#applications-of-bipartite-graphs","text":"Where do we see bipartite graphs being used? Here's one that is very relevant to e-commerce, which touches our daily lives: We can model customer purchases of products using a bipartite graph. Here, the two node sets are customer nodes and product nodes, and edges indicate that a customer C C purchased a product P P . On the basis of this graph, we can do interesting analyses, such as finding customers that are similar to one another on the basis of their shared product purchases. Can you think of other situations where a bipartite graph model can be useful?","title":"Applications of bipartite graphs"},{"location":"04-advanced/01-bipartite/#dataset","text":"Here's another application in crime analysis, which is relevant to the example that we will use in this chapter: This bipartite network contains persons who appeared in at least one crime case as either a suspect, a victim, a witness or both a suspect and victim at the same time. A left node represents a person and a right node represents a crime. An edge between two nodes shows that the left node was involved in the crime represented by the right node. This crime dataset was also sourced from Konect. from nams import load_data as cf G = cf . load_crime_network () for n , d in G . nodes ( data = True ): G . nodes [ n ][ \"degree\" ] = G . degree ( n ) If you inspect the nodes, you will see that they contain a special metadata keyword: bipartite . This is a special keyword that NetworkX can use to identify nodes of a given partition.","title":"Dataset"},{"location":"04-advanced/01-bipartite/#visualize-the-crime-network","text":"To help us get our bearings right, let's visualize the crime network. import nxviz as nv import matplotlib.pyplot as plt fig , ax = plt . subplots ( figsize = ( 7 , 7 )) nv . circos ( G , sort_by = \"degree\" , group_by = \"bipartite\" , node_color_by = \"bipartite\" , node_aes_kwargs = { \"size_scale\" : 3 }) /home/runner/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.0 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.6.3, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( <AxesSubplot:>","title":"Visualize the crime network"},{"location":"04-advanced/01-bipartite/#exercise-extract-each-node-set","text":"A useful thing to be able to do is to extract each partition's node set. This will become handy when interacting with NetworkX's bipartite algorithms later on. Write a function that extracts all of the nodes from specified node partition. It should also raise a plain Exception if no nodes exist in that specified partition. (as a precuation against users putting in invalid partition names). import networkx as nx def extract_partition_nodes ( G : nx . Graph , partition : str ): nodeset = [ _ for _ , _ in _______ if ____________ ] if _____________ : raise Exception ( f \"No nodes exist in the partition { partition } !\" ) return nodeset from nams.solutions.bipartite import extract_partition_nodes # Uncomment the next line to see the answer. # extract_partition_nodes??","title":"Exercise: Extract each node set"},{"location":"04-advanced/01-bipartite/#bipartite-graph-projections","text":"In a bipartite graph, one task that can be useful to do is to calculate the projection of a graph onto one of its nodes. What do we mean by the \"projection of a graph\"? It is best visualized using this figure: from nams.solutions.bipartite import draw_bipartite_graph_example , bipartite_example_graph from nxviz import annotate import matplotlib.pyplot as plt bG = bipartite_example_graph () pG = nx . bipartite . projection . projected_graph ( bG , \"abcd\" ) ax = draw_bipartite_graph_example () plt . sca ( ax [ 0 ]) annotate . parallel_labels ( bG , group_by = \"bipartite\" ) plt . sca ( ax [ 1 ]) annotate . arc_labels ( pG ) As shown in the figure above, we start first with a bipartite graph with two node sets, the \"alphabet\" set and the \"numeric\" set. The projection of this bipartite graph onto the \"alphabet\" node set is a graph that is constructed such that it only contains the \"alphabet\" nodes, and edges join the \"alphabet\" nodes because they share a connection to a \"numeric\" node. The red edge on the right is basically the red path traced on the left.","title":"Bipartite Graph Projections"},{"location":"04-advanced/01-bipartite/#computing-graph-projections","text":"How does one compute graph projections using NetworkX? Turns out, NetworkX has a bipartite submodule, which gives us all of the facilities that we need to interact with bipartite algorithms. First of all, we need to check that the graph is indeed a bipartite graph. NetworkX provides a function for us to do so: from networkx.algorithms import bipartite bipartite . is_bipartite ( G ) True Now that we've confirmed that the graph is indeed bipartite, we can use the NetworkX bipartite submodule functions to generate the bipartite projection onto one of the node partitions. First off, we need to extract nodes from a particular partition. person_nodes = extract_partition_nodes ( G , \"person\" ) crime_nodes = extract_partition_nodes ( G , \"crime\" ) Next, we can compute the projection: person_graph = bipartite . projected_graph ( G , person_nodes ) crime_graph = bipartite . projected_graph ( G , crime_nodes ) And with that, we have our projected graphs! Go ahead and inspect them: list ( person_graph . edges ( data = True ))[ 0 : 5 ] [('p1', 'p336', {}), ('p1', 'p756', {}), ('p1', 'p93', {}), ('p1', 'p694', {}), ('p2', 'p768', {})] list ( crime_graph . edges ( data = True ))[ 0 : 5 ] [('c1', 'c2', {}), ('c1', 'c4', {}), ('c1', 'c3', {}), ('c2', 'c3', {}), ('c2', 'c4', {})] Now, what is the interpretation of these projected graphs? For person_graph , we have found individuals who are linked by shared participation (whether witness or suspect) in a crime. For crime_graph , we have found crimes that are linked by shared involvement by people. Just by this graph, we already can find out pretty useful information. Let's use an exercise that leverages what you already know to extract useful information from the projected graph.","title":"Computing graph projections"},{"location":"04-advanced/01-bipartite/#exercise-find-the-crimes-that-have-the-most-shared-connections-with-other-crimes","text":"Find crimes that are most similar to one another on the basis of the number of shared connections to individuals. Hint: This is a degree centrality problem! import pandas as pd def find_most_similar_crimes ( cG : nx . Graph ): \"\"\" Find the crimes that are most similar to other crimes. \"\"\" dcs = ______________ return ___________________ from nams.solutions.bipartite import find_most_similar_crimes find_most_similar_crimes ( crime_graph ) c110 0.136364 c47 0.070909 c23 0.070909 c95 0.063636 c14 0.061818 c352 0.060000 c432 0.060000 c160 0.058182 c417 0.058182 c525 0.058182 dtype: float64","title":"Exercise: find the crime(s) that have the most shared connections with other crimes"},{"location":"04-advanced/01-bipartite/#exercise-find-the-individuals-that-have-the-most-shared-connections-with-other-individuals","text":"Now do the analogous thing for individuals! def find_most_similar_people ( pG : nx . Graph ): \"\"\" Find the persons that are most similar to other persons. \"\"\" dcs = ______________ return ___________________ from nams.solutions.bipartite import find_most_similar_people find_most_similar_people ( person_graph ) p425 0.061594 p2 0.057971 p356 0.053140 p56 0.039855 p695 0.039855 p497 0.036232 p715 0.035024 p10 0.033816 p815 0.032609 p74 0.030193 dtype: float64","title":"Exercise: find the individual(s) that have the most shared connections with other individuals"},{"location":"04-advanced/01-bipartite/#weighted-projection","text":"Though we were able to find out which graphs were connected with one another, we did not record in the resulting projected graph the strength by which the two nodes were connected. To preserve this information, we need another function: weighted_person_graph = bipartite . weighted_projected_graph ( G , person_nodes ) list ( weighted_person_graph . edges ( data = True ))[ 0 : 5 ] [('p1', 'p336', {'weight': 1}), ('p1', 'p756', {'weight': 1}), ('p1', 'p93', {'weight': 1}), ('p1', 'p694', {'weight': 1}), ('p2', 'p287', {'weight': 1})]","title":"Weighted Projection"},{"location":"04-advanced/01-bipartite/#exercise-find-the-people-that-can-help-with-investigating-a-crimes-person","text":"Let's pretend that we are a detective trying to solve a crime, and that we right now need to find other individuals who were not implicated in the same exact crime as an individual was, but who might be able to give us information about that individual because they were implicated in other crimes with that individual. Implement a function that takes in a bipartite graph G , a string person and a string crime , and returns a list of other person s that were not implicated in the crime , but were connected to the person via other crimes. It should return a ranked list , based on the number of shared crimes (from highest to lowest) because the ranking will help with triage. list ( G . neighbors ( 'p1' )) ['c1', 'c2', 'c3', 'c4'] def find_connected_persons ( G , person , crime ): # Step 0: Check that the given \"person\" and \"crime\" are connected. if _____________________________ : raise ValueError ( f \"Graph does not have a connection between { person } and { crime } !\" ) # Step 1: calculate weighted projection for person nodes. person_nodes = ____________________________________ person_graph = bipartite . ________________________ ( _ , ____________ ) # Step 2: Find neighbors of the given `person` node in projected graph. candidate_neighbors = ___________________________________ # Step 3: Remove candidate neighbors from the set if they are implicated in the given crime. for p in G . neighbors ( crime ): if ________________________ : _____________________________ # Step 4: Rank-order the candidate neighbors by number of shared connections. _________ = [] ## You might need a for-loop here return pd . DataFrame ( __________ ) . sort_values ( \"________\" , ascending = False ) from nams.solutions.bipartite import find_connected_persons find_connected_persons ( G , 'p2' , 'c10' ) node weight 38 p67 4 25 p338 2 45 p356 2 9 p361 2 34 p5 1 26 p495 1 27 p820 1 28 p563 1 29 p499 1 30 p223 1 31 p773 1 32 p4 1 33 p782 1 0 p287 1 35 p401 1 24 p603 1 37 p320 1 39 p211 1 40 p300 1 41 p661 1 42 p449 1 43 p286 1 44 p690 1 36 p90 1 23 p439 1 1 p768 1 22 p710 1 2 p660 1 3 p498 1 4 p578 1 5 p48 1 6 p528 1 7 p304 1 8 p305 1 10 p39 1 11 p620 1 12 p360 1 13 p781 1 14 p665 1 15 p608 1 16 p309 1 17 p806 1 18 p186 1 19 p587 1 20 p716 1 21 p475 1 46 p471 1","title":"Exercise: Find the people that can help with investigating a crime's person."},{"location":"04-advanced/01-bipartite/#degree-centrality","text":"The degree centrality metric is something we can calculate for bipartite graphs. Recall that the degree centrality metric is the number of neighbors of a node divided by the total number of possible neighbors. In a unipartite graph, the denominator can be the total number of nodes less one (if self-loops are not allowed) or simply the total number of nodes (if self loops are allowed).","title":"Degree Centrality"},{"location":"04-advanced/01-bipartite/#exercise-what-is-the-denominator-for-bipartite-graphs","text":"Think about it for a moment, then write down your answer. from nams.solutions.bipartite import bipartite_degree_centrality_denominator from nams.functions import render_html render_html ( bipartite_degree_centrality_denominator ()) The total number of neighbors that a node can possibly have is the number of nodes in the other partition. This comes naturally from the definition of a bipartite graph, where nodes can only be connected to nodes in the other partition.","title":"Exercise: What is the denominator for bipartite graphs?"},{"location":"04-advanced/01-bipartite/#exercise-which-persons-are-implicated-in-the-most-number-of-crimes","text":"Find the persons (singular or plural) who are connected to the most number of crimes. To do so, you will need to use nx.bipartite.degree_centrality , rather than the regular nx.degree_centrality function. nx.bipartite.degree_centrality requires that you pass in a node set from one of the partitions so that it can correctly partition nodes on the other set. What is returned, though, is the degree centrality for nodes in both sets. Here is an example to show you how the function is used: dcs = nx . bipartite . degree_centrality ( my_graph , nodes_from_one_partition ) def find_most_crime_person ( G , person_nodes ): dcs = __________________________ return ___________________________ from nams.solutions.bipartite import find_most_crime_person find_most_crime_person ( G , person_nodes ) 'p815'","title":"Exercise: Which persons are implicated in the most number of crimes?"},{"location":"04-advanced/01-bipartite/#solutions","text":"Here are the solutions to the exercises above. from nams.solutions import bipartite import inspect print ( inspect . getsource ( bipartite )) import networkx as nx import pandas as pd from nams.functions import render_html def extract_partition_nodes(G: nx.Graph, partition: str): nodeset = [n for n, d in G.nodes(data=True) if d[\"bipartite\"] == partition] if len(nodeset) == 0: raise Exception(f\"No nodes exist in the partition {partition}!\") return nodeset def bipartite_example_graph(): bG = nx.Graph() bG.add_nodes_from(\"abcd\", bipartite=\"letters\") bG.add_nodes_from(range(1, 4), bipartite=\"numbers\") bG.add_edges_from([(\"a\", 1), (\"b\", 1), (\"b\", 3), (\"c\", 2), (\"c\", 3), (\"d\", 1)]) return bG def draw_bipartite_graph_example(): \"\"\"Draw an example bipartite graph and its corresponding projection.\"\"\" import matplotlib.pyplot as plt import nxviz as nv from nxviz import annotate, plots, highlights fig, ax = plt.subplots(nrows=1, ncols=2, figsize=(8, 4)) plt.sca(ax[0]) bG = bipartite_example_graph() nv.parallel(bG, group_by=\"bipartite\", node_color_by=\"bipartite\") annotate.parallel_group(bG, group_by=\"bipartite\", y_offset=-0.5) highlights.parallel_edge(bG, \"a\", 1, group_by=\"bipartite\") highlights.parallel_edge(bG, \"b\", 1, group_by=\"bipartite\") pG = nx.bipartite.projected_graph(bG, nodes=list(\"abcd\")) plt.sca(ax[1]) nv.arc(pG) highlights.arc_edge(pG, \"a\", \"b\") return ax def find_most_similar_crimes(cG: nx.Graph): \"\"\" Find the crimes that are most similar to other crimes. \"\"\" dcs = pd.Series(nx.degree_centrality(cG)) return dcs.sort_values(ascending=False).head(10) def find_most_similar_people(pG: nx.Graph): \"\"\" Find the persons that are most similar to other persons. \"\"\" dcs = pd.Series(nx.degree_centrality(pG)) return dcs.sort_values(ascending=False).head(10) def find_connected_persons(G, person, crime): \"\"\"Answer to exercise on people implicated in crimes\"\"\" # Step 0: Check that the given \"person\" and \"crime\" are connected. if not G.has_edge(person, crime): raise ValueError( f\"Graph does not have a connection between {person} and {crime}!\" ) # Step 1: calculate weighted projection for person nodes. person_nodes = extract_partition_nodes(G, \"person\") person_graph = nx.bipartite.weighted_projected_graph(G, person_nodes) # Step 2: Find neighbors of the given `person` node in projected graph. candidate_neighbors = set(person_graph.neighbors(person)) # Step 3: Remove candidate neighbors from the set if they are implicated in the given crime. for p in G.neighbors(crime): if p in candidate_neighbors: candidate_neighbors.remove(p) # Step 4: Rank-order the candidate neighbors by number of shared connections. data = [] for nbr in candidate_neighbors: data.append(dict(node=nbr, weight=person_graph.edges[person, nbr][\"weight\"])) return pd.DataFrame(data).sort_values(\"weight\", ascending=False) def bipartite_degree_centrality_denominator(): \"\"\"Answer to bipartite graph denominator for degree centrality.\"\"\" ans = \"\"\" The total number of neighbors that a node can _possibly_ have is the number of nodes in the other partition. This comes naturally from the definition of a bipartite graph, where nodes can _only_ be connected to nodes in the other partition. \"\"\" return ans def find_most_crime_person(G, person_nodes): dcs = ( pd.Series(nx.bipartite.degree_centrality(G, person_nodes)) .sort_values(ascending=False) .to_frame() ) return dcs.reset_index().query(\"index.str.contains('p')\").iloc[0][\"index\"]","title":"Solutions"},{"location":"04-advanced/02-linalg/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); % load_ext autoreload % autoreload 2 % matplotlib inline % config InlineBackend . figure_format = 'retina' Introduction from IPython.display import YouTubeVideo YouTubeVideo ( id = \"uTHihJiRELc\" , width = \"100%\" ) In this chapter, we will look at the relationship between graphs and linear algebra. The deep connection between these two topics is super interesting, and I'd like to show it to you through an exploration of three topics: Path finding Message passing Bipartite projections Preliminaries Before we go deep into the linear algebra piece though, we have to first make sure some ideas are clear. The most important thing that we need when treating graphs in linear algebra form is the adjacency matrix . For example, for four nodes joined in a chain: import networkx as nx nodes = list ( range ( 4 )) G1 = nx . Graph () G1 . add_nodes_from ( nodes ) G1 . add_edges_from ( zip ( nodes , nodes [ 1 :])) we can visualize the graph: nx . draw ( G1 , with_labels = True ) and we can visualize its adjacency matrix: import nxviz as nv m = nv . matrix ( G1 ) /home/runner/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.0 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.6.3, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( and we can obtain the adjacency matrix as a NumPy array: A1 = nx . to_numpy_array ( G1 , nodelist = sorted ( G1 . nodes ())) A1 array([[0., 1., 0., 0.], [1., 0., 1., 0.], [0., 1., 0., 1.], [0., 0., 1., 0.]]) Symmetry Remember that for an undirected graph, the adjacency matrix will be symmetric about the diagonal, while for a directed graph, the adjacency matrix will be asymmetric . Path finding In the Paths chapter, we can use the breadth-first search algorithm to find a shortest path between any two nodes . As it turns out, using adjacency matrices, we can answer a related question, which is how many paths exist of length K between two nodes . To see how, we need to see the relationship between matrix powers and graph path lengths. Let's take the adjacency matrix above, raise it to the second power, and see what it tells us. import numpy as np np . linalg . matrix_power ( A1 , 2 ) array([[1., 0., 1., 0.], [0., 2., 0., 1.], [1., 0., 2., 0.], [0., 1., 0., 1.]]) Exercise: adjacency matrix power? What do you think the values in the adjacency matrix are related to? If studying in a group, discuss with your neighbors; if working on this alone, write down your thoughts. from nams.solutions.linalg import adjacency_matrix_power from nams.functions import render_html render_html ( adjacency_matrix_power ()) The diagonals equal to the degree of each node. The off-diagonals also contain values, which correspond to the number of paths that exist of length 2 between the node on the row axis and the node on the column axis. In fact, the diagonal also takes on the same meaning! For the terminal nodes, there is only 1 path from itself back to itself, while for the middle nodes, there are 2 paths from itself back to itself! Higher matrix powers The semantic meaning of adjacency matrix powers is preserved even if we go to higher powers. For example, if we go to the 3rd matrix power: np . linalg . matrix_power ( A1 , 3 ) array([[0., 2., 0., 1.], [2., 0., 3., 0.], [0., 3., 0., 2.], [1., 0., 2., 0.]]) You should be able to convince yourself that: There's no way to go from a node back to itself in 3 steps, thus explaining the diagonals, and The off-diagonals take on the correct values when you think about them in terms of \"ways to go from one node to another\". With directed graphs? Does the \"number of steps\" interpretation hold with directed graphs? Yes it does! Let's see it in action. G2 = nx . DiGraph () G2 . add_nodes_from ( nodes ) G2 . add_edges_from ( zip ( nodes , nodes [ 1 :])) nx . draw ( G2 , with_labels = True ) Exercise: directed graph matrix power Convince yourself that the resulting adjacency matrix power contains the same semantic meaning as that for an undirected graph, that is, the number of ways to go from \"row\" node to \"column\" node in K steps . (I have provided three different matrix powers for you.) A2 = nx . to_numpy_array ( G2 ) np . linalg . matrix_power ( A2 , 2 ) array([[0., 0., 1., 0.], [0., 0., 0., 1.], [0., 0., 0., 0.], [0., 0., 0., 0.]]) np . linalg . matrix_power ( A2 , 3 ) array([[0., 0., 0., 1.], [0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]]) np . linalg . matrix_power ( A2 , 4 ) array([[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]]) Message Passing Let's now dive into the second topic here, that of message passing. To show how message passing works on a graph, let's start with the directed linear chain, as this will make things easier to understand. \"Message\" representation in matrix form Our graph adjacency matrix contains nodes ordered in a particular fashion along the rows and columns. We can also create a \"message\" matrix M M , using the same ordering of nodes along the rows, with columns instead representing a \"message\" that is intended to be \"passed\" from one node to another: M = np . array ([ 1 , 0 , 0 , 0 ]) M array([1, 0, 0, 0]) Notice where the position of the value 1 is - at the first node. If we take M and matrix multiply it against A2, let's see what we get: M @ A2 array([0., 1., 0., 0.]) The message has been passed onto the next node! And if we pass the message one more time: M @ A2 @ A2 array([0., 0., 1., 0.]) Now, the message lies on the 3rd node! We can make an animation to visualize this more clearly. There are comments in the code to explain what's going on! def propagate ( G , msg , n_frames ): \"\"\" Computes the node values based on propagation. Intended to be used before or when being passed into the anim() function (defined below). :param G: A NetworkX Graph. :param msg: The initial state of the message. :returns: A list of 1/0 representing message status at each node. \"\"\" # Initialize a list to store message states at each timestep. msg_states = [] # Set a variable `new_msg` to be the initial message state. new_msg = msg # Get the adjacency matrix of the graph G. A = nx . to_numpy_array ( G ) # Perform message passing at each time step for i in range ( n_frames ): msg_states . append ( new_msg ) new_msg = new_msg @ A # Return the message states. return msg_states from IPython.display import HTML import matplotlib.pyplot as plt from matplotlib import animation def update_func ( step , nodes , colors ): \"\"\" The update function for each animation time step. :param step: Passed in from matplotlib's FuncAnimation. Must be present in the function signature. :param nodes: Returned from nx.draw_networkx_edges(). Is an array of colors. :param colors: A list of pre-computed colors. \"\"\" nodes . set_array ( colors [ step ] . ravel ()) return nodes def anim ( G , initial_state , n_frames = 4 ): \"\"\" Animation function! \"\"\" # First, pre-compute the message passing states over all frames. colors = propagate ( G , initial_state , n_frames ) # Instantiate a figure fig = plt . figure () # Precompute node positions so that they stay fixed over the entire animation pos = nx . kamada_kawai_layout ( G ) # Draw nodes to screen nodes = nx . draw_networkx_nodes ( G , pos = pos , node_color = colors [ 0 ] . ravel (), node_size = 20 ) # Draw edges to screen ax = nx . draw_networkx_edges ( G , pos ) # Finally, return the animation through matplotlib. return animation . FuncAnimation ( fig , update_func , frames = range ( n_frames ), fargs = ( nodes , colors )) # Initialize the message msg = np . zeros ( len ( G2 )) msg [ 0 ] = 1 # Animate the graph with message propagation. HTML ( anim ( G2 , msg , n_frames = 4 ) . to_html5_video ()) Your browser does not support the video tag. Bipartite Graphs & Matrices The section on message passing above assumed unipartite graphs, or at least graphs for which messages can be meaningfully passed between nodes. In this section, we will look at bipartite graphs. Recall from before the definition of a bipartite graph: Nodes are separated into two partitions (hence 'bi'-'partite'). Edges can only occur between nodes of different partitions. Bipartite graphs have a natural matrix representation, known as the biadjacency matrix . Nodes on one partition are the rows, and nodes on the other partition are the columns. NetworkX's bipartite module provides a function for computing the biadjacency matrix of a bipartite graph. Let's start by looking at a toy bipartite graph, a \"customer-product\" purchase record graph, with 4 products and 3 customers. The matrix representation might be as follows: # Rows = customers, columns = products, 1 = customer purchased product, 0 = customer did not purchase product. cp_mat = np . array ([[ 0 , 1 , 0 , 0 ], [ 1 , 0 , 1 , 0 ], [ 1 , 1 , 1 , 1 ]]) From this \"bi-adjacency\" matrix, one can compute the projection onto the customers, matrix multiplying the matrix with its transpose. c_mat = cp_mat @ cp_mat . T # c_mat means \"customer matrix\" c_mat array([[1, 0, 1], [0, 2, 2], [1, 2, 4]]) What we get is the connectivity matrix of the customers, based on shared purchases. The diagonals are the degree of the customers in the original graph, i.e. the number of purchases they originally made, and the off-diagonals are the connectivity matrix, based on shared products. To get the products matrix, we make the transposed matrix the left side of the matrix multiplication. p_mat = cp_mat . T @ cp_mat # p_mat means \"product matrix\" p_mat array([[2, 1, 2, 1], [1, 2, 1, 1], [2, 1, 2, 1], [1, 1, 1, 1]]) You may now try to convince yourself that the diagonals are the number of times a customer purchased that product, and the off-diagonals are the connectivity matrix of the products, weighted by how similar two customers are. Exercises In the following exercises, you will now play with a customer-product graph from Amazon. This dataset was downloaded from UCSD's Julian McAuley's website , and corresponds to the digital music dataset. This is a bipartite graph. The two partitions are: customers : The customers that were doing the reviews. products : The music that was being reviewed. In the original dataset (see the original JSON in the datasets/ directory), they are referred to as: customers : reviewerID products : asin from nams import load_data as cf G_amzn = cf . load_amazon_reviews () 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 64706/64706 [00:00<00:00, 78113.58it/s] 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 64706/64706 [00:00<00:00, 464512.67it/s] 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 64706/64706 [00:00<00:00, 437161.15it/s] Remember that with bipartite graphs, it is useful to obtain nodes from one of the partitions. from nams.solutions.bipartite import extract_partition_nodes customer_nodes = extract_partition_nodes ( G_amzn , \"customer\" ) mat = nx . bipartite . biadjacency_matrix ( G_amzn , row_order = customer_nodes ) You'll notice that this matrix is extremely large! There are 5541 customers and 3568 products, for a total matrix size of 5541 \\times 3568 = 19770288 5541 \\times 3568 = 19770288 , but it is stored in a sparse format because only 64706 elements are filled in. mat <5541x3568 sparse matrix of type '<class 'numpy.int64'>' with 64706 stored elements in Compressed Sparse Row format> Example: finding customers who reviewed the most number of music items. Let's find out which customers reviewed the most number of music items. To do so, you can break the problem into a few steps. First off, we compute the customer projection using matrix operations. customer_mat = mat @ mat . T Next, get the diagonals of the customer-customer matrix. Recall here that in customer_mat , the diagonals correspond to the degree of the customer nodes in the bipartite matrix. SciPy sparse matrices provide a .diagonal() method that returns the diagonal elements. # Get the diagonal. degrees = customer_mat . diagonal () Finally, find the index of the customer that has the highest degree. cust_idx = np . argmax ( degrees ) cust_idx 294 We can verify this independently by sorting the customer nodes by degree. import pandas as pd import janitor # There's some pandas-fu we need to use to get this correct. deg = ( pd . Series ( dict ( nx . degree ( G_amzn , customer_nodes ))) . to_frame () . reset_index () . rename_column ( \"index\" , \"customer\" ) . rename_column ( 0 , \"num_reviews\" ) . sort_values ( 'num_reviews' , ascending = False ) ) deg . head () customer num_reviews 294 A9Q28YTLYREO7 578 86 A3HU0B9XUEVHIM 375 77 A3KJ6JAZPH382D 301 307 A3C6ZCBUNXUT7V 261 218 A8IFUOL8S9BZC 256 Indeed, customer 294 was the one who had the most number of reviews! Example: finding similar customers Let's now also compute which two customers are similar, based on shared reviews. To do so involves the following steps: We construct a sparse matrix consisting of only the diagonals. scipy.sparse.diags(elements) will construct a sparse diagonal matrix based on the elements inside elements . Subtract the diagonals from the customer matrix projection. This yields the customer-customer similarity matrix, which should only consist of the off-diagonal elements of the customer matrix projection. Finally, get the indices where the weight (shared number of between the customers is highest. ( This code is provided for you. ) import scipy.sparse as sp # Construct diagonal elements. customer_diags = sp . diags ( degrees ) # Subtract off-diagonals. off_diagonals = customer_mat - customer_diags # Compute index of most similar individuals. np . unravel_index ( np . argmax ( off_diagonals ), customer_mat . shape ) (294, 86) Performance: Object vs. Matrices Finally, to motivate why you might want to use matrices rather than graph objects to compute some of these statistics, let's time the two ways of getting to the same answer. Objects Let's first use NetworkX's built-in machinery to find customers that are most similar. from time import time start = time () # Compute the projection G_cust = nx . bipartite . weighted_projected_graph ( G_amzn , customer_nodes ) # Identify the most similar customers most_similar_customers = sorted ( G_cust . edges ( data = True ), key = lambda x : x [ 2 ][ 'weight' ], reverse = True )[ 0 ] end = time () print ( f ' { end - start : .3f } seconds' ) print ( f 'Most similar customers: { most_similar_customers } ' ) 15.048 seconds Most similar customers: ('A3HU0B9XUEVHIM', 'A9Q28YTLYREO7', {'weight': 154}) Matrices Now, let's implement the same thing in matrix form. start = time () # Compute the projection using matrices mat = nx . bipartite . matrix . biadjacency_matrix ( G_amzn , customer_nodes ) cust_mat = mat @ mat . T # Identify the most similar customers degrees = customer_mat . diagonal () customer_diags = sp . diags ( degrees ) off_diagonals = customer_mat - customer_diags c1 , c2 = np . unravel_index ( np . argmax ( off_diagonals ), customer_mat . shape ) end = time () print ( f ' { end - start : .3f } seconds' ) print ( f 'Most similar customers: { customer_nodes [ c1 ] } , { customer_nodes [ c2 ] } , { cust_mat [ c1 , c2 ] } ' ) 0.459 seconds Most similar customers: A9Q28YTLYREO7, A3HU0B9XUEVHIM, 154 On a modern PC, the matrix computation should be about 10-50X faster using the matrix form compared to the object-oriented form. (The web server that is used to build the book might not necessarily have the software stack to do this though, so the time you see reported might not reflect the expected speedups.) I'd encourage you to fire up a Binder session or clone the book locally to test out the code yourself. You may notice that it's much easier to read the \"objects\" code, but the matrix code way outperforms the object code. This tradeoff is common in computing, and shouldn't surprise you. That said, the speed gain alone is a great reason to use matrices! Acceleration on a GPU If your appetite has been whipped up for even more acceleration and you have a GPU on your daily compute, then you're very much in luck! The RAPIDS.AI project has a package called cuGraph , which provides GPU-accelerated graph algorithms. As over release 0.16.0, all cuGraph algorithms will be able to accept NetworkX graph objects! This came about through online conversations on GitHub and Twitter, which for us, personally, speaks volumes to the power of open source projects! Because cuGraph does presume that you have access to a GPU, and because we assume most readers of this book might not have access to one easily, we'll delegate teaching how to install and use cuGraph to the cuGraph devs and their documentation . Nonetheless, if you do have the ability to install and use the RAPIDS stack, definitely check it out!","title":"Chapter 10: Linear Algebra"},{"location":"04-advanced/02-linalg/#introduction","text":"from IPython.display import YouTubeVideo YouTubeVideo ( id = \"uTHihJiRELc\" , width = \"100%\" ) In this chapter, we will look at the relationship between graphs and linear algebra. The deep connection between these two topics is super interesting, and I'd like to show it to you through an exploration of three topics: Path finding Message passing Bipartite projections","title":"Introduction"},{"location":"04-advanced/02-linalg/#preliminaries","text":"Before we go deep into the linear algebra piece though, we have to first make sure some ideas are clear. The most important thing that we need when treating graphs in linear algebra form is the adjacency matrix . For example, for four nodes joined in a chain: import networkx as nx nodes = list ( range ( 4 )) G1 = nx . Graph () G1 . add_nodes_from ( nodes ) G1 . add_edges_from ( zip ( nodes , nodes [ 1 :])) we can visualize the graph: nx . draw ( G1 , with_labels = True ) and we can visualize its adjacency matrix: import nxviz as nv m = nv . matrix ( G1 ) /home/runner/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.0 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.6.3, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( and we can obtain the adjacency matrix as a NumPy array: A1 = nx . to_numpy_array ( G1 , nodelist = sorted ( G1 . nodes ())) A1 array([[0., 1., 0., 0.], [1., 0., 1., 0.], [0., 1., 0., 1.], [0., 0., 1., 0.]])","title":"Preliminaries"},{"location":"04-advanced/02-linalg/#symmetry","text":"Remember that for an undirected graph, the adjacency matrix will be symmetric about the diagonal, while for a directed graph, the adjacency matrix will be asymmetric .","title":"Symmetry"},{"location":"04-advanced/02-linalg/#path-finding","text":"In the Paths chapter, we can use the breadth-first search algorithm to find a shortest path between any two nodes . As it turns out, using adjacency matrices, we can answer a related question, which is how many paths exist of length K between two nodes . To see how, we need to see the relationship between matrix powers and graph path lengths. Let's take the adjacency matrix above, raise it to the second power, and see what it tells us. import numpy as np np . linalg . matrix_power ( A1 , 2 ) array([[1., 0., 1., 0.], [0., 2., 0., 1.], [1., 0., 2., 0.], [0., 1., 0., 1.]])","title":"Path finding"},{"location":"04-advanced/02-linalg/#exercise-adjacency-matrix-power","text":"What do you think the values in the adjacency matrix are related to? If studying in a group, discuss with your neighbors; if working on this alone, write down your thoughts. from nams.solutions.linalg import adjacency_matrix_power from nams.functions import render_html render_html ( adjacency_matrix_power ()) The diagonals equal to the degree of each node. The off-diagonals also contain values, which correspond to the number of paths that exist of length 2 between the node on the row axis and the node on the column axis. In fact, the diagonal also takes on the same meaning! For the terminal nodes, there is only 1 path from itself back to itself, while for the middle nodes, there are 2 paths from itself back to itself!","title":"Exercise: adjacency matrix power?"},{"location":"04-advanced/02-linalg/#higher-matrix-powers","text":"The semantic meaning of adjacency matrix powers is preserved even if we go to higher powers. For example, if we go to the 3rd matrix power: np . linalg . matrix_power ( A1 , 3 ) array([[0., 2., 0., 1.], [2., 0., 3., 0.], [0., 3., 0., 2.], [1., 0., 2., 0.]]) You should be able to convince yourself that: There's no way to go from a node back to itself in 3 steps, thus explaining the diagonals, and The off-diagonals take on the correct values when you think about them in terms of \"ways to go from one node to another\".","title":"Higher matrix powers"},{"location":"04-advanced/02-linalg/#with-directed-graphs","text":"Does the \"number of steps\" interpretation hold with directed graphs? Yes it does! Let's see it in action. G2 = nx . DiGraph () G2 . add_nodes_from ( nodes ) G2 . add_edges_from ( zip ( nodes , nodes [ 1 :])) nx . draw ( G2 , with_labels = True )","title":"With directed graphs?"},{"location":"04-advanced/02-linalg/#exercise-directed-graph-matrix-power","text":"Convince yourself that the resulting adjacency matrix power contains the same semantic meaning as that for an undirected graph, that is, the number of ways to go from \"row\" node to \"column\" node in K steps . (I have provided three different matrix powers for you.) A2 = nx . to_numpy_array ( G2 ) np . linalg . matrix_power ( A2 , 2 ) array([[0., 0., 1., 0.], [0., 0., 0., 1.], [0., 0., 0., 0.], [0., 0., 0., 0.]]) np . linalg . matrix_power ( A2 , 3 ) array([[0., 0., 0., 1.], [0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]]) np . linalg . matrix_power ( A2 , 4 ) array([[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]])","title":"Exercise: directed graph matrix power"},{"location":"04-advanced/02-linalg/#message-passing","text":"Let's now dive into the second topic here, that of message passing. To show how message passing works on a graph, let's start with the directed linear chain, as this will make things easier to understand.","title":"Message Passing"},{"location":"04-advanced/02-linalg/#message-representation-in-matrix-form","text":"Our graph adjacency matrix contains nodes ordered in a particular fashion along the rows and columns. We can also create a \"message\" matrix M M , using the same ordering of nodes along the rows, with columns instead representing a \"message\" that is intended to be \"passed\" from one node to another: M = np . array ([ 1 , 0 , 0 , 0 ]) M array([1, 0, 0, 0]) Notice where the position of the value 1 is - at the first node. If we take M and matrix multiply it against A2, let's see what we get: M @ A2 array([0., 1., 0., 0.]) The message has been passed onto the next node! And if we pass the message one more time: M @ A2 @ A2 array([0., 0., 1., 0.]) Now, the message lies on the 3rd node! We can make an animation to visualize this more clearly. There are comments in the code to explain what's going on! def propagate ( G , msg , n_frames ): \"\"\" Computes the node values based on propagation. Intended to be used before or when being passed into the anim() function (defined below). :param G: A NetworkX Graph. :param msg: The initial state of the message. :returns: A list of 1/0 representing message status at each node. \"\"\" # Initialize a list to store message states at each timestep. msg_states = [] # Set a variable `new_msg` to be the initial message state. new_msg = msg # Get the adjacency matrix of the graph G. A = nx . to_numpy_array ( G ) # Perform message passing at each time step for i in range ( n_frames ): msg_states . append ( new_msg ) new_msg = new_msg @ A # Return the message states. return msg_states from IPython.display import HTML import matplotlib.pyplot as plt from matplotlib import animation def update_func ( step , nodes , colors ): \"\"\" The update function for each animation time step. :param step: Passed in from matplotlib's FuncAnimation. Must be present in the function signature. :param nodes: Returned from nx.draw_networkx_edges(). Is an array of colors. :param colors: A list of pre-computed colors. \"\"\" nodes . set_array ( colors [ step ] . ravel ()) return nodes def anim ( G , initial_state , n_frames = 4 ): \"\"\" Animation function! \"\"\" # First, pre-compute the message passing states over all frames. colors = propagate ( G , initial_state , n_frames ) # Instantiate a figure fig = plt . figure () # Precompute node positions so that they stay fixed over the entire animation pos = nx . kamada_kawai_layout ( G ) # Draw nodes to screen nodes = nx . draw_networkx_nodes ( G , pos = pos , node_color = colors [ 0 ] . ravel (), node_size = 20 ) # Draw edges to screen ax = nx . draw_networkx_edges ( G , pos ) # Finally, return the animation through matplotlib. return animation . FuncAnimation ( fig , update_func , frames = range ( n_frames ), fargs = ( nodes , colors )) # Initialize the message msg = np . zeros ( len ( G2 )) msg [ 0 ] = 1 # Animate the graph with message propagation. HTML ( anim ( G2 , msg , n_frames = 4 ) . to_html5_video ()) Your browser does not support the video tag.","title":"\"Message\" representation in matrix form"},{"location":"04-advanced/02-linalg/#bipartite-graphs-matrices","text":"The section on message passing above assumed unipartite graphs, or at least graphs for which messages can be meaningfully passed between nodes. In this section, we will look at bipartite graphs. Recall from before the definition of a bipartite graph: Nodes are separated into two partitions (hence 'bi'-'partite'). Edges can only occur between nodes of different partitions. Bipartite graphs have a natural matrix representation, known as the biadjacency matrix . Nodes on one partition are the rows, and nodes on the other partition are the columns. NetworkX's bipartite module provides a function for computing the biadjacency matrix of a bipartite graph. Let's start by looking at a toy bipartite graph, a \"customer-product\" purchase record graph, with 4 products and 3 customers. The matrix representation might be as follows: # Rows = customers, columns = products, 1 = customer purchased product, 0 = customer did not purchase product. cp_mat = np . array ([[ 0 , 1 , 0 , 0 ], [ 1 , 0 , 1 , 0 ], [ 1 , 1 , 1 , 1 ]]) From this \"bi-adjacency\" matrix, one can compute the projection onto the customers, matrix multiplying the matrix with its transpose. c_mat = cp_mat @ cp_mat . T # c_mat means \"customer matrix\" c_mat array([[1, 0, 1], [0, 2, 2], [1, 2, 4]]) What we get is the connectivity matrix of the customers, based on shared purchases. The diagonals are the degree of the customers in the original graph, i.e. the number of purchases they originally made, and the off-diagonals are the connectivity matrix, based on shared products. To get the products matrix, we make the transposed matrix the left side of the matrix multiplication. p_mat = cp_mat . T @ cp_mat # p_mat means \"product matrix\" p_mat array([[2, 1, 2, 1], [1, 2, 1, 1], [2, 1, 2, 1], [1, 1, 1, 1]]) You may now try to convince yourself that the diagonals are the number of times a customer purchased that product, and the off-diagonals are the connectivity matrix of the products, weighted by how similar two customers are.","title":"Bipartite Graphs &amp; Matrices"},{"location":"04-advanced/02-linalg/#exercises","text":"In the following exercises, you will now play with a customer-product graph from Amazon. This dataset was downloaded from UCSD's Julian McAuley's website , and corresponds to the digital music dataset. This is a bipartite graph. The two partitions are: customers : The customers that were doing the reviews. products : The music that was being reviewed. In the original dataset (see the original JSON in the datasets/ directory), they are referred to as: customers : reviewerID products : asin from nams import load_data as cf G_amzn = cf . load_amazon_reviews () 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 64706/64706 [00:00<00:00, 78113.58it/s] 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 64706/64706 [00:00<00:00, 464512.67it/s] 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 64706/64706 [00:00<00:00, 437161.15it/s] Remember that with bipartite graphs, it is useful to obtain nodes from one of the partitions. from nams.solutions.bipartite import extract_partition_nodes customer_nodes = extract_partition_nodes ( G_amzn , \"customer\" ) mat = nx . bipartite . biadjacency_matrix ( G_amzn , row_order = customer_nodes ) You'll notice that this matrix is extremely large! There are 5541 customers and 3568 products, for a total matrix size of 5541 \\times 3568 = 19770288 5541 \\times 3568 = 19770288 , but it is stored in a sparse format because only 64706 elements are filled in. mat <5541x3568 sparse matrix of type '<class 'numpy.int64'>' with 64706 stored elements in Compressed Sparse Row format>","title":"Exercises"},{"location":"04-advanced/02-linalg/#example-finding-customers-who-reviewed-the-most-number-of-music-items","text":"Let's find out which customers reviewed the most number of music items. To do so, you can break the problem into a few steps. First off, we compute the customer projection using matrix operations. customer_mat = mat @ mat . T Next, get the diagonals of the customer-customer matrix. Recall here that in customer_mat , the diagonals correspond to the degree of the customer nodes in the bipartite matrix. SciPy sparse matrices provide a .diagonal() method that returns the diagonal elements. # Get the diagonal. degrees = customer_mat . diagonal () Finally, find the index of the customer that has the highest degree. cust_idx = np . argmax ( degrees ) cust_idx 294 We can verify this independently by sorting the customer nodes by degree. import pandas as pd import janitor # There's some pandas-fu we need to use to get this correct. deg = ( pd . Series ( dict ( nx . degree ( G_amzn , customer_nodes ))) . to_frame () . reset_index () . rename_column ( \"index\" , \"customer\" ) . rename_column ( 0 , \"num_reviews\" ) . sort_values ( 'num_reviews' , ascending = False ) ) deg . head () customer num_reviews 294 A9Q28YTLYREO7 578 86 A3HU0B9XUEVHIM 375 77 A3KJ6JAZPH382D 301 307 A3C6ZCBUNXUT7V 261 218 A8IFUOL8S9BZC 256 Indeed, customer 294 was the one who had the most number of reviews!","title":"Example: finding customers who reviewed the most number of music items."},{"location":"04-advanced/02-linalg/#example-finding-similar-customers","text":"Let's now also compute which two customers are similar, based on shared reviews. To do so involves the following steps: We construct a sparse matrix consisting of only the diagonals. scipy.sparse.diags(elements) will construct a sparse diagonal matrix based on the elements inside elements . Subtract the diagonals from the customer matrix projection. This yields the customer-customer similarity matrix, which should only consist of the off-diagonal elements of the customer matrix projection. Finally, get the indices where the weight (shared number of between the customers is highest. ( This code is provided for you. ) import scipy.sparse as sp # Construct diagonal elements. customer_diags = sp . diags ( degrees ) # Subtract off-diagonals. off_diagonals = customer_mat - customer_diags # Compute index of most similar individuals. np . unravel_index ( np . argmax ( off_diagonals ), customer_mat . shape ) (294, 86)","title":"Example: finding similar customers"},{"location":"04-advanced/02-linalg/#performance-object-vs-matrices","text":"Finally, to motivate why you might want to use matrices rather than graph objects to compute some of these statistics, let's time the two ways of getting to the same answer.","title":"Performance: Object vs. Matrices"},{"location":"04-advanced/02-linalg/#objects","text":"Let's first use NetworkX's built-in machinery to find customers that are most similar. from time import time start = time () # Compute the projection G_cust = nx . bipartite . weighted_projected_graph ( G_amzn , customer_nodes ) # Identify the most similar customers most_similar_customers = sorted ( G_cust . edges ( data = True ), key = lambda x : x [ 2 ][ 'weight' ], reverse = True )[ 0 ] end = time () print ( f ' { end - start : .3f } seconds' ) print ( f 'Most similar customers: { most_similar_customers } ' ) 15.048 seconds Most similar customers: ('A3HU0B9XUEVHIM', 'A9Q28YTLYREO7', {'weight': 154})","title":"Objects"},{"location":"04-advanced/02-linalg/#matrices","text":"Now, let's implement the same thing in matrix form. start = time () # Compute the projection using matrices mat = nx . bipartite . matrix . biadjacency_matrix ( G_amzn , customer_nodes ) cust_mat = mat @ mat . T # Identify the most similar customers degrees = customer_mat . diagonal () customer_diags = sp . diags ( degrees ) off_diagonals = customer_mat - customer_diags c1 , c2 = np . unravel_index ( np . argmax ( off_diagonals ), customer_mat . shape ) end = time () print ( f ' { end - start : .3f } seconds' ) print ( f 'Most similar customers: { customer_nodes [ c1 ] } , { customer_nodes [ c2 ] } , { cust_mat [ c1 , c2 ] } ' ) 0.459 seconds Most similar customers: A9Q28YTLYREO7, A3HU0B9XUEVHIM, 154 On a modern PC, the matrix computation should be about 10-50X faster using the matrix form compared to the object-oriented form. (The web server that is used to build the book might not necessarily have the software stack to do this though, so the time you see reported might not reflect the expected speedups.) I'd encourage you to fire up a Binder session or clone the book locally to test out the code yourself. You may notice that it's much easier to read the \"objects\" code, but the matrix code way outperforms the object code. This tradeoff is common in computing, and shouldn't surprise you. That said, the speed gain alone is a great reason to use matrices!","title":"Matrices"},{"location":"04-advanced/02-linalg/#acceleration-on-a-gpu","text":"If your appetite has been whipped up for even more acceleration and you have a GPU on your daily compute, then you're very much in luck! The RAPIDS.AI project has a package called cuGraph , which provides GPU-accelerated graph algorithms. As over release 0.16.0, all cuGraph algorithms will be able to accept NetworkX graph objects! This came about through online conversations on GitHub and Twitter, which for us, personally, speaks volumes to the power of open source projects! Because cuGraph does presume that you have access to a GPU, and because we assume most readers of this book might not have access to one easily, we'll delegate teaching how to install and use cuGraph to the cuGraph devs and their documentation . Nonetheless, if you do have the ability to install and use the RAPIDS stack, definitely check it out!","title":"Acceleration on a GPU"},{"location":"04-advanced/03-stats/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); % load_ext autoreload % autoreload 2 % matplotlib inline % config InlineBackend . figure_format = 'retina' Introduction from IPython.display import YouTubeVideo YouTubeVideo ( id = \"P-0CJpO3spg\" , width = \"100%\" ) In this chapter, we are going to take a look at how to perform statistical inference on graphs. Statistics refresher Before we can proceed with statistical inference on graphs, we must first refresh ourselves with some ideas from the world of statistics. Otherwise, the methods that we will end up using may seem a tad weird , and hence difficult to follow along. To review statistical ideas, let's set up a few statements and explore what they mean. We are concerned with models of randomness As with all things statistics, we are concerned with models of randomness. Here, probability distributions give us a way to think about random events and how to assign credibility points to them. In an abstract fashion... The supremely abstract way of thinking about a probability distribution is that it is the space of all possibilities of \"stuff\" with different credibility points distributed amongst each possible \"thing\". More concretely: the coin flip A more concrete example is to consider the coin flip. Here, the space of all possibilities of \"stuff\" is the set of \"heads\" and \"tails\". If we have a fair coin, then we have 0.5 credibility points distributed to each of \"heads\" and \"tails\". Another example: dice rolls Another concrete example is to consider the six-sided dice. Here, the space of all possibilities of \"stuff\" is the set of numbers in the range [1, 6] [1, 6] . If we have a fair dice, then we have 1/6 credibility points assigned to each of the numbers. (Unfair dice will have an unequal distribution of credibility points across each face.) A graph-based example: social networks If we receive an undirected social network graph with 5 nodes and 6 edges, we have to keep in mind that this graph with 6 edges was merely one of 15 \\choose 6 15 \\choose 6 ways to construct 5 node, 6 edge graphs. (15 comes up because there are 15 edges that can be constructed in a 5-node undirected graph.) Hypothesis Testing A commonplace task in statistical inferences is calculating the probability of observing a value or something more extreme under an assumed \"null\" model of reality. This is what we commonly call \"hypothesis testing\", and where the oft-misunderstood term \"p-value\" shows up. Hypothesis testing in coin flips, by simulation As an example, hypothesis testing in coin flips follows this logic: I observe that 8 out of 10 coin tosses give me heads, giving me a probability of heads p=0.8 p=0.8 (a summary statistic). Under a \"null distribution\" of a fair coin, I simulate the distribution of probability of heads (the summary statistic) that I would get from 10 coin tosses. Finally, I use that distribution to calculate the probability of observing p=0.8 p=0.8 or more extreme. Hypothesis testing in graphs The same protocol applies when we perform hypothesis testing on graphs. Firstly, we calculate a summary statistic that describes our graph. Secondly, we propose a null graph model , and calculate our summary statistic under simulated versions of that null graph model. Thirdly, we look at the probability of observing the summary statistic value that we calculated in step 1 or more extreme, under the assumed graph null model distribution. Stochastic graph creation models Since we are going to be dealing with models of randomness in graphs, let's take a look at some examples. Erdos-Renyi (a.k.a. \"binomial\") graph On easy one to study is the Erdos-Renyi graph, also known as the \"binomial\" graph. The data generation story here is that we instantiate an undirected graph with n n nodes, giving \\frac{n^2 - n}{2} \\frac{n^2 - n}{2} possible edges. Each edge has a probability p p of being created. import networkx as nx G_er = nx . erdos_renyi_graph ( n = 30 , p = 0.2 ) nx . draw ( G_er ) You can verify that there's approximately 20% of \\frac{30^2 - 30}{2} = 435 \\frac{30^2 - 30}{2} = 435 . len ( G_er . edges ()) 90 len ( G_er . edges ()) / 435 0.20689655172413793 We can also look at the degree distribution: import pandas as pd from nams.functions import ecdf import matplotlib.pyplot as plt x , y = ecdf ( pd . Series ( dict ( nx . degree ( G_er )))) plt . scatter ( x , y ) <matplotlib.collections.PathCollection at 0x7ff080541f70> Barabasi-Albert Graph The data generating story of this graph generator is essentially that nodes that have lots of edges preferentially get new edges attached onto them. This is what we call a \"preferential attachment\" process. G_ba = nx . barabasi_albert_graph ( n = 30 , m = 3 ) nx . draw ( G_ba ) len ( G_ba . edges ()) 81 And the degree distribution: x , y = ecdf ( pd . Series ( dict ( nx . degree ( G_ba )))) plt . scatter ( x , y ) <matplotlib.collections.PathCollection at 0x7ff080420940> You can see that even though the number of edges between the two graphs are similar, their degree distribution is wildly different. Load Data For this notebook, we are going to look at a protein-protein interaction network, and test the hypothesis that this network was not generated by the data generating process described by an Erdos-Renyi graph. Let's load a protein-protein interaction network dataset . This undirected network contains protein interactions contained in yeast. Research showed that proteins with a high degree were more important for the surivial of the yeast than others. A node represents a protein and an edge represents a metabolic interaction between two proteins. The network contains loops. from nams import load_data as cf G = cf . load_propro_network () for n , d in G . nodes ( data = True ): G . nodes [ n ][ \"degree\" ] = G . degree ( n ) As is always the case, let's make sure we know some basic stats of the graph. len ( G . nodes ()) 1870 len ( G . edges ()) 2277 Let's also examine the degree distribution of the graph. x , y = ecdf ( pd . Series ( dict ( nx . degree ( G )))) plt . scatter ( x , y ) <matplotlib.collections.PathCollection at 0x7ff07270daf0> Finally, we should visualize the graph to get a feel for it. import nxviz as nv from nxviz import annotate nv . circos ( G , sort_by = \"degree\" , node_color_by = \"degree\" , node_aes_kwargs = { \"size_scale\" : 10 }) annotate . node_colormapping ( G , color_by = \"degree\" ) /home/runner/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.0 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.6.3, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( One thing we might infer from this visualization is that the vast majority of nodes have a very small degree, while a very small number of nodes have a high degree. That would prompt us to think: what process could be responsible for generating this graph? Inferring Graph Generating Model Given a graph dataset, how do we identify which data generating model provides the best fit? One way to do this is to compare characteristics of a graph generating model against the characteristics of the graph. The logic here is that if we have a good graph generating model for the data, we should, in theory, observe the observed graph's characteristics in the graphs generated by the graph generating model. Comparison of degree distribution Let's compare the degree distribution between the data, a few Erdos-Renyi graphs, and a few Barabasi-Albert graphs. Comparison with Barabasi-Albert graphs from ipywidgets import interact , IntSlider m = IntSlider ( value = 2 , min = 1 , max = 10 ) @interact ( m = m ) def compare_barabasi_albert_graph ( m ): fig , ax = plt . subplots () G_ba = nx . barabasi_albert_graph ( n = len ( G . nodes ()), m = m ) x , y = ecdf ( pd . Series ( dict ( nx . degree ( G_ba )))) ax . scatter ( x , y , label = \"Barabasi-Albert Graph\" ) x , y = ecdf ( pd . Series ( dict ( nx . degree ( G )))) ax . scatter ( x , y , label = \"Protein Interaction Network\" ) ax . legend () var element = $('#fd67aaf2-c599-42f4-966d-1b9c9e18837d'); Comparison with Erdos-Renyi graphs from ipywidgets import FloatSlider p = FloatSlider ( value = 0.6 , min = 0 , max = 0.1 , step = 0.001 ) @interact ( p = p ) def compare_erdos_renyi_graph ( p ): fig , ax = plt . subplots () G_er = nx . erdos_renyi_graph ( n = len ( G . nodes ()), p = p ) x , y = ecdf ( pd . Series ( dict ( nx . degree ( G_er )))) ax . scatter ( x , y , label = \"Erdos-Renyi Graph\" ) x , y = ecdf ( pd . Series ( dict ( nx . degree ( G )))) ax . scatter ( x , y , label = \"Protein Interaction Network\" ) ax . legend () ax . set_title ( f \"p= { p } \" ) var element = $('#5b57e6da-8d2e-4079-9bc6-d53d8cc04c5d'); Given the degree distribution only, which model do you think better describes the generation of a protein-protein interaction network? Quantitative Model Comparison Each time we plug in a value of m m for the Barabasi-Albert graph model, we are using one of many possible Barabasi-Albert graph models, each with a different m m . Similarly, each time we choose a different p p for the Erdos-Renyi model, we are using one of many possible Erdos-Renyi graph models, each with a different p p . To quantitatively compare degree distributions, we can use the Wasserstein distance between the data. Let's see how to implement this. from scipy.stats import wasserstein_distance def erdos_renyi_degdist ( n , p ): \"\"\"Return a Pandas series of degree distribution of an Erdos-Renyi graph.\"\"\" G = nx . erdos_renyi_graph ( n = n , p = p ) return pd . Series ( dict ( nx . degree ( G ))) def barabasi_albert_degdist ( n , m ): \"\"\"Return a Pandas series of degree distribution of an Barabasi-Albert graph.\"\"\" G = nx . barabasi_albert_graph ( n = n , m = m ) return pd . Series ( dict ( nx . degree ( G ))) deg = pd . Series ( dict ( nx . degree ( G ))) er_deg = erdos_renyi_degdist ( n = len ( G . nodes ()), p = 0.001 ) ba_deg = barabasi_albert_degdist ( n = len ( G . nodes ()), m = 1 ) wasserstein_distance ( deg , er_deg ), wasserstein_distance ( deg , ba_deg ) (0.7860962566844915, 0.5251336898395734) Notice that because the graphs are instantiated in a non-deterministic fashion, re-running the cell above will give you different values for each new graph generated. Let's now plot the wasserstein distance to our graph data for the two particular Erdos-Renyi and Barabasi-Albert graph models shown above. import matplotlib.pyplot as plt from tqdm.autonotebook import tqdm er_dist = [] ba_dist = [] for _ in tqdm ( range ( 100 )): er_deg = erdos_renyi_degdist ( n = len ( G . nodes ()), p = 0.001 ) er_dist . append ( wasserstein_distance ( deg , er_deg )) ba_deg = barabasi_albert_degdist ( n = len ( G . nodes ()), m = 1 ) ba_dist . append ( wasserstein_distance ( deg , ba_deg )) # er_degs = [erdos_renyi_degdist(n=len(G.nodes()), p=0.001) for _ in range(100)] <ipython-input-1-1b1ecb0363e4>:2: TqdmExperimentalWarning: Using `tqdm.autonotebook.tqdm` in notebook mode. Use `tqdm.tqdm` instead to force console mode (e.g. in jupyter console) from tqdm.autonotebook import tqdm var element = $('#766db859-4220-4f1d-b2a2-efc20d895d33'); import seaborn as sns import janitor data = ( pd . DataFrame ( { \"Erdos-Renyi\" : er_dist , \"Barabasi-Albert\" : ba_dist , } ) . melt ( value_vars = [ \"Erdos-Renyi\" , \"Barabasi-Albert\" ]) . rename_columns ({ \"variable\" : \"Graph Model\" , \"value\" : \"Wasserstein Distance\" }) ) sns . swarmplot ( data = data , x = \"Graph Model\" , y = \"Wasserstein Distance\" ) <AxesSubplot:xlabel='Graph Model', ylabel='Wasserstein Distance'> From this, we might conclude that the Barabasi-Albert graph with m=1 m=1 has the better fit to the protein-protein interaction network graph. Interpretation That statement, accurate as it might be, still does not connect the dots to biology . Let's think about the generative model for this graph. The Barabasi-Albert graph gives us a model for \"rich gets richer\". Given the current state of the graph, if we want to add a new edge, we first pick a node with probability proportional to the number of edges it already has. Then, we pick another node with probability proportional to the number of edges that it has too. Finally, we add an edge there. This has the effect of \"enriching\" nodes that have a large number of edges with more edges. How might this connect to biology? We can't necessarily provide a concrete answer, but this model might help raise new hypotheses. For example, if protein-protein interactions of the \"binding\" kind are driven by subdomains, then proteins that acquire a domain through recombination may end up being able to bind to everything else that the domain was able to. In this fashion, proteins with that particular binding domain gain new edges more readily. Testing these hypotheses would be a totally different matter, and at this point, I submit the above hypothesis with a large amount of salt thrown over my shoulder. In other words, the hypothesized mechanism could be completely wrong. However, I hope that this example illustrated that the usage of a \"graph generative model\" can help us narrow down hypotheses about the observed world. {\"state\": {\"25c5cd70c00e47d687a89094126f6be2\": {\"model_name\": \"LayoutModel\", \"model_module\": \"@jupyter-widgets/base\", \"model_module_version\": \"1.2.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/base\", \"_model_module_version\": \"1.2.0\", \"_model_name\": \"LayoutModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"LayoutView\", \"align_content\": null, \"align_items\": null, \"align_self\": null, \"border\": null, \"bottom\": null, \"display\": null, \"flex\": null, \"flex_flow\": null, \"grid_area\": null, \"grid_auto_columns\": null, \"grid_auto_flow\": null, \"grid_auto_rows\": null, \"grid_column\": null, \"grid_gap\": null, \"grid_row\": null, \"grid_template_areas\": null, \"grid_template_columns\": null, \"grid_template_rows\": null, \"height\": null, \"justify_content\": null, \"justify_items\": null, \"left\": null, \"margin\": null, \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"object_fit\": null, \"object_position\": null, \"order\": null, \"overflow\": null, \"overflow_x\": null, \"overflow_y\": null, \"padding\": null, \"right\": null, \"top\": null, \"visibility\": null, \"width\": null}}, \"3aec3736461c469ca0aa1a211a71e1ee\": {\"model_name\": \"SliderStyleModel\", \"model_module\": \"@jupyter-widgets/controls\", \"model_module_version\": \"1.5.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/controls\", \"_model_module_version\": \"1.5.0\", \"_model_name\": \"SliderStyleModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"StyleView\", \"description_width\": \"\", \"handle_color\": null}}, \"80e5e852d32b4da395152a560f3def86\": {\"model_name\": \"IntSliderModel\", \"model_module\": \"@jupyter-widgets/controls\", \"model_module_version\": \"1.5.0\", \"state\": {\"_dom_classes\": [], \"_model_module\": \"@jupyter-widgets/controls\", \"_model_module_version\": \"1.5.0\", \"_model_name\": \"IntSliderModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/controls\", \"_view_module_version\": \"1.5.0\", \"_view_name\": \"IntSliderView\", \"continuous_update\": true, \"description\": \"m\", \"description_tooltip\": null, \"disabled\": false, \"layout\": \"IPY_MODEL_25c5cd70c00e47d687a89094126f6be2\", \"max\": 10, \"min\": 1, \"orientation\": \"horizontal\", \"readout\": true, \"readout_format\": \"d\", \"step\": 1, \"style\": \"IPY_MODEL_3aec3736461c469ca0aa1a211a71e1ee\", \"value\": 2}}, \"849f222e990c4292802e22294ba8dfed\": {\"model_name\": \"LayoutModel\", \"model_module\": \"@jupyter-widgets/base\", \"model_module_version\": \"1.2.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/base\", \"_model_module_version\": \"1.2.0\", \"_model_name\": \"LayoutModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"LayoutView\", \"align_content\": null, \"align_items\": null, \"align_self\": null, \"border\": null, \"bottom\": null, \"display\": null, \"flex\": null, \"flex_flow\": null, \"grid_area\": null, \"grid_auto_columns\": null, \"grid_auto_flow\": null, \"grid_auto_rows\": null, \"grid_column\": null, \"grid_gap\": null, \"grid_row\": null, \"grid_template_areas\": null, \"grid_template_columns\": null, \"grid_template_rows\": null, \"height\": null, \"justify_content\": null, \"justify_items\": null, \"left\": null, \"margin\": null, \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"object_fit\": null, \"object_position\": null, \"order\": null, \"overflow\": null, \"overflow_x\": null, \"overflow_y\": null, \"padding\": null, \"right\": null, \"top\": null, \"visibility\": null, \"width\": null}}, \"de248d7e9cbc41b69d19ed0ff52ed26a\": {\"model_name\": \"VBoxModel\", \"model_module\": \"@jupyter-widgets/controls\", \"model_module_version\": \"1.5.0\", \"state\": {\"_dom_classes\": [\"widget-interact\"], \"_model_module\": \"@jupyter-widgets/controls\", \"_model_module_version\": \"1.5.0\", \"_model_name\": \"VBoxModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/controls\", \"_view_module_version\": \"1.5.0\", \"_view_name\": \"VBoxView\", \"box_style\": \"\", \"children\": [\"IPY_MODEL_80e5e852d32b4da395152a560f3def86\", \"IPY_MODEL_3feacbbeccb749dfb73c9fd914d3452b\"], \"layout\": \"IPY_MODEL_849f222e990c4292802e22294ba8dfed\"}}, \"2250175739e44563846e4635e31d60e5\": {\"model_name\": \"LayoutModel\", \"model_module\": \"@jupyter-widgets/base\", \"model_module_version\": \"1.2.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/base\", \"_model_module_version\": \"1.2.0\", \"_model_name\": \"LayoutModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"LayoutView\", \"align_content\": null, \"align_items\": null, \"align_self\": null, \"border\": null, \"bottom\": null, \"display\": null, \"flex\": null, \"flex_flow\": null, \"grid_area\": null, \"grid_auto_columns\": null, \"grid_auto_flow\": null, \"grid_auto_rows\": null, \"grid_column\": null, \"grid_gap\": null, \"grid_row\": null, \"grid_template_areas\": null, \"grid_template_columns\": null, \"grid_template_rows\": null, \"height\": null, \"justify_content\": null, \"justify_items\": null, \"left\": null, \"margin\": null, \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"object_fit\": null, \"object_position\": null, \"order\": null, \"overflow\": null, \"overflow_x\": null, \"overflow_y\": null, \"padding\": null, \"right\": null, \"top\": null, \"visibility\": null, \"width\": null}}, \"3feacbbeccb749dfb73c9fd914d3452b\": {\"model_name\": \"OutputModel\", \"model_module\": \"@jupyter-widgets/output\", \"model_module_version\": \"1.0.0\", \"state\": {\"_dom_classes\": [], \"_model_module\": \"@jupyter-widgets/output\", \"_model_module_version\": \"1.0.0\", \"_model_name\": \"OutputModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/output\", \"_view_module_version\": \"1.0.0\", \"_view_name\": \"OutputView\", \"layout\": \"IPY_MODEL_2250175739e44563846e4635e31d60e5\", \"msg_id\": \"\", \"outputs\": [{\"output_type\": \"display_data\", \"metadata\": {\"image/png\": {\"width\": 377, \"height\": 248}, \"needs_background\": \"light\"}, \"data\": {\"text/plain\": \"<Figure size 432x288 with 1 Axes>\", \"image/png\": \"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yRK1bNkyfMU5wJQpU4r9pOC0tDRt3LhRxhgtX75c33//vc4999wgVxjZ1q9fr759+2rt2rVKTExUamqqGjRooJiYGP38889atGiRZs+erUcffVS//vpruMuFQxHkAQABWbppr8bO26iVW/fnW9a2QXUN6dZEKY3D/6RDL19DVAYNGqTx48drzJgxDNsoxFlnnVXsbf/1r39JkoYOHarnn39e//rXvzRu3LhglRbxdu3apW7dumnnzp0aNGiQnnvuOZ122mn51vvyyy/197//PQwVoqxgaA0AoFAffPOT+r+5wmeIl6SVW/er/5sr9J9vtoe4sqLp3r27JOU7A3rw4EG9+OKLSk1NVb169VSxYkWdccYZuuqqq/T111/7bMsYoy5duuiXX37R7bffrrp16yo6Ojr7C8KGDRv0yCOPqE2bNjrjjDMUGxurpKQk3XnnndqxY0eBdS5fvlyXXHKJEhISFB8frx49eujbb7/Nt97OnTv11FNPKSUlRbVr11bFihV15pln6qabbvI7hOijjz5St27dVKdOHcXGxurMM89U586d9dprr+Var7hj5Pft26dZs2apSZMmeuaZZ1SrVi1NnTpVx48fL3JbkvTpp5+qQ4cOqlKliqpVq6Zrr71WGzdu9Lnu0aNHNXLkSLVs2VJVqlTRaaedposuukj//ve/862b85qElStX6oorrlD16tWzx+YbY7Rt2zZt27Yt1zCtAQMGFFrzY489pp07d+qmm27SuHHjfIZ4Sbr00kvz9WtGRkb2fjZs2KAbbrhBNWvWVFRUlBYsWCBJWrVqlYYMGaIWLVqoevXqqlSpkpo0aaKHHnpIBw4cyLefnNccFOV4er3xxhs677zzVKlSJdWqVUt33nmnDh48WOhxQOkjyAMACrR00149OvN/chXy/BOXlR6Z+V8t3bQ3NIUVw1dffSVJatOmTa7569at0+OPP66oqChdccUVevDBB3XppZdq/vz56tSpk7744guf7e3fv1/t27fX119/rT59+ui+++5TrVq1JEkzZ87U66+/rvr166tfv34aNGiQ/vSnP2nixIm68MIL9fPPP/tsc8WKFerSpYtiY2N177336vLLL9e8efPUqVMnLV68ONe6ixYt0qhRo5SYmKi+ffvqgQceUPv27TV9+nRdeOGFWrNmTa71//Wvf+nqq6/W2rVr1atXLz300EPq2bOnjh07pkmTJhXrmOb19ttv68SJExowYIBiYmJ0880368CBA5o2bVqR25o5c6auueYa1atXT0OGDNFFF12kGTNmqH379vrxxx9zrfvbb7+pY8eOeuyxxxQdHa3bbrtNt956q3799VfddNNNeuKJJ3zuY/ny5erUqZOOHz+evU3Tpk01bNgwJSQkKCEhQcOGDct+XXPNNQXWfPTo0ewvDjmHd/kTE+N7cMTmzZvVrl07ZWRk6Oabb9add96pqlWrSpImTJig999/X2effbYGDhyou+++W3Xq1NHo0aOVkpKiQ4cO+WyzKMfTa+jQoRo6dKhatGihe++9V3Xr1tWECRPUu3fvQt8bQsBaW25ekla1atXKlqphVYv1ynqyqk16+JN8LwAIxNq1a+3atWtLpe3rXl/m8/eTv9f1ry8rlToCJclKssOGDct+PfDAA7Zjx47WGGOvvPJK+/vvv+fa5rfffrO//vprvra2b99u69SpY5s1a+Z3P/3797enTp3Kt3zHjh32+PHj+ebPmTPHRkVF2bvvvjvX/LS0tOw2X3311VzLZs+ebSXZxo0b26ysrOz5u3fvzvderLV29erVtkqVKvayyy7LNb9Vq1a2YsWKdvfu3fm2yfv+O3fubN0xoWiaN29uo6Ki7Pbt26211v7vf/+zkmzHjh19rp+UlGSTkpJyzZs0aVL2sfj4449zLRszZoyVZFNTU3PNv/XWW60k+/zzz+eaf+zYMdujRw9rjLHfffdd9vycx/v1118PuLbCLFy40Eqy9erVK9J2Xlu3bs2u69FHH/W5TkZGhs3MzMw3f+LEiVaSHTVqVK75JTme9evXt9u2bcuef+rUKdupUycrya5YsaJY79HpAv1926pVKytplS3FbMsZeQCAXxt2H/I7nMafFVv3a8Nu32cEQ2nEiBHZr1deeUVLlixR8+bN1a9fP8XH5744NyEhQTVq5B/fX69ePV177bVav369fvrpp3zLK1asqJdeesnnWdW6desqNjY23/zu3bvrnHPO0Zw5c3zW3bhxY/31r3/NNe/qq69W586dtWnTplxn5WvWrJnvvUhSixYtlJqaqrS0NJ06dSrXspiYGFWoUCHfNr7ef1EtWrRI69at0yWXXKJ69epJks4991y1atVKS5YsKfIdg1JTU3XllVfmmnffffepUaNGmj9/vrZt2ybJPZxn6tSpatOmjYYOHZpr/UqVKun555+XtVbvvfdevn20bNlSd911V5HqKsgvv/wiyd3/vkyePFnDhw/P9Vq9enW+9WrVquX3jH5SUpKio6Pzzb/ttttUtWpVvz9bgR7PnP7xj3/kul4iJiZGAwcOlCStXLnS534QOlzsCgDwq7jDZJZu2hv2O9lY+8dYoCNHjuiHH37QI488optvvlk//PCDnn322VzrL126VGPHjtXy5cu1Z88enTx5Mtfyn3/+Od8FoMnJyapZs6bf/b/77ruaPHmy1qxZowMHDigrKyt7ecWKFX1u16lTJ0VF5T/P1qVLFy1cuFDfffedOnfunD3/008/1euvv65vv/1We/fuVWZmZq7t9u7dqzp16kiSbr75Zj300EM655xzdMMNN6hz585KSUnRGWec4bOWnH777TeNGTMm3/z7779fiYmJktxDPiRlBz2vAQMGKD09XRMmTNDo0aML3ZdXzvfpFR0drY4dO2rz5s367rvvlJSUpG+++UZZWVl+78Pv/TLj64tE27ZtA64nEN6fO3/XF0yePFkLFy7MNS85OTnfXZRatGjh84ug5H4/b7zxht5//32tXbtWBw8elMvlyl7ub9hWoMczp7zD0CSpfv36kuRzPD5CiyAPAPDr8PHMwlcK4nalpUqVKmrbtq1mzpypevXq6YUXXtDdd9+dHUhmzZqla6+9VpUqVdKll16qRo0aqUqVKtkXGC5cuFAnTpzI127t2rX97vPBBx/UmDFjVKdOHfXo0UN169ZV5cqVJbnDnK+zn5Kyx9j721fOiwzHjRunIUOGqFq1arr00kt11llnKS4uTsYYzZ49W2vWrMlV94MPPqgaNWrotdde07hx4zRmzBgZY9S5c2e9+OKLPkOb12+//aYRI0bkmz9gwAAlJibqwIEDmj59uhITE/ONI7/pppv0t7/9TVOmTNHIkSP9BtTiHot9+/ZJkr755ht98803fts7fPiw37aCxfulyV+Y9l6wKklPPPFEvi+UgdR1ww03aNasWWrYsKGuvvpq1a5dO/uYjhkzxufPqlS0ny0v75e0nLx/gcr5xRThQZAHAPh1WqXifUwUd7vSlpiYqLPPPlvp6elKT0/PDvJPPvmkKlasqG+//VbNmzfPtc1dd92V7wyql7+zrnv27NG4ceN07rnnatmyZfmGv/i6i4rX7t27fc73DtlISEiQJGVmZmrYsGGqXbu20tPTswOk1/Lly322c8stt+iWW27Rb7/9pmXLlmnWrFl666231KNHD61bt87vXxiSk5Nz/ZUjrylTpuj48eM6fvx49heWvPbt26cZM2bopptu8ttOToEeC+/0gQceKNIZf8l/HxZXmzZtFBsbq+3bt2vjxo1q0qRJsdrxV9e3336rWbNm6ZJLLtFnn32Wa5iUy+XSCy+84LfNQI8nnCMyf9MCACJCce8LH0n3k8/LOxwg51CETZs26ZxzzskX4l0ul5YsWVLkfWzZskUul0vdu3fPF+J37NihLVu2+N12yZIlcrlc+YbXeM/kXnDBBZLcQ2Z+++039enTJ1+IP3z4sNLT0wusMTExUT179lTPnj3lcrn01ltvafHixerbt2+gbzMX77Cafv36KS4uLt/ygwcPavr06ZowYULAQd7XF6isrKzsPvEei7Zt2yoqKirfXX1KKjo6Ot8Qq8LExcWpX79+mjx5sp566im98847Qa1p06ZNkqSrrroq37UOK1eu1LFjx/xuG+jxhHNwsSsAwK+mteLVtkH1Im3TrkH1sI+P92f27NnaunWrKlSooA4dOmTPT05O1saNG7Vz587sedZajRgxQmvXri3yfpKTkyW5Q3nO4QeHDx/WHXfckW8ce04bN27Md0/3Dz/8UAsXLlTjxo3VqVMnSe4LXePi4rRq1apcQ0ZOnTqlIUOGaO/e/Nc3fPHFFz73vWfPHknyGcADsWzZMv3www9q3ry53nvvPU2cODHf64MPPlBSUpIWLFigDRs2BNTu/Pnz9cknn+SaN378eG3evFldu3bNHs9ds2ZN3Xzzzfr222/19NNP+3yPmzdv1tatW4v0vk4//XT9+uuvBYZjX5599lmdeeaZmjp1qh544AEdOXLE53rFuRe792cr5xAdyd2H9957b4HbBno84RyckQcAFGhItybq/+aKQu8jL0lRRhrcrXhDCYIt50WPR44c0dq1a/X5559Lkp577rlc44UfeOAB3X333brgggvUt29fVahQQUuXLs2+3/rHH39cpH3Xrl1bN954o95//321bNlS3bt318GDB/Xll1+qUqVKatmypc87lUjSZZddpoceekiff/65WrRooU2bNmnmzJmqVKmS3nzzzewz9VFRURo8eLBGjRql8847T1dffbVOnjyptLQ0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+eWXX9aXX36pXr16qWvXrtlBeOvWrerYsaN27typ1NRU9evXT9u3b9e0adP06aefasaMGbryyislucN1YmKiPvzwQ1199dVq2bJldvuJiYmS3MN8evXqpTlz5ujss8/WTTfdpEqVKiktLU2DBg3SihUr9M47gX8ZGjp0qObMmaNevXqpe/fuSktL04QJE7Rp0ybNnz+/BEfqD6+99po++ugjXXXVVercubNWrFihDz74QGvWrNHq1asVGxurxMREDRs2TJMnT9a2bduyhzVJyhV009PT1b17d+3fv189evRQnz59tHfvXs2ePVsdO3bUrFmz1LNnz3w1+OsfSbrnnnv0pz/9SRdffLHq1Kmjffv26bPPPlP//v31448/6umnn87V1tatW9W1a1dt27ZNrVu31j333COXy6UNGzbolVde0d133x3w+/Hl5MmT6tGjhxYuXKhmzZrp3nvv1dGjRzV9+nTdcMMNWr16tZ577rl8223btk1t27ZVw4YN1b9/f+3fv18ffPCBrr76an311Vfq2rVrYV2VyzXXXKOLL75Yn3zyidLS0gLa/osvvlCfPn2yf04bN26sHTt2aObMmfr000+VlpamVq1aSXIPXZs9e7bWrFmjIUOGZP+Me6fdunXT+++/r3nz5qlJkybZ+0hLS5MkLVu2TMePH1elSpUkSQsXLlRmZmaugF/cY7l582a1a9dOTZs21c0336xjx46patWqft/3u+++q9tuu00NGzbUF198oaSkpEKPVcSw1pabl6RVrVq1sqVqWNVivbKerGqTHv4k3wsAArF27Vq7du3a0mn8rcuL9jvtrZ6lU0eAJFn3x1tuX375pTXGWGOMzcjIsNZaO2zYMCvJxsXF2fT09HzbdO/e3UqyzzzzTK75S5cutdHR0bZ69er20KFD2fMnTZpkJdlJkyb5rM27v/vuu89mZmZmz8/MzLS33XablWRnz56dPX/r1q1Wkr311ltztXPrrbdaSbZ+/fp227Zt2fNPnTplO3XqZCXZFStW+D9IOXhrzrsPb63x8fH2v//9b65l/fr1s5LsBx98kGt+586dfR57b22NGjWysbGxdsGCBbmW/fzzz/bMM8+0tWvXtsePH89Xg7/+sdbaTZs25Zt34sQJm5qaamNiYuyOHTtyLevQoYOVZJ977rl82/3666/22LFjAb0fa61NSkqySUlJueY999xzVpK9/PLL7alTp7Ln79692yYlJVlJdunSpdnzvX0syQ4fPjxXW1988UV2W4Hy7uPUqVN25cqV1hhjW7VqZV0uV773tXHjxux5+/fvt4mJifb000+3P/zwQ642v//+e1ulShV7wQUX5Jrv/TncunVrvjo2b95sJdlrr702e9769eutJHvppZdaSfarr77KXnb//fdbSXbRokXZ80pyLB999FGfxydvnz7//PPWGGNTUlLsvn37fG6TV6C/b1u1amUlrbKlmG0ZWgMA8G/POv/DafzZtsS9XZgNHz5cw4cP1+OPP65rr71Wl112may1uv/++/Odcbvzzjt1wQUX5Jq3Y8cOzZ07V2eddVa+4QkdOnRQv379tH//fs2cOTOgelwul8aPH6/atWvrlVdeUXR0dPay6OhovfzyyzLGFOnOOv/4xz901llnZf87JiYme3jPypUrA26nIIMHD9Z5552Xa94dd9xR5H18+umn2rx5swYNGqTOnTvnWnbmmWdq6NCh+uWXX3xeQOqrf7x8jVOvWLGi7r33XmVmZuZqb9WqVVq2bJlatmyphx9+ON923iEtJfHWW2/JGKPRo0crJuaPgQ81a9bUk08+KUmaOHFivu2SkpL0xBNP5JrXo0cPnXXWWcXuywsvvFA33HCD0tPTC/25mjJlin777TeNGDFCf/rTn3ItO+ecc3THHXfou+++09q1awPad8OGDZWcnKy0tLTsv4R5++Kpp55SdHR0rr6ZN2+eqlSponbt2mXPK+6xrFWrVq6/ovjicrl033336eGHH1bv3r311VdfqXr16gG9t0jC0BoAgH9bFhZ/uzDfyWbEiBGS3MNoEhMT1alTJ/3lL3/Rn//853zrtm3bNt+87777TpLUqVMnVahQId/y1NRUTZ06Vd99951uueWWQuvZsGGD9u3bpyZNmuiZZ57xuU7lypW1bl3gX4LatGmTb179+vUlSQcOHAi4nVDsY/ny5ZLcQ0jyXogsKXss9bp16/INr/HVP14//fSTnn/+ec2bN08//fSTjh07lmt5zrH8X3/9tSR3QI6KCv65zEOHDmnTpk2qW7euz4uUU1NTJf3xs5VTy5Ytc32586pfv372sSuOkSNHatasWdlfaP19UfHuY82aNT77Z8OGDZLc/ZM36PuTmpqqt956S6tXr9YFF1yg+fPnq06dOmrfvr1at26dHeR//fVXff/99+revbsqVqwoqWTHskWLFoqNjS2wtr59+2r27NkaNGiQxowZUyo/D6FAkAcA+HfiUGi3CyLvWcBA1K5dO9887zjsOnXq+NzGO/+3334LaB/79u2T5A6s3i8Zvhw+fDig9qQ/xiPn5D1zmZWVFXA7odiH9/1PmzatwPV8vX9f/SNJW7ZsUdu2bXXgwAF16tRJ3bt3V0JCgqKjo5WRkaG3335bJ06cyF7f21d169YNuO6iKMnPjK/jLLmPdd6LoIsiOTlZgwYN0ksvvaSxY8f6/EuE9Ef/TJgwocD2ivLz2a1bN7311luaN2+eWrRooQULFujyyy/PXvbCCy/o4MGDmj9/vqy1ucbHl+RY+vt5yWnRokWKiYlRr169HBviJe5aAwAoSGx8aLcLE18P/fHeu/2XX37xuc2uXbtyrVcY73q9e/cucMzr1q1bi/MWIp73/X/44YcFvn9fQyL8PZRp9OjR2rdvn958800tWLBA48aN09NPP63hw4erR48e+db3huWcZ+mDKdg/M8Hy+OOPq3r16ho5cqT27t3rcx1vTWvWrCmwf2699daA9+s9a/7VV19p9erV2rdvX3ZYT01NVVZWltLS0rLPzHvXz1lPcY5lIA/xSktLU7Vq1dSrVy99+umnAb+nSBO0IG+MqWeMecsYs9MYc8IYk2GMGWOMqRaOdgAAQdCwc+HrBHO7COIdk71kyRJlZmbmW+69+4b3Lh6SsodG+DpT3axZMyUmJurrr7/WqVOnSqPksCvo/bdv316StHjx4qDtz/tk0r59++Zb5r11pK8a5syZE9BZ7oLejy/x8fFq1KiRfv7553y3XZR8/8yEQmJiop588kkdPHjQ71+DitM/hR2f2rVr609/+pMWL16sL774QtIfYT0lJUWxsbGaN2+e5s+fr2rVquW6DqK0j+X555+vhQsXqnr16urTp49mz55drHbCLShB3hjTSNIqSQMlrZT0iqQtkoZIWm6MOT2U7QAAgqRmc/fDnooiqWPYx8cHQ7169XTppZcqIyNDY8aMybVsxYoVeu+991StWjX17t07e/7pp7s/pn766ad87cXExGjQoEHatWuXBg8enG8st+Q+yxjoxYSRqKD3f/XVV6tRo0b65z//qc8++8zn9suXL9fRo0cD3p/3VpB57xE+Z84cnxdBtm7dWh06dNDq1av1/PPP51u+b98+HT9+PPvfBb0ff2677TZZa/X3v/89V8Ddu3dv9q0wb7vttoDbC5a//vWvatSokd54441czzXwGjhwoBITEzVixAifF9e6XK58xzmQ45OamqqjR49q7NixatKkSfbF2ZUrV9ZFF12k//znP9q8ebO6dOmSb4hLaR/L5s2ba9GiRapVq5auu+46ffDBB8VuK1yCNUb+NUk1JQ221r7qnWmMGS3pAUnPSro7hO0AAIKl81D3w54Ku4+8JJkoqfPfS7+mEHn99deVkpKiv//975o7d67atGmTfR/5qKgoTZo0SfHxfwwjuuiiixQXF6cxY8Zo//79qlWrliRp0KBBSkhI0JNPPqk1a9bo9ddf18cff6zU1FTVrVtXe/bs0caNG7V06VI9++yzAV9MGGm6deumadOmqU+fPurZs6cqV66spKQk9e/fXxUqVNDMmTPVo0cPXXHFFerQoYNatmypuLg4bd++Xd988422bNmiXbt2KS4uLqD9/fWvf9WkSZN03XXXqW/fvqpbt66+//57ffHFF7r++ut9BrOpU6eqS5cueuyxxzRjxgx16dJF1lpt3LhRc+fO1fr167O/IBT0fvz529/+ps8//1wffvihWrRooZ49e+ro0aOaNm2a9uzZo6FDh6pjx47FOr4lUbFiRY0cOVLXX3+9tm3blm/56aefrunTp6t3795q3769unXrpnPOOUdRUVH66aeftHz58nxfdLp166YXX3xRd9xxh6699lqddtppSkxM1H333ZdrnfHjx2vPnj3q06dPrn1269Yt+8tB3gdESaE5lo0bN9bixYuVmpqqm2++WSdOnAjo4vVIUeIgb4xpKKm7pAxJ/8yzeJikOyX1N8Y8ZK09UtrtAACCrGEXqdfYwh8KZaKkXuMi9mFQxdGwYUN9++23euaZZ/TZZ59pwYIFqlq1qi677DI9/vjjuvDCC3OtX61aNc2YMUMjRozQpEmTdOSI++Pqz3/+sxISElShQgXNnj1bU6dO1eTJk/XJJ5/o8OHDOuOMM9SgQQM9/fTTuvnmm8PxVoPi9ttv17Zt2/T+++/rhRdeUGZmpjp37pwdfM8//3ytWbNGo0eP1ieffKJJkyYpKipKderU0QUXXKARI0aoRo0aAe/v/PPPV1pamp544gl99tlnyszMVIsWLTRz5kwlJib6DPINGjRQenq6XnjhBc2ePVvjx49XpUqVlJycrIceekg1a9YM+P34UrFiRX355ZcaPXq03nvvPb366quKiYlRixYtNGbMGPXr168IRzS4rrvuOl100UV+74LTrVs3/fe//9VLL72kOXPmaPHixapYsaLOPPNMpaam5hvC1KNHD7388suaMGGCXnnlFZ08eVJJSUm5grz3TLvL5co1Bt67P+9tJPMuk0J3LJOSkrRo0SJ169ZNAwcO1IkTJ7JvsRrpTFGu6vfZgDG3S5og6V/W2rt8LJ8jd0C/xFqb/+awQW6nkFpXtWrVqlXex2oH1fDiXcDickkNT76Xb37GqCtKWhGAcsB7y8LmzUtxSMuWBdLCF933ic8rqaP7THwZCvEA4Eugv29bt26tdPeTzFqXVi3BGFpztme6wc/yjXIH8KaSCgrgwWpHxhh/ST3/jUgBAIFp2MX92rPOfZ/4E4fcd6dp2LlMjIkHAKcJRpD3noI+6Ge5d35iiNpxpOLfIRYAQqxmc4I7AESAUDwQynszz5KN4SlCO/7+hOE5U1+693yqWl/6fXuRN9tp89+Qp25CwU8lAwAAQPkVjNtPes+U+xscXjXPeqXdTnj1zH87q0A8lZX/AQvDrjq3pNUAAACgjApGkP/RM23qZ3kTz9Tf2PdgtxNeza5QUQ/rKWv0latNrnlGUvdzCn/EMAAAAMqnYAT5NM+0uzEmV3vGmHhJKZKOSfo6RO2E36XDA17VWumFzBvzzX/kcq7LBQAAgH8lDvLW2s2S5kpKlnRvnsUjJFWRNMV773djTAVjTDPPU1yL3U5ESxkitbip0NWslaZlXawJWb1yzb+udT3d1bmRn60AAAAQDiW9bXuwBeti179KWiZpnDGmm6R1ktpJ6ir3UJjHc6xb17N8m9yhvbjtRLbe/yfVbCYtekk68Xu+xb/bOL2aeXWuEB9fKUb3dW1MiAdQZMYYWWvlcrnyPeYcABAc3iBvjClkzdAISpC31m42xrSR9JSkyyT1lLRL0jhJI6y1+0PZTsRIGeJ+rf9UWv2+dOKgFJsgtbxRX2e11vb0HUo5nqn4SjHq06oeY+IBFFtsbKyOHz+uI0eOKD4+PtzlAECZ5H1ac2xsZNxZMGi3n7TWbpc0MID1MvTHrSSL3Y6jNLvCcxHsH7qLi1kBBE98fLyOHz+uX375RZJUpUoVGWMi5qwRADiVtVbWWh05ciT7d2yknDAJxX3kAQClrHr16jpy5IiOHj2qHTt2hLscACiz4uLiVL169XCXIYkgDwBlQlRUlOrXr6/9+/fr0KFDOnHiRMRdlAUATmWMUWxsrOLj41W9evWIuRaJIA8AZURUVJRq1KihGjVqhLsUAEAIRMbXCQAAAABFQpAHAAAAHIggDwAAADgQQR4AAABwIII8AAAA4EAEeQAAAMCBCPIAAACAA5ny9MAQY8y+ypUrV2/evHm4SwEAAEAZtm7dOh07dmy/tfb00tpHeQvyWyVVlZRRirtp5pmuL8V9oOToJ2egn5yBfnIG+skZ6KfIF2gfJUv63VrboLQKKVdBPhSMMaskyVrbOty1wD/6yRnoJ2egn5yBfnIG+inyRVIfMUYeAAAAcCCCPAAAAOBABHkAAADAgQjyAAAAgAMR5AEAAAAH4q41AAAAgANxRh4AAABwIII8AAAA4EAEeQAAAMCBCPIAAACAAxHkAQAAAAciyAMAAAAORJAHAAAAHIggHyTGmHrGmLeMMTuNMSeMMRnGmDHGmGrhrq08Mcacboy53RgzyxizyRhzzBhz0BizxBjzF2OMz595Y0wHY8xnxpj9xpijxpj/GmPuN8ZEh/o9lFfGmP7GGOt53e5nHfopTIwxnYwxM4wxuzy/43YZY+YaY3r6WJd+CjFjzBWe/tjh+b23xRgzzRhzkZ/16aNSYoy51hjzqjFmsTHmd8/vtKmFbFPk/jDG3GqMWWmMOez5nFtgjLky+O+obCpKPxljmhhjHjbGzDfGbDfGnDTG7DbGfGiM6VrIfkq1n3ggVBAYYxpJWiappqQPJa2X1FZSV0k/Skqx1u4LX4XlhzHmbkn/J2mXpDRJP0mqJamPpARJMyRdZ3P84BtjrvbMPy7pA0n7JfWSdLak6dba60L5HsojY0x9Sf+TFC3pNEl3WGsn5lmHfgoTY8wTkp6WtFfSJ3L//1VD0gWS0qy1Q3OsSz+FmDHmeUlDJe2TNFvufmos6SpJMZJusdZOzbE+fVSKjDGrJbWQdFjSDknNJL1rrf2zn/WL3B/GmJckPeRpf7qkipJulFRd0iBr7fjgvquypyj9ZIx5X9INktZKWiJ3H50t9/9j0ZKGWGvH+diu9PvJWsurhC9JcyRZT6fknD/aM//1cNdYXl6SUuX+BRiVZ35tuUO9ldQ3x/yqkvZIOiGpTY75leT+cmYl3Rju91WWX5KMpK8kbZb0oueY355nHfopfP1znef4fikp3sfyCvRTWPuntqQsSb9IqplnWVfPMd9CH4W0T7pKauL53dbFc0yn+lm3yP0hqYNn/iZJ1XLMT5b7y9xxScnhPg6R/ipiPw2QdIGP+Z0lnfT0X51w9BNDa0rIGNNQUndJGZL+mWfxMElHJPU3xlQJcWnlkrV2vrX2Y2utK8/8XyS97vlnlxyLrpV0hqT3rbXf5lj/uKQnPP+8p/QqhqTBcn8BGyj3/y++0E9h4BmK9ryko5JustYeyruOtfZUjn/ST6GXJPcw2RXW2j05F1hr0yQdkrtPvOijUmatTbPWbrSe1FaI4vTH3Z7ps9baAzm2yZA7h8TK/fsUBShKP1lrJ1trv/Mxf6GkBXKfae+QZ3FI+okgX3KpnulcH+HxkKSlkuIktQ91YcjHGzgyc8zz9t8XPtZfJHeA6WCMiS3NwsorY0xzSaMkjbXWLipgVfopPDpIaiDpM0kHPOOwHzbGDPEz9pp+Cr2Ncp8RbGuMqZFzgTHmYknxcv/Fy4s+iizF6Y+Ctvk8zzoofb6yhRSifiLIl9zZnukGP8s3eqZNQ1AL/DDGxEi6xfPPnP9T+e0/a22mpK1yjzFtWKoFlkOePnlH7iFPjxWyOv0UHhd6prslpcs9Pn6UpDGSlhljFhpjcp7tpZ9CzFq7X9LDcl8LtNYY8y9jzEhjzH8kzZV7SNRdOTahjyJLkfrD89f9upIOW2t3+WiPzBFCxpgkSd3k/sK1KMf8kPVTTEkbgBI804N+lnvnJ5Z+KSjAKEnnSvrMWjsnx3z6L3z+IffFkh2ttccKWZd+Co+anundcgeKSyStkHs4x8uSekiapj+Gq9FPYWCtHWOMyZD0lqQ7cizaJGlyniE39FFkKWp/0H8RwvNXknflHiIzNOfwGYWwnzgjX/qMZ8rtgcLEGDNY7qvG10vqX9TNPVP6L4iMMW3lPgv/srV2eTCa9Ezpp+Dy3vrOSLrWWjvPWnvYWvuDpN5y34mhs79bHPpAP5UCY8xQue+IMVlSI0lVJLWWtEXSu8aYF4rSnGdKH0WG4vYH/VeKPLcFfUdSitx3GnqpmE2VuJ8I8iXn/VaV4Gd51TzrIYSMMfdKGiv3LaO6ev4MnRP9F2I5htRskPRkgJvRT+HhPcO0xVq7JucCz19RvH/dauuZ0k8hZozpIvcFyR9Zax+01m6x1h611qbL/WXrZ0kPeW7MINFHkaao/VHY+oWdCUYJeUL8VLnv6PUfSX/2ccFsyPqJIF9yP3qm/sY5NfFM/Y2hRykxxtwvabyk7+UO8b/4WM1v/3kCZwO5L2DZUkpllkenyX28m0s6bv54CJSV+05PkjTBM2+M59/0U3h4j/tvfpZ7g37lPOvTT6HjfbBMWt4F1tqjklbK/Vl/gWc2fRRZitQf1tojcn85O80YU8dHe2SOUuTpk3/LfS/49+S+m1fei1xD2k8E+ZLz/vLsbvI8NdQYEy/3n12OSfo61IWVZ8aYhyW9Imm13CF+j59V53uml/lYdrHcdxxaZq09EfQiy68Tkt708/Le3muJ59/eYTf0U3gskjtENDHGVPSx/FzPNMMzpZ9Cz3s3kzP8LPfOP+mZ0keRpTj9UdA2l+dZB0Hi+R04Xe4z8VMk9bfWZhWwSWj6qbRutF+eXuKBUBH1knu4hpX0raTqhaxbVdKv4uEoEfGSNFz+HwhFP4WnT6Z6ju8zeeZfKskl99n6RPopbP1zvee4/iKpbp5ll3v66Jik0+mjsPRPFxX+QKgi9Yd4IFQ4+ilW0qeedSYqz0Mn/WwTkn4ynkZRAsaYRnL/D1dT0oeS1klqJ/dTwzZI6mCt3Re+CssPY8ytcl/wlSXpVfkef5ZhrZ2cY5tr5P6WfVzS+3I/evkqeR6PLel6y/8oIWGMGS738Jo7rLUT8yy7RvRTyBljasr9PIzGkhbLPVQjSe7x11buPy1Py7H+NaKfQsbzl+A5ct9R6JCkWXKH+uZyD7sxku631o7Nsc01oo9Kjef4XuP5Z2257+60Re7/fyRpr7X2b3nWL1J/GGNelvSg3BecT5f7gUQ3SDpd7pOK44P/zsqWovSTMWaS3E933SvpNfm+SHWBtXZBnn2Ufj+F+1tQWXlJqi9pkqRdcv8Jc5vcF1kWeEaYV9D7Ybjnf7CCXgt8bJciz0Nv5D579T9JD0iKDvd7Kk8v+TkjTz+FvV+qy/0Xxq2e32/75D5p0Z5+Cv9LUgVJ98s9hPN3uYdD7ZH7vv/d6aOQ90dhn0MZwegPSbdK+kbuJ2IfkrRQ0pXhfv9OeRWln+R+emth2WJ4OPqJM/IAAACAA3GxKwAAAOBABHkAAADAgQjyAAAAgAMR5AEAAAAHIsgDAAAADkSQBwAAAByIIA8AAAA4EEEeAAAAcCCCPAAAAOBABHkAAADAgQjyAAAAgAMR5AEAAAAHIsgDAAAADkSQBwAAAByIIA8AAAA4EEEeAAAAcCCCPAAAAOBA/w/oCayoBFpM2wAAAABJRU5ErkJggg==\\n\"}}]}}, \"7afbde8d5d4f4dba8e160f3a998779ad\": {\"model_name\": \"LayoutModel\", \"model_module\": \"@jupyter-widgets/base\", \"model_module_version\": \"1.2.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/base\", \"_model_module_version\": \"1.2.0\", \"_model_name\": \"LayoutModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"LayoutView\", \"align_content\": null, \"align_items\": null, \"align_self\": null, \"border\": null, \"bottom\": null, \"display\": null, \"flex\": null, \"flex_flow\": null, \"grid_area\": null, \"grid_auto_columns\": null, \"grid_auto_flow\": null, \"grid_auto_rows\": null, \"grid_column\": null, \"grid_gap\": null, \"grid_row\": null, \"grid_template_areas\": null, \"grid_template_columns\": null, \"grid_template_rows\": null, \"height\": null, \"justify_content\": null, \"justify_items\": null, \"left\": null, \"margin\": null, \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"object_fit\": null, \"object_position\": null, \"order\": null, \"overflow\": null, \"overflow_x\": null, \"overflow_y\": null, \"padding\": null, \"right\": null, \"top\": null, \"visibility\": null, \"width\": null}}, \"ba3939632fa041be9152e920f7da4a9b\": {\"model_name\": \"SliderStyleModel\", \"model_module\": \"@jupyter-widgets/controls\", \"model_module_version\": \"1.5.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/controls\", \"_model_module_version\": \"1.5.0\", \"_model_name\": \"SliderStyleModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"StyleView\", \"description_width\": \"\", \"handle_color\": null}}, \"33b18a2e103f4bed8eb2b55964b6f954\": {\"model_name\": \"FloatSliderModel\", \"model_module\": \"@jupyter-widgets/controls\", \"model_module_version\": \"1.5.0\", \"state\": {\"_dom_classes\": [], \"_model_module\": \"@jupyter-widgets/controls\", \"_model_module_version\": \"1.5.0\", \"_model_name\": \"FloatSliderModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/controls\", \"_view_module_version\": \"1.5.0\", \"_view_name\": \"FloatSliderView\", \"continuous_update\": true, \"description\": \"p\", \"description_tooltip\": null, \"disabled\": false, \"layout\": \"IPY_MODEL_7afbde8d5d4f4dba8e160f3a998779ad\", \"max\": 0.1, \"min\": 0.0, \"orientation\": \"horizontal\", \"readout\": true, \"readout_format\": \".2f\", \"step\": 0.001, \"style\": \"IPY_MODEL_ba3939632fa041be9152e920f7da4a9b\", \"value\": 0.1}}, \"14b6c84e418f419aba299d59cc8c1885\": {\"model_name\": \"LayoutModel\", \"model_module\": \"@jupyter-widgets/base\", \"model_module_version\": \"1.2.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/base\", \"_model_module_version\": \"1.2.0\", \"_model_name\": \"LayoutModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"LayoutView\", \"align_content\": null, \"align_items\": null, \"align_self\": null, \"border\": null, \"bottom\": null, \"display\": null, \"flex\": null, \"flex_flow\": null, \"grid_area\": null, \"grid_auto_columns\": null, \"grid_auto_flow\": null, \"grid_auto_rows\": null, \"grid_column\": null, \"grid_gap\": null, \"grid_row\": null, \"grid_template_areas\": null, \"grid_template_columns\": null, \"grid_template_rows\": null, \"height\": null, \"justify_content\": null, \"justify_items\": null, \"left\": null, \"margin\": null, \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"object_fit\": null, \"object_position\": null, \"order\": null, \"overflow\": null, \"overflow_x\": null, \"overflow_y\": null, \"padding\": null, \"right\": null, \"top\": null, \"visibility\": null, \"width\": null}}, \"3ee97d640e0b4782a0df7124e47ca031\": {\"model_name\": \"VBoxModel\", \"model_module\": \"@jupyter-widgets/controls\", \"model_module_version\": \"1.5.0\", \"state\": {\"_dom_classes\": [\"widget-interact\"], \"_model_module\": \"@jupyter-widgets/controls\", \"_model_module_version\": \"1.5.0\", \"_model_name\": \"VBoxModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/controls\", \"_view_module_version\": \"1.5.0\", \"_view_name\": \"VBoxView\", \"box_style\": \"\", \"children\": [\"IPY_MODEL_33b18a2e103f4bed8eb2b55964b6f954\", \"IPY_MODEL_50ad2676ee0446418057a2e4e66b93dd\"], \"layout\": \"IPY_MODEL_14b6c84e418f419aba299d59cc8c1885\"}}, \"01ad7a53d77b47bfb92494396f88b77c\": {\"model_name\": \"LayoutModel\", \"model_module\": \"@jupyter-widgets/base\", \"model_module_version\": \"1.2.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/base\", \"_model_module_version\": \"1.2.0\", \"_model_name\": \"LayoutModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"LayoutView\", \"align_content\": null, \"align_items\": null, \"align_self\": null, \"border\": null, \"bottom\": null, \"display\": null, \"flex\": null, \"flex_flow\": null, \"grid_area\": null, \"grid_auto_columns\": null, \"grid_auto_flow\": null, \"grid_auto_rows\": null, \"grid_column\": null, \"grid_gap\": null, \"grid_row\": null, \"grid_template_areas\": null, \"grid_template_columns\": null, \"grid_template_rows\": null, \"height\": null, \"justify_content\": null, \"justify_items\": null, \"left\": null, \"margin\": null, \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"object_fit\": null, \"object_position\": null, \"order\": null, \"overflow\": null, \"overflow_x\": null, \"overflow_y\": null, \"padding\": null, \"right\": null, \"top\": null, \"visibility\": null, \"width\": null}}, \"50ad2676ee0446418057a2e4e66b93dd\": {\"model_name\": \"OutputModel\", \"model_module\": \"@jupyter-widgets/output\", \"model_module_version\": \"1.0.0\", \"state\": {\"_dom_classes\": [], \"_model_module\": \"@jupyter-widgets/output\", \"_model_module_version\": \"1.0.0\", \"_model_name\": \"OutputModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/output\", \"_view_module_version\": \"1.0.0\", \"_view_name\": \"OutputView\", \"layout\": \"IPY_MODEL_01ad7a53d77b47bfb92494396f88b77c\", \"msg_id\": \"\", \"outputs\": [{\"output_type\": \"display_data\", \"metadata\": {\"image/png\": {\"width\": 372, \"height\": 263}, \"needs_background\": \"light\"}, \"data\": {\"text/plain\": \"<Figure size 432x288 with 1 Axes>\", \"image/png\": \"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zz7T8ePHixzvDnjZ1EUbXA3nxkhVK8dpUIeT9ODQ9rnLB5zWUANOC/5XMOTnpXnQkde7Y6RXgs8TXC5MJan+qdKl/5Fu+lI6b4rU9x7f/U1fSneska7+SLrgYemcidLvJvrGcJ99A2HbA1o1SFLXZnVKtY+X538trfj4eF1xxRXKzs4uNG7566+/1muvvVZon9TUVLVu3Vqff/65Zs6cmW/dzJkz9emnn6pVq1a5s6ls2rRJK1euLFRn7969Onr0aNCTR8tixIgRateunT755BOlpfkmtxo0aJBatGihf/zjH/rwww+D7vfFF1/o0KHwx5jGxcXpuuuu048//qirr75aknTDDTeEXTc5OTn3RNARI0bovffeC7rdoUOHdOzYsVLXDwwfKviF66OPPtKLL75Y7L6TJ0/ONx7/yJEjGj9+vCRp9Gj+oIvIsXZXtro/ON+VYS3dW9TVhItO1bw/9dKmBy7Uqsnn5wvnKB2OoHvRiwOkbUvK9zFMvFS/lVS7hdThUqnNhfnXE7ojzm39T9HIfy0JaapFL83/WtyVRC+++GJ16NAhpDp///vfNX/+fD3xxBP6+uuvc+dBnzFjhi644AK9++67+bY3xujll1/WOeeco0suuUSDBg1SmzZttGbNGs2ePVtJSUl65ZVXFBfnO46xYsUKDR48WJ07d9bpp5+uk046ST/99JPmzJmjY8eO5Y5JD5cxRpMmTdLgwYN19913a/HixYqPj9fbb7+tc889VxdeeKG6d++uDh06KDExUVu3btXSpUu1ceNG7dixQ4mJiWH38Mc//lH33Xeftm/frjPOOCPoNJVlMWrUKB09elRjxozRwIED1bZtW6Wmpqp+/fo6cOCAtm3bpnnz5unAgQPq2bNnqWrfdNNNmjZtmoYPH66hQ4eqUaNG+u677zR37lyNGDFCM2bMKHLftm3b6rTTTss3D/qGDRt04YUXFjqyDnhRcVeQLm+RMitKpCGge827Y8o3nHe8Uhr0dMnbIeKktqynB4acEfI0VF75MC1qmkXJd1Q01IBer149paen669//avee+89ff3112rdurX++c9/KiUlpVBAl6SzzjpLS5cu1d/+9jd98skneu+991SvXj1ddtlluvfee9W6devcbbt06aLx48dr0aJFmjt3rvbu3asTTjhBnTt31pgxY3T++eeX+rkX5eKLL1bn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WGtt06ZNbdOmTfMt+/vf/24l2fPPP98eO3Ysd/muXbts06ZNrSSbnp6euzzwGkuyEydOzFdr7ty5ubVCFXiMY8eO2a+++soaY2ynTp1sTk5Ooee1bt263GVZWVm2Vq1atm7dunblypX5an733Xe2evXqtmPHjvmWB96HmzZtKtTHhg0brCQ7bNiw3GWrV6+2kuw555xjJdlPPvkkd93tt99uJdlPP/00d1k4v8vx48cH/f0UfE2nTJlijTE2NTXV7tmzJ+g+BZXr5205mvb5Rtv0rvfDvj23sPD/51CxOnXqZCUts2XIrAxxiWQdL3e7A3jFj6uKHtZSlM2f+/Zz2cSJEzVx4kTdfffdGjZsmM477zxZa3X77bcXOkJ23XXXqWPHjvmWbdu2TfPmzdPJJ59caJhA9+7dddlllykrK0tvv/12SP3k5OTomWeeUcOGDfX444+rUqVKuesqVaqkRx99VMaYUs0083//9386+eSTc3+uXLly7jCbr776KuQ6xRkzZozOOOOMfMuuvfbaUj/GBx98oA0bNujWW29V7975Z3046aSTNHbsWO3cuTPoiZfBXp+AYOPAq1SpoptvvlnHjx/PV2/ZsmVavHixOnTooLvuuqvQfoGhJeF46aWXZIzRY489psqVf/tjcv369XXvvfdKkl588cVC+zVt2lT33HNPvmXnnnuuTj755DK/lmeeeaYuueQSZWRklPi+euWVV7Rv3z5NmjRJp556ar51p512mq699lp98803+v7770N67ObNmyslJUVpaWm5f7kKvBb33XefKlWqlO+1mT9/vqpXr66zzjord1lZf5cNGjTI91ePYHJycnTLLbforrvu0uDBg/XJJ5+oTp06IT23SPX0gnUlbxQCplSMbAxxiWSDnna7A3jFxkVl38/lmV0mTfKdj2GMUa1atdSzZ09dc801+sMf/lBo265dC5/o9M0330iSevbsqfj4+ELr+/Xrp1dffVXffPONrrzyyhL7Wbt2rfbs2aNTTjlFf/vb34JuU61aNa1aFfqXmy5duhRa1qRJE0nS3r17Q65TEY/xxRdfSPIN5Sh4Aq+k3LHKq1atKjTMJdjrE7BlyxZNmTJF8+fP15YtW3T4cP4rI+YdK//ll19K8gXfuDjnjyNlZ2dr/fr1atSoUdCTe/v16yfpt/dWXh06dMj3pS2gSZMmub+7snjggQf0zjvv5H5RLeoLSOAxVqxYEfT1Wbt2rSTf61MwwBelX79+eumll7R8+XJ17NhRCxYs0Iknnqizzz5bnTt3zg3oP/30k7777jsNGDBAVapUkRTe77J9+/ZKSEgotrehQ4dq9uzZuvXWW/XEE0+Uy/vBa/YcPOZ2C/AAAnqkOqmz2x3AS45mV+x+DgoctQtFw4aFL1EdGOd84oknBt0nsHzfvn0hPcaePXsk+YJo4MtDMAcOHAipnvTbeN+8Akcaf/3115DrVMRjBJ7/W2+9Vex2wZ5/sNdHkjZu3KiuXbtq79696tmzpwYMGKDk5GRVqlRJmZmZevnll3X06NHc7QOvVaNGjULuuzTCec8E+z1Lvt91wZOHSyMlJUW33nqrHnnkET355JNB/3Ig/fb6vPDCC8XWK837s3///nrppZc0f/58tW/fXgsXLtT555+fu+6hhx7S/v37tWDBAllr840/D+d3WdT7Ja9PP/1UlStX1kUXXRQT4fwvby53pE6j5OK/+MD7ov/dHo0S60nXOXNiGaJEQlLF7ueSYBejCcw9vnPnzqD77NixI992JQlsN3jw4GLHB27aFJ3XMAg8/zlz5hT7/IMNTSjqYkGPPfaY9uzZo3/9619auHChnnrqKU2ePFkTJ07UueeeW2j7QAjOe1TdSU6/Z5xy9913q06dOnrggQe0e/fuoNsEelqxYkWxr8+oUaNCftzAUe5PPvlEy5cv1549e3JDeL9+/fTrr78qLS0t90h6YPu8/ZTldxnKxaXS0tJUu3ZtXXTRRfrggw9Cfk6RaOqiDZqV4cx7fsLA0x2pA/cQ0CPR2A1udwCvaV7GK8SVdT8PCYx5/vzzz3X8+PFC6wOzUQRmtZCUO0Qh2JHlNm3aqFatWvryyy917Fh0/qm5uOd/9tlnS5I+++wzxx4vcCXMoUOHFloXmCIxWA8fffRRSEeli3s+wSQlJalFixbavn17oekFpeDvmYpQq1Yt3Xvvvdq/f3+Rf70py+tT0u+nYcOGOvXUU/XZZ59p7ty5kn4L4ampqUpISND8+fO1YMEC1a5dO995BuX9u2zXrp0WLVqkOnXqaMiQIZo9e3aZ6kSCB/672pE6RtKA00r+6wS8jYAORIP6bX0XISqNpj1cH3/uhMaNG+ucc85RZmamnnjiiXzrlixZov/85z+qXbu2Bg8enLu8bt26knzjoguqXLmybr31Vu3YsUNjxowpNFZa8h0VDPUkPC8q7vkPGjRILVq00D/+8Q99+OGHQff/4osvdOjQoZAfLzDlYcE5rj/66KOgJw927txZ3bt31/LlyzVlypRC6/fs2aMjR367wmJxz6coV199tay1uvPOO/MF1927d+dO+Xj11VeHXM8pN910k1q0aKGpU6fmm5c/YPTo0apVq5YmTZoU9KTUnJycQr/nUH4//fr106FDh/Tkk0/qlFNOyT2puVq1aurWrZvefPNNbdiwQX369Ck01KS8f5dt27bVp59+qgYNGmj48OGaMWNGmWt5Vb+H0xyrNe58LpoWDRiDDkSL3mN9FyEqaR50STJxUu87y7+nCvLcc88pNTVVd955p+bNm6cuXbrkzoMeFxenadOmKSnpt+E83bp1U2Jiop544gllZWWpQYMGkqRbb71VycnJuvfee7VixQo999xzeu+999SvXz81atRIP/74o9atW6f09HTdf//9IZ+E5zX9+/fXW2+9pSFDhuiCCy5QtWrV1LRpU40cOVLx8fF6++23de655+rCCy9U9+7d1aFDByUmJmrr1q1aunSpNm7cqB07digxMTGkx7vppps0bdo0DR8+XEOHDlWjRo303Xffae7cuRoxYkTQwPXqq6+qT58++utf/6pZs2apT58+stZq3bp1mjdvnlavXp0b/It7PkW544479N///ldz5sxR+/btdcEFF+jQoUN666239OOPP2rs2LHq0aNHmX6/4ahSpYoeeOABjRgxQps3by60vm7dupo5c6YGDx6ss88+W/3799dpp52muLg4bdmyRV988UWhLzD9+/fXww8/rGuvvVbDhg1TjRo1VKtWLd1yyy35tnnmmWf0448/asiQIfkes3///rmhv+CFi6SK+V22bNlSn332mfr166crrrhCR48eDemk70gwfta32rgn9C+8xRneuTGzt0QJAjoQLZr3kS56suSLFZk46aKnPHuRorJo3ry5vv76a/3tb3/Thx9+qIULF6pmzZo677zzdPfdd+vMM8/Mt33t2rU1a9YsTZo0SdOmTdPBgwclSX/4wx+UnJys+Ph4zZ49W6+++qqmT5+u999/XwcOHNAJJ5ygZs2aafLkybriiivceKqO+OMf/6jNmzfrjTfe0EMPPaTjx4+rd+/euYG2Xbt2WrFihR57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\\n\"}}]}}, \"23b177b0cb0b45d4b4bfbf36c1f720d7\": {\"model_name\": \"LayoutModel\", \"model_module\": \"@jupyter-widgets/base\", \"model_module_version\": \"1.2.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/base\", \"_model_module_version\": \"1.2.0\", \"_model_name\": \"LayoutModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"LayoutView\", \"align_content\": null, \"align_items\": null, \"align_self\": null, \"border\": null, \"bottom\": null, \"display\": null, \"flex\": null, \"flex_flow\": null, \"grid_area\": null, \"grid_auto_columns\": null, \"grid_auto_flow\": null, \"grid_auto_rows\": null, \"grid_column\": null, \"grid_gap\": null, \"grid_row\": null, \"grid_template_areas\": null, \"grid_template_columns\": null, \"grid_template_rows\": null, \"height\": null, \"justify_content\": null, \"justify_items\": null, \"left\": null, \"margin\": null, \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"object_fit\": null, \"object_position\": null, \"order\": null, \"overflow\": null, \"overflow_x\": null, \"overflow_y\": null, \"padding\": null, \"right\": null, \"top\": null, \"visibility\": null, \"width\": null}}, \"34113cf945a04b189886b2c847785cbc\": {\"model_name\": \"ProgressStyleModel\", \"model_module\": \"@jupyter-widgets/controls\", \"model_module_version\": \"1.5.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/controls\", \"_model_module_version\": \"1.5.0\", \"_model_name\": \"ProgressStyleModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"StyleView\", \"bar_color\": null, \"description_width\": \"\"}}, \"09848e34af634b95a86b940f0c097d0b\": {\"model_name\": \"FloatProgressModel\", \"model_module\": \"@jupyter-widgets/controls\", \"model_module_version\": \"1.5.0\", \"state\": {\"_dom_classes\": [], \"_model_module\": \"@jupyter-widgets/controls\", \"_model_module_version\": \"1.5.0\", \"_model_name\": \"FloatProgressModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/controls\", \"_view_module_version\": \"1.5.0\", \"_view_name\": \"ProgressView\", \"bar_style\": \"success\", \"description\": \"\", \"description_tooltip\": null, \"layout\": \"IPY_MODEL_23b177b0cb0b45d4b4bfbf36c1f720d7\", \"max\": 100.0, \"min\": 0.0, \"orientation\": \"horizontal\", \"style\": \"IPY_MODEL_34113cf945a04b189886b2c847785cbc\", \"value\": 100.0}}, \"12b0cdcfbb584e8eba4140c8309479f1\": {\"model_name\": \"LayoutModel\", \"model_module\": \"@jupyter-widgets/base\", \"model_module_version\": \"1.2.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/base\", \"_model_module_version\": \"1.2.0\", \"_model_name\": \"LayoutModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"LayoutView\", \"align_content\": null, \"align_items\": null, \"align_self\": null, \"border\": null, \"bottom\": null, \"display\": null, \"flex\": null, \"flex_flow\": null, \"grid_area\": null, \"grid_auto_columns\": null, \"grid_auto_flow\": null, \"grid_auto_rows\": null, \"grid_column\": null, \"grid_gap\": null, \"grid_row\": null, \"grid_template_areas\": null, \"grid_template_columns\": null, \"grid_template_rows\": null, \"height\": null, \"justify_content\": null, \"justify_items\": null, \"left\": null, \"margin\": null, \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"object_fit\": null, \"object_position\": null, \"order\": null, \"overflow\": null, \"overflow_x\": null, \"overflow_y\": null, \"padding\": null, \"right\": null, \"top\": null, \"visibility\": null, \"width\": null}}, \"6c270123ee254b159c45605a5ac865db\": {\"model_name\": \"DescriptionStyleModel\", \"model_module\": \"@jupyter-widgets/controls\", \"model_module_version\": \"1.5.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/controls\", \"_model_module_version\": \"1.5.0\", \"_model_name\": \"DescriptionStyleModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"StyleView\", \"description_width\": \"\"}}, \"9b97e25a5de244deb5f14f39f45c6462\": {\"model_name\": \"HTMLModel\", \"model_module\": \"@jupyter-widgets/controls\", \"model_module_version\": \"1.5.0\", \"state\": {\"_dom_classes\": [], \"_model_module\": \"@jupyter-widgets/controls\", \"_model_module_version\": \"1.5.0\", \"_model_name\": \"HTMLModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/controls\", \"_view_module_version\": \"1.5.0\", \"_view_name\": \"HTMLView\", \"description\": \"\", \"description_tooltip\": null, \"layout\": \"IPY_MODEL_12b0cdcfbb584e8eba4140c8309479f1\", \"placeholder\": \"\\u200b\", \"style\": \"IPY_MODEL_6c270123ee254b159c45605a5ac865db\", \"value\": \"100%\"}}, \"016fc318ad244a9bbb74e10f3b52c083\": {\"model_name\": \"LayoutModel\", \"model_module\": \"@jupyter-widgets/base\", \"model_module_version\": \"1.2.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/base\", \"_model_module_version\": \"1.2.0\", \"_model_name\": \"LayoutModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"LayoutView\", \"align_content\": null, \"align_items\": null, \"align_self\": null, \"border\": null, \"bottom\": null, \"display\": null, \"flex\": null, \"flex_flow\": null, \"grid_area\": null, \"grid_auto_columns\": null, \"grid_auto_flow\": null, \"grid_auto_rows\": null, \"grid_column\": null, \"grid_gap\": null, \"grid_row\": null, \"grid_template_areas\": null, \"grid_template_columns\": null, \"grid_template_rows\": null, \"height\": null, \"justify_content\": null, \"justify_items\": null, \"left\": null, \"margin\": null, \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"object_fit\": null, \"object_position\": null, \"order\": null, \"overflow\": null, \"overflow_x\": null, \"overflow_y\": null, \"padding\": null, \"right\": null, \"top\": null, \"visibility\": null, \"width\": null}}, \"091115de01f742ae8eb17466596bba96\": {\"model_name\": \"DescriptionStyleModel\", \"model_module\": \"@jupyter-widgets/controls\", \"model_module_version\": \"1.5.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/controls\", \"_model_module_version\": \"1.5.0\", \"_model_name\": \"DescriptionStyleModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"StyleView\", \"description_width\": \"\"}}, \"ba872c5ed8ad4f39be4ad24057fc5724\": {\"model_name\": \"HTMLModel\", \"model_module\": \"@jupyter-widgets/controls\", \"model_module_version\": \"1.5.0\", \"state\": {\"_dom_classes\": [], \"_model_module\": \"@jupyter-widgets/controls\", \"_model_module_version\": \"1.5.0\", \"_model_name\": \"HTMLModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/controls\", \"_view_module_version\": \"1.5.0\", \"_view_name\": \"HTMLView\", \"description\": \"\", \"description_tooltip\": null, \"layout\": \"IPY_MODEL_016fc318ad244a9bbb74e10f3b52c083\", \"placeholder\": \"\\u200b\", \"style\": \"IPY_MODEL_091115de01f742ae8eb17466596bba96\", \"value\": \" 100/100 [00:20&lt;00:00, 4.96it/s]\"}}, \"11fd0bbc7dc54811a88c7d88705153f6\": {\"model_name\": \"LayoutModel\", \"model_module\": \"@jupyter-widgets/base\", \"model_module_version\": \"1.2.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/base\", \"_model_module_version\": \"1.2.0\", \"_model_name\": \"LayoutModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"LayoutView\", \"align_content\": null, \"align_items\": null, \"align_self\": null, \"border\": null, \"bottom\": null, \"display\": null, \"flex\": null, \"flex_flow\": null, \"grid_area\": null, \"grid_auto_columns\": null, \"grid_auto_flow\": null, \"grid_auto_rows\": null, \"grid_column\": null, \"grid_gap\": null, \"grid_row\": null, \"grid_template_areas\": null, \"grid_template_columns\": null, \"grid_template_rows\": null, \"height\": null, \"justify_content\": null, \"justify_items\": null, \"left\": null, \"margin\": null, \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"object_fit\": null, \"object_position\": null, \"order\": null, \"overflow\": null, \"overflow_x\": null, \"overflow_y\": null, \"padding\": null, \"right\": null, \"top\": null, \"visibility\": null, \"width\": null}}, \"da4ded8cd54a4191adf92cb7e70cce31\": {\"model_name\": \"HBoxModel\", \"model_module\": \"@jupyter-widgets/controls\", \"model_module_version\": \"1.5.0\", \"state\": {\"_dom_classes\": [], \"_model_module\": \"@jupyter-widgets/controls\", \"_model_module_version\": \"1.5.0\", \"_model_name\": \"HBoxModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/controls\", \"_view_module_version\": \"1.5.0\", \"_view_name\": \"HBoxView\", \"box_style\": \"\", \"children\": [\"IPY_MODEL_9b97e25a5de244deb5f14f39f45c6462\", \"IPY_MODEL_09848e34af634b95a86b940f0c097d0b\", \"IPY_MODEL_ba872c5ed8ad4f39be4ad24057fc5724\"], \"layout\": \"IPY_MODEL_11fd0bbc7dc54811a88c7d88705153f6\"}}}, \"version_major\": 2, \"version_minor\": 0}","title":"Chapter 11: Statistical Inference"},{"location":"04-advanced/03-stats/#introduction","text":"from IPython.display import YouTubeVideo YouTubeVideo ( id = \"P-0CJpO3spg\" , width = \"100%\" ) In this chapter, we are going to take a look at how to perform statistical inference on graphs.","title":"Introduction"},{"location":"04-advanced/03-stats/#statistics-refresher","text":"Before we can proceed with statistical inference on graphs, we must first refresh ourselves with some ideas from the world of statistics. Otherwise, the methods that we will end up using may seem a tad weird , and hence difficult to follow along. To review statistical ideas, let's set up a few statements and explore what they mean.","title":"Statistics refresher"},{"location":"04-advanced/03-stats/#we-are-concerned-with-models-of-randomness","text":"As with all things statistics, we are concerned with models of randomness. Here, probability distributions give us a way to think about random events and how to assign credibility points to them.","title":"We are concerned with models of randomness"},{"location":"04-advanced/03-stats/#in-an-abstract-fashion","text":"The supremely abstract way of thinking about a probability distribution is that it is the space of all possibilities of \"stuff\" with different credibility points distributed amongst each possible \"thing\".","title":"In an abstract fashion..."},{"location":"04-advanced/03-stats/#more-concretely-the-coin-flip","text":"A more concrete example is to consider the coin flip. Here, the space of all possibilities of \"stuff\" is the set of \"heads\" and \"tails\". If we have a fair coin, then we have 0.5 credibility points distributed to each of \"heads\" and \"tails\".","title":"More concretely: the coin flip"},{"location":"04-advanced/03-stats/#another-example-dice-rolls","text":"Another concrete example is to consider the six-sided dice. Here, the space of all possibilities of \"stuff\" is the set of numbers in the range [1, 6] [1, 6] . If we have a fair dice, then we have 1/6 credibility points assigned to each of the numbers. (Unfair dice will have an unequal distribution of credibility points across each face.)","title":"Another example: dice rolls"},{"location":"04-advanced/03-stats/#a-graph-based-example-social-networks","text":"If we receive an undirected social network graph with 5 nodes and 6 edges, we have to keep in mind that this graph with 6 edges was merely one of 15 \\choose 6 15 \\choose 6 ways to construct 5 node, 6 edge graphs. (15 comes up because there are 15 edges that can be constructed in a 5-node undirected graph.)","title":"A graph-based example: social networks"},{"location":"04-advanced/03-stats/#hypothesis-testing","text":"A commonplace task in statistical inferences is calculating the probability of observing a value or something more extreme under an assumed \"null\" model of reality. This is what we commonly call \"hypothesis testing\", and where the oft-misunderstood term \"p-value\" shows up.","title":"Hypothesis Testing"},{"location":"04-advanced/03-stats/#hypothesis-testing-in-coin-flips-by-simulation","text":"As an example, hypothesis testing in coin flips follows this logic: I observe that 8 out of 10 coin tosses give me heads, giving me a probability of heads p=0.8 p=0.8 (a summary statistic). Under a \"null distribution\" of a fair coin, I simulate the distribution of probability of heads (the summary statistic) that I would get from 10 coin tosses. Finally, I use that distribution to calculate the probability of observing p=0.8 p=0.8 or more extreme.","title":"Hypothesis testing in coin flips, by simulation"},{"location":"04-advanced/03-stats/#hypothesis-testing-in-graphs","text":"The same protocol applies when we perform hypothesis testing on graphs. Firstly, we calculate a summary statistic that describes our graph. Secondly, we propose a null graph model , and calculate our summary statistic under simulated versions of that null graph model. Thirdly, we look at the probability of observing the summary statistic value that we calculated in step 1 or more extreme, under the assumed graph null model distribution.","title":"Hypothesis testing in graphs"},{"location":"04-advanced/03-stats/#stochastic-graph-creation-models","text":"Since we are going to be dealing with models of randomness in graphs, let's take a look at some examples.","title":"Stochastic graph creation models"},{"location":"04-advanced/03-stats/#erdos-renyi-aka-binomial-graph","text":"On easy one to study is the Erdos-Renyi graph, also known as the \"binomial\" graph. The data generation story here is that we instantiate an undirected graph with n n nodes, giving \\frac{n^2 - n}{2} \\frac{n^2 - n}{2} possible edges. Each edge has a probability p p of being created. import networkx as nx G_er = nx . erdos_renyi_graph ( n = 30 , p = 0.2 ) nx . draw ( G_er ) You can verify that there's approximately 20% of \\frac{30^2 - 30}{2} = 435 \\frac{30^2 - 30}{2} = 435 . len ( G_er . edges ()) 90 len ( G_er . edges ()) / 435 0.20689655172413793 We can also look at the degree distribution: import pandas as pd from nams.functions import ecdf import matplotlib.pyplot as plt x , y = ecdf ( pd . Series ( dict ( nx . degree ( G_er )))) plt . scatter ( x , y ) <matplotlib.collections.PathCollection at 0x7ff080541f70>","title":"Erdos-Renyi (a.k.a. \"binomial\") graph"},{"location":"04-advanced/03-stats/#barabasi-albert-graph","text":"The data generating story of this graph generator is essentially that nodes that have lots of edges preferentially get new edges attached onto them. This is what we call a \"preferential attachment\" process. G_ba = nx . barabasi_albert_graph ( n = 30 , m = 3 ) nx . draw ( G_ba ) len ( G_ba . edges ()) 81 And the degree distribution: x , y = ecdf ( pd . Series ( dict ( nx . degree ( G_ba )))) plt . scatter ( x , y ) <matplotlib.collections.PathCollection at 0x7ff080420940> You can see that even though the number of edges between the two graphs are similar, their degree distribution is wildly different.","title":"Barabasi-Albert Graph"},{"location":"04-advanced/03-stats/#load-data","text":"For this notebook, we are going to look at a protein-protein interaction network, and test the hypothesis that this network was not generated by the data generating process described by an Erdos-Renyi graph. Let's load a protein-protein interaction network dataset . This undirected network contains protein interactions contained in yeast. Research showed that proteins with a high degree were more important for the surivial of the yeast than others. A node represents a protein and an edge represents a metabolic interaction between two proteins. The network contains loops. from nams import load_data as cf G = cf . load_propro_network () for n , d in G . nodes ( data = True ): G . nodes [ n ][ \"degree\" ] = G . degree ( n ) As is always the case, let's make sure we know some basic stats of the graph. len ( G . nodes ()) 1870 len ( G . edges ()) 2277 Let's also examine the degree distribution of the graph. x , y = ecdf ( pd . Series ( dict ( nx . degree ( G )))) plt . scatter ( x , y ) <matplotlib.collections.PathCollection at 0x7ff07270daf0> Finally, we should visualize the graph to get a feel for it. import nxviz as nv from nxviz import annotate nv . circos ( G , sort_by = \"degree\" , node_color_by = \"degree\" , node_aes_kwargs = { \"size_scale\" : 10 }) annotate . node_colormapping ( G , color_by = \"degree\" ) /home/runner/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.0 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.6.3, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( One thing we might infer from this visualization is that the vast majority of nodes have a very small degree, while a very small number of nodes have a high degree. That would prompt us to think: what process could be responsible for generating this graph?","title":"Load Data"},{"location":"04-advanced/03-stats/#inferring-graph-generating-model","text":"Given a graph dataset, how do we identify which data generating model provides the best fit? One way to do this is to compare characteristics of a graph generating model against the characteristics of the graph. The logic here is that if we have a good graph generating model for the data, we should, in theory, observe the observed graph's characteristics in the graphs generated by the graph generating model.","title":"Inferring Graph Generating Model"},{"location":"04-advanced/03-stats/#comparison-of-degree-distribution","text":"Let's compare the degree distribution between the data, a few Erdos-Renyi graphs, and a few Barabasi-Albert graphs.","title":"Comparison of degree distribution"},{"location":"04-advanced/03-stats/#comparison-with-barabasi-albert-graphs","text":"from ipywidgets import interact , IntSlider m = IntSlider ( value = 2 , min = 1 , max = 10 ) @interact ( m = m ) def compare_barabasi_albert_graph ( m ): fig , ax = plt . subplots () G_ba = nx . barabasi_albert_graph ( n = len ( G . nodes ()), m = m ) x , y = ecdf ( pd . Series ( dict ( nx . degree ( G_ba )))) ax . scatter ( x , y , label = \"Barabasi-Albert Graph\" ) x , y = ecdf ( pd . Series ( dict ( nx . degree ( G )))) ax . scatter ( x , y , label = \"Protein Interaction Network\" ) ax . legend () var element = $('#fd67aaf2-c599-42f4-966d-1b9c9e18837d');","title":"Comparison with Barabasi-Albert graphs"},{"location":"04-advanced/03-stats/#comparison-with-erdos-renyi-graphs","text":"from ipywidgets import FloatSlider p = FloatSlider ( value = 0.6 , min = 0 , max = 0.1 , step = 0.001 ) @interact ( p = p ) def compare_erdos_renyi_graph ( p ): fig , ax = plt . subplots () G_er = nx . erdos_renyi_graph ( n = len ( G . nodes ()), p = p ) x , y = ecdf ( pd . Series ( dict ( nx . degree ( G_er )))) ax . scatter ( x , y , label = \"Erdos-Renyi Graph\" ) x , y = ecdf ( pd . Series ( dict ( nx . degree ( G )))) ax . scatter ( x , y , label = \"Protein Interaction Network\" ) ax . legend () ax . set_title ( f \"p= { p } \" ) var element = $('#5b57e6da-8d2e-4079-9bc6-d53d8cc04c5d'); Given the degree distribution only, which model do you think better describes the generation of a protein-protein interaction network?","title":"Comparison with Erdos-Renyi graphs"},{"location":"04-advanced/03-stats/#quantitative-model-comparison","text":"Each time we plug in a value of m m for the Barabasi-Albert graph model, we are using one of many possible Barabasi-Albert graph models, each with a different m m . Similarly, each time we choose a different p p for the Erdos-Renyi model, we are using one of many possible Erdos-Renyi graph models, each with a different p p . To quantitatively compare degree distributions, we can use the Wasserstein distance between the data. Let's see how to implement this. from scipy.stats import wasserstein_distance def erdos_renyi_degdist ( n , p ): \"\"\"Return a Pandas series of degree distribution of an Erdos-Renyi graph.\"\"\" G = nx . erdos_renyi_graph ( n = n , p = p ) return pd . Series ( dict ( nx . degree ( G ))) def barabasi_albert_degdist ( n , m ): \"\"\"Return a Pandas series of degree distribution of an Barabasi-Albert graph.\"\"\" G = nx . barabasi_albert_graph ( n = n , m = m ) return pd . Series ( dict ( nx . degree ( G ))) deg = pd . Series ( dict ( nx . degree ( G ))) er_deg = erdos_renyi_degdist ( n = len ( G . nodes ()), p = 0.001 ) ba_deg = barabasi_albert_degdist ( n = len ( G . nodes ()), m = 1 ) wasserstein_distance ( deg , er_deg ), wasserstein_distance ( deg , ba_deg ) (0.7860962566844915, 0.5251336898395734) Notice that because the graphs are instantiated in a non-deterministic fashion, re-running the cell above will give you different values for each new graph generated. Let's now plot the wasserstein distance to our graph data for the two particular Erdos-Renyi and Barabasi-Albert graph models shown above. import matplotlib.pyplot as plt from tqdm.autonotebook import tqdm er_dist = [] ba_dist = [] for _ in tqdm ( range ( 100 )): er_deg = erdos_renyi_degdist ( n = len ( G . nodes ()), p = 0.001 ) er_dist . append ( wasserstein_distance ( deg , er_deg )) ba_deg = barabasi_albert_degdist ( n = len ( G . nodes ()), m = 1 ) ba_dist . append ( wasserstein_distance ( deg , ba_deg )) # er_degs = [erdos_renyi_degdist(n=len(G.nodes()), p=0.001) for _ in range(100)] <ipython-input-1-1b1ecb0363e4>:2: TqdmExperimentalWarning: Using `tqdm.autonotebook.tqdm` in notebook mode. Use `tqdm.tqdm` instead to force console mode (e.g. in jupyter console) from tqdm.autonotebook import tqdm var element = $('#766db859-4220-4f1d-b2a2-efc20d895d33'); import seaborn as sns import janitor data = ( pd . DataFrame ( { \"Erdos-Renyi\" : er_dist , \"Barabasi-Albert\" : ba_dist , } ) . melt ( value_vars = [ \"Erdos-Renyi\" , \"Barabasi-Albert\" ]) . rename_columns ({ \"variable\" : \"Graph Model\" , \"value\" : \"Wasserstein Distance\" }) ) sns . swarmplot ( data = data , x = \"Graph Model\" , y = \"Wasserstein Distance\" ) <AxesSubplot:xlabel='Graph Model', ylabel='Wasserstein Distance'> From this, we might conclude that the Barabasi-Albert graph with m=1 m=1 has the better fit to the protein-protein interaction network graph.","title":"Quantitative Model Comparison"},{"location":"04-advanced/03-stats/#interpretation","text":"That statement, accurate as it might be, still does not connect the dots to biology . Let's think about the generative model for this graph. The Barabasi-Albert graph gives us a model for \"rich gets richer\". Given the current state of the graph, if we want to add a new edge, we first pick a node with probability proportional to the number of edges it already has. Then, we pick another node with probability proportional to the number of edges that it has too. Finally, we add an edge there. This has the effect of \"enriching\" nodes that have a large number of edges with more edges. How might this connect to biology? We can't necessarily provide a concrete answer, but this model might help raise new hypotheses. For example, if protein-protein interactions of the \"binding\" kind are driven by subdomains, then proteins that acquire a domain through recombination may end up being able to bind to everything else that the domain was able to. In this fashion, proteins with that particular binding domain gain new edges more readily. Testing these hypotheses would be a totally different matter, and at this point, I submit the above hypothesis with a large amount of salt thrown over my shoulder. In other words, the hypothesized mechanism could be completely wrong. However, I hope that this example illustrated that the usage of a \"graph generative model\" can help us narrow down hypotheses about the observed world. {\"state\": {\"25c5cd70c00e47d687a89094126f6be2\": {\"model_name\": \"LayoutModel\", \"model_module\": \"@jupyter-widgets/base\", \"model_module_version\": \"1.2.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/base\", \"_model_module_version\": \"1.2.0\", \"_model_name\": \"LayoutModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"LayoutView\", \"align_content\": null, \"align_items\": null, \"align_self\": null, \"border\": null, \"bottom\": null, \"display\": null, \"flex\": null, \"flex_flow\": null, \"grid_area\": null, \"grid_auto_columns\": null, \"grid_auto_flow\": null, \"grid_auto_rows\": null, \"grid_column\": null, \"grid_gap\": null, \"grid_row\": null, \"grid_template_areas\": null, \"grid_template_columns\": null, \"grid_template_rows\": null, \"height\": null, \"justify_content\": null, \"justify_items\": null, \"left\": null, \"margin\": null, \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"object_fit\": null, \"object_position\": null, \"order\": null, \"overflow\": null, \"overflow_x\": null, \"overflow_y\": null, \"padding\": null, \"right\": null, \"top\": null, \"visibility\": null, \"width\": null}}, \"3aec3736461c469ca0aa1a211a71e1ee\": {\"model_name\": \"SliderStyleModel\", \"model_module\": \"@jupyter-widgets/controls\", \"model_module_version\": \"1.5.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/controls\", \"_model_module_version\": \"1.5.0\", \"_model_name\": \"SliderStyleModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"StyleView\", \"description_width\": \"\", \"handle_color\": null}}, \"80e5e852d32b4da395152a560f3def86\": {\"model_name\": \"IntSliderModel\", \"model_module\": \"@jupyter-widgets/controls\", \"model_module_version\": \"1.5.0\", \"state\": {\"_dom_classes\": [], \"_model_module\": \"@jupyter-widgets/controls\", \"_model_module_version\": \"1.5.0\", \"_model_name\": \"IntSliderModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/controls\", \"_view_module_version\": \"1.5.0\", \"_view_name\": \"IntSliderView\", \"continuous_update\": true, \"description\": \"m\", \"description_tooltip\": null, \"disabled\": false, \"layout\": \"IPY_MODEL_25c5cd70c00e47d687a89094126f6be2\", \"max\": 10, \"min\": 1, \"orientation\": \"horizontal\", \"readout\": true, \"readout_format\": \"d\", \"step\": 1, \"style\": \"IPY_MODEL_3aec3736461c469ca0aa1a211a71e1ee\", \"value\": 2}}, \"849f222e990c4292802e22294ba8dfed\": {\"model_name\": \"LayoutModel\", \"model_module\": \"@jupyter-widgets/base\", \"model_module_version\": \"1.2.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/base\", \"_model_module_version\": \"1.2.0\", \"_model_name\": \"LayoutModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"LayoutView\", \"align_content\": null, \"align_items\": null, \"align_self\": null, \"border\": null, \"bottom\": null, \"display\": null, \"flex\": null, \"flex_flow\": null, \"grid_area\": null, \"grid_auto_columns\": null, \"grid_auto_flow\": null, \"grid_auto_rows\": null, \"grid_column\": null, \"grid_gap\": null, \"grid_row\": null, \"grid_template_areas\": null, \"grid_template_columns\": null, \"grid_template_rows\": null, \"height\": null, \"justify_content\": null, \"justify_items\": null, \"left\": null, \"margin\": null, \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"object_fit\": null, \"object_position\": null, \"order\": null, \"overflow\": null, \"overflow_x\": null, \"overflow_y\": null, \"padding\": null, \"right\": null, \"top\": null, \"visibility\": null, \"width\": null}}, \"de248d7e9cbc41b69d19ed0ff52ed26a\": {\"model_name\": \"VBoxModel\", \"model_module\": \"@jupyter-widgets/controls\", \"model_module_version\": \"1.5.0\", \"state\": {\"_dom_classes\": [\"widget-interact\"], \"_model_module\": \"@jupyter-widgets/controls\", \"_model_module_version\": \"1.5.0\", \"_model_name\": \"VBoxModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/controls\", \"_view_module_version\": \"1.5.0\", \"_view_name\": \"VBoxView\", \"box_style\": \"\", \"children\": [\"IPY_MODEL_80e5e852d32b4da395152a560f3def86\", \"IPY_MODEL_3feacbbeccb749dfb73c9fd914d3452b\"], \"layout\": \"IPY_MODEL_849f222e990c4292802e22294ba8dfed\"}}, \"2250175739e44563846e4635e31d60e5\": {\"model_name\": \"LayoutModel\", \"model_module\": \"@jupyter-widgets/base\", \"model_module_version\": \"1.2.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/base\", \"_model_module_version\": \"1.2.0\", \"_model_name\": \"LayoutModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"LayoutView\", \"align_content\": null, \"align_items\": null, \"align_self\": null, \"border\": null, \"bottom\": null, \"display\": null, \"flex\": null, \"flex_flow\": null, \"grid_area\": null, \"grid_auto_columns\": null, \"grid_auto_flow\": null, \"grid_auto_rows\": null, \"grid_column\": null, \"grid_gap\": null, \"grid_row\": null, \"grid_template_areas\": null, \"grid_template_columns\": null, \"grid_template_rows\": null, \"height\": null, \"justify_content\": null, \"justify_items\": null, \"left\": null, \"margin\": null, \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"object_fit\": null, \"object_position\": null, \"order\": null, \"overflow\": null, \"overflow_x\": null, \"overflow_y\": null, \"padding\": null, \"right\": null, \"top\": null, \"visibility\": null, \"width\": null}}, \"3feacbbeccb749dfb73c9fd914d3452b\": {\"model_name\": \"OutputModel\", \"model_module\": \"@jupyter-widgets/output\", \"model_module_version\": \"1.0.0\", \"state\": {\"_dom_classes\": [], \"_model_module\": \"@jupyter-widgets/output\", \"_model_module_version\": \"1.0.0\", \"_model_name\": \"OutputModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/output\", \"_view_module_version\": \"1.0.0\", \"_view_name\": \"OutputView\", \"layout\": \"IPY_MODEL_2250175739e44563846e4635e31d60e5\", \"msg_id\": \"\", \"outputs\": [{\"output_type\": \"display_data\", \"metadata\": {\"image/png\": {\"width\": 377, \"height\": 248}, \"needs_background\": \"light\"}, \"data\": {\"text/plain\": \"<Figure size 432x288 with 1 Axes>\", \"image/png\": \"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yRK1bNkyfMU5wJQpU4r9pOC0tDRt3LhRxhgtX75c33//vc4999wgVxjZ1q9fr759+2rt2rVKTExUamqqGjRooJiYGP38889atGiRZs+erUcffVS//vpruMuFQxHkAQABWbppr8bO26iVW/fnW9a2QXUN6dZEKY3D/6RDL19DVAYNGqTx48drzJgxDNsoxFlnnVXsbf/1r39JkoYOHarnn39e//rXvzRu3LhglRbxdu3apW7dumnnzp0aNGiQnnvuOZ122mn51vvyyy/197//PQwVoqxgaA0AoFAffPOT+r+5wmeIl6SVW/er/5sr9J9vtoe4sqLp3r27JOU7A3rw4EG9+OKLSk1NVb169VSxYkWdccYZuuqqq/T111/7bMsYoy5duuiXX37R7bffrrp16yo6Ojr7C8KGDRv0yCOPqE2bNjrjjDMUGxurpKQk3XnnndqxY0eBdS5fvlyXXHKJEhISFB8frx49eujbb7/Nt97OnTv11FNPKSUlRbVr11bFihV15pln6qabbvI7hOijjz5St27dVKdOHcXGxurMM89U586d9dprr+Var7hj5Pft26dZs2apSZMmeuaZZ1SrVi1NnTpVx48fL3JbkvTpp5+qQ4cOqlKliqpVq6Zrr71WGzdu9Lnu0aNHNXLkSLVs2VJVqlTRaaedposuukj//ve/862b85qElStX6oorrlD16tWzx+YbY7Rt2zZt27Yt1zCtAQMGFFrzY489pp07d+qmm27SuHHjfIZ4Sbr00kvz9WtGRkb2fjZs2KAbbrhBNWvWVFRUlBYsWCBJWrVqlYYMGaIWLVqoevXqqlSpkpo0aaKHHnpIBw4cyLefnNccFOV4er3xxhs677zzVKlSJdWqVUt33nmnDh48WOhxQOkjyAMACrR00149OvN/chXy/BOXlR6Z+V8t3bQ3NIUVw1dffSVJatOmTa7569at0+OPP66oqChdccUVevDBB3XppZdq/vz56tSpk7744guf7e3fv1/t27fX119/rT59+ui+++5TrVq1JEkzZ87U66+/rvr166tfv34aNGiQ/vSnP2nixIm68MIL9fPPP/tsc8WKFerSpYtiY2N177336vLLL9e8efPUqVMnLV68ONe6ixYt0qhRo5SYmKi+ffvqgQceUPv27TV9+nRdeOGFWrNmTa71//Wvf+nqq6/W2rVr1atXLz300EPq2bOnjh07pkmTJhXrmOb19ttv68SJExowYIBiYmJ0880368CBA5o2bVqR25o5c6auueYa1atXT0OGDNFFF12kGTNmqH379vrxxx9zrfvbb7+pY8eOeuyxxxQdHa3bbrtNt956q3799VfddNNNeuKJJ3zuY/ny5erUqZOOHz+evU3Tpk01bNgwJSQkKCEhQcOGDct+XXPNNQXWfPTo0ewvDjmHd/kTE+N7cMTmzZvVrl07ZWRk6Oabb9add96pqlWrSpImTJig999/X2effbYGDhyou+++W3Xq1NHo0aOVkpKiQ4cO+WyzKMfTa+jQoRo6dKhatGihe++9V3Xr1tWECRPUu3fvQt8bQsBaW25ekla1atXKlqphVYv1ynqyqk16+JN8LwAIxNq1a+3atWtLpe3rXl/m8/eTv9f1ry8rlToCJclKssOGDct+PfDAA7Zjx47WGGOvvPJK+/vvv+fa5rfffrO//vprvra2b99u69SpY5s1a+Z3P/3797enTp3Kt3zHjh32+PHj+ebPmTPHRkVF2bvvvjvX/LS0tOw2X3311VzLZs+ebSXZxo0b26ysrOz5u3fvzvderLV29erVtkqVKvayyy7LNb9Vq1a2YsWKdvfu3fm2yfv+O3fubN0xoWiaN29uo6Ki7Pbt26211v7vf/+zkmzHjh19rp+UlGSTkpJyzZs0aVL2sfj4449zLRszZoyVZFNTU3PNv/XWW60k+/zzz+eaf+zYMdujRw9rjLHfffdd9vycx/v1118PuLbCLFy40Eqy9erVK9J2Xlu3bs2u69FHH/W5TkZGhs3MzMw3f+LEiVaSHTVqVK75JTme9evXt9u2bcuef+rUKdupUycrya5YsaJY79HpAv1926pVKytplS3FbMsZeQCAXxt2H/I7nMafFVv3a8Nu32cEQ2nEiBHZr1deeUVLlixR8+bN1a9fP8XH5744NyEhQTVq5B/fX69ePV177bVav369fvrpp3zLK1asqJdeesnnWdW6desqNjY23/zu3bvrnHPO0Zw5c3zW3bhxY/31r3/NNe/qq69W586dtWnTplxn5WvWrJnvvUhSixYtlJqaqrS0NJ06dSrXspiYGFWoUCHfNr7ef1EtWrRI69at0yWXXKJ69epJks4991y1atVKS5YsKfIdg1JTU3XllVfmmnffffepUaNGmj9/vrZt2ybJPZxn6tSpatOmjYYOHZpr/UqVKun555+XtVbvvfdevn20bNlSd911V5HqKsgvv/wiyd3/vkyePFnDhw/P9Vq9enW+9WrVquX3jH5SUpKio6Pzzb/ttttUtWpVvz9bgR7PnP7xj3/kul4iJiZGAwcOlCStXLnS534QOlzsCgDwq7jDZJZu2hv2O9lY+8dYoCNHjuiHH37QI488optvvlk//PCDnn322VzrL126VGPHjtXy5cu1Z88enTx5Mtfyn3/+Od8FoMnJyapZs6bf/b/77ruaPHmy1qxZowMHDigrKyt7ecWKFX1u16lTJ0VF5T/P1qVLFy1cuFDfffedOnfunD3/008/1euvv65vv/1We/fuVWZmZq7t9u7dqzp16kiSbr75Zj300EM655xzdMMNN6hz585KSUnRGWec4bOWnH777TeNGTMm3/z7779fiYmJktxDPiRlBz2vAQMGKD09XRMmTNDo0aML3ZdXzvfpFR0drY4dO2rz5s367rvvlJSUpG+++UZZWVl+78Pv/TLj64tE27ZtA64nEN6fO3/XF0yePFkLFy7MNS85OTnfXZRatGjh84ug5H4/b7zxht5//32tXbtWBw8elMvlyl7ub9hWoMczp7zD0CSpfv36kuRzPD5CiyAPAPDr8PHMwlcK4nalpUqVKmrbtq1mzpypevXq6YUXXtDdd9+dHUhmzZqla6+9VpUqVdKll16qRo0aqUqVKtkXGC5cuFAnTpzI127t2rX97vPBBx/UmDFjVKdOHfXo0UN169ZV5cqVJbnDnK+zn5Kyx9j721fOiwzHjRunIUOGqFq1arr00kt11llnKS4uTsYYzZ49W2vWrMlV94MPPqgaNWrotdde07hx4zRmzBgZY9S5c2e9+OKLPkOb12+//aYRI0bkmz9gwAAlJibqwIEDmj59uhITE/ONI7/pppv0t7/9TVOmTNHIkSP9BtTiHot9+/ZJkr755ht98803fts7fPiw37aCxfulyV+Y9l6wKklPPPFEvi+UgdR1ww03aNasWWrYsKGuvvpq1a5dO/uYjhkzxufPqlS0ny0v75e0nLx/gcr5xRThQZAHAPh1WqXifUwUd7vSlpiYqLPPPlvp6elKT0/PDvJPPvmkKlasqG+//VbNmzfPtc1dd92V7wyql7+zrnv27NG4ceN07rnnatmyZfmGv/i6i4rX7t27fc73DtlISEiQJGVmZmrYsGGqXbu20tPTswOk1/Lly322c8stt+iWW27Rb7/9pmXLlmnWrFl666231KNHD61bt87vXxiSk5Nz/ZUjrylTpuj48eM6fvx49heWvPbt26cZM2bopptu8ttOToEeC+/0gQceKNIZf8l/HxZXmzZtFBsbq+3bt2vjxo1q0qRJsdrxV9e3336rWbNm6ZJLLtFnn32Wa5iUy+XSCy+84LfNQI8nnCMyf9MCACJCce8LH0n3k8/LOxwg51CETZs26ZxzzskX4l0ul5YsWVLkfWzZskUul0vdu3fPF+J37NihLVu2+N12yZIlcrlc+YbXeM/kXnDBBZLcQ2Z+++039enTJ1+IP3z4sNLT0wusMTExUT179lTPnj3lcrn01ltvafHixerbt2+gbzMX77Cafv36KS4uLt/ygwcPavr06ZowYULAQd7XF6isrKzsPvEei7Zt2yoqKirfXX1KKjo6Ot8Qq8LExcWpX79+mjx5sp566im98847Qa1p06ZNkqSrrroq37UOK1eu1LFjx/xuG+jxhHNwsSsAwK+mteLVtkH1Im3TrkH1sI+P92f27NnaunWrKlSooA4dOmTPT05O1saNG7Vz587sedZajRgxQmvXri3yfpKTkyW5Q3nO4QeHDx/WHXfckW8ce04bN27Md0/3Dz/8UAsXLlTjxo3VqVMnSe4LXePi4rRq1apcQ0ZOnTqlIUOGaO/e/Nc3fPHFFz73vWfPHknyGcADsWzZMv3www9q3ry53nvvPU2cODHf64MPPlBSUpIWLFigDRs2BNTu/Pnz9cknn+SaN378eG3evFldu3bNHs9ds2ZN3Xzzzfr222/19NNP+3yPmzdv1tatW4v0vk4//XT9+uuvBYZjX5599lmdeeaZmjp1qh544AEdOXLE53rFuRe792cr5xAdyd2H9957b4HbBno84RyckQcAFGhItybq/+aKQu8jL0lRRhrcrXhDCYIt50WPR44c0dq1a/X5559Lkp577rlc44UfeOAB3X333brgggvUt29fVahQQUuXLs2+3/rHH39cpH3Xrl1bN954o95//321bNlS3bt318GDB/Xll1+qUqVKatmypc87lUjSZZddpoceekiff/65WrRooU2bNmnmzJmqVKmS3nzzzewz9VFRURo8eLBGjRql8847T1dffbVOnjyptLQ0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+eWXX9aXX36pXr16qWvXrtlBeOvWrerYsaN27typ1NRU9evXT9u3b9e0adP06aefasaMGbryyislucN1YmKiPvzwQ1199dVq2bJldvuJiYmS3MN8evXqpTlz5ujss8/WTTfdpEqVKiktLU2DBg3SihUr9M47gX8ZGjp0qObMmaNevXqpe/fuSktL04QJE7Rp0ybNnz+/BEfqD6+99po++ugjXXXVVercubNWrFihDz74QGvWrNHq1asVGxurxMREDRs2TJMnT9a2bduyhzVJyhV009PT1b17d+3fv189evRQnz59tHfvXs2ePVsdO3bUrFmz1LNnz3w1+OsfSbrnnnv0pz/9SRdffLHq1Kmjffv26bPPPlP//v31448/6umnn87V1tatW9W1a1dt27ZNrVu31j333COXy6UNGzbolVde0d133x3w+/Hl5MmT6tGjhxYuXKhmzZrp3nvv1dGjRzV9+nTdcMMNWr16tZ577rl8223btk1t27ZVw4YN1b9/f+3fv18ffPCBrr76an311Vfq2rVrYV2VyzXXXKOLL75Yn3zyidLS0gLa/osvvlCfPn2yf04bN26sHTt2aObMmfr000+VlpamVq1aSXIPXZs9e7bWrFmjIUOGZP+Me6fdunXT+++/r3nz5qlJkybZ+0hLS5MkLVu2TMePH1elSpUkSQsXLlRmZmaugF/cY7l582a1a9dOTZs21c0336xjx46patWqft/3u+++q9tuu00NGzbUF198oaSkpEKPVcSw1pabl6RVrVq1sqVqWNVivbKerGqTHv4k3wsAArF27Vq7du3a0mn8rcuL9jvtrZ6lU0eAJFn3x1tuX375pTXGWGOMzcjIsNZaO2zYMCvJxsXF2fT09HzbdO/e3UqyzzzzTK75S5cutdHR0bZ69er20KFD2fMnTZpkJdlJkyb5rM27v/vuu89mZmZmz8/MzLS33XablWRnz56dPX/r1q1Wkr311ltztXPrrbdaSbZ+/fp227Zt2fNPnTplO3XqZCXZFStW+D9IOXhrzrsPb63x8fH2v//9b65l/fr1s5LsBx98kGt+586dfR57b22NGjWysbGxdsGCBbmW/fzzz/bMM8+0tWvXtsePH89Xg7/+sdbaTZs25Zt34sQJm5qaamNiYuyOHTtyLevQoYOVZJ977rl82/3666/22LFjAb0fa61NSkqySUlJueY999xzVpK9/PLL7alTp7Ln79692yYlJVlJdunSpdnzvX0syQ4fPjxXW1988UV2W4Hy7uPUqVN25cqV1hhjW7VqZV0uV773tXHjxux5+/fvt4mJifb000+3P/zwQ642v//+e1ulShV7wQUX5Jrv/TncunVrvjo2b95sJdlrr702e9769eutJHvppZdaSfarr77KXnb//fdbSXbRokXZ80pyLB999FGfxydvnz7//PPWGGNTUlLsvn37fG6TV6C/b1u1amUlrbKlmG0ZWgMA8G/POv/DafzZtsS9XZgNHz5cw4cP1+OPP65rr71Wl112may1uv/++/Odcbvzzjt1wQUX5Jq3Y8cOzZ07V2eddVa+4QkdOnRQv379tH//fs2cOTOgelwul8aPH6/atWvrlVdeUXR0dPay6OhovfzyyzLGFOnOOv/4xz901llnZf87JiYme3jPypUrA26nIIMHD9Z5552Xa94dd9xR5H18+umn2rx5swYNGqTOnTvnWnbmmWdq6NCh+uWXX3xeQOqrf7x8jVOvWLGi7r33XmVmZuZqb9WqVVq2bJlatmyphx9+ON923iEtJfHWW2/JGKPRo0crJuaPgQ81a9bUk08+KUmaOHFivu2SkpL0xBNP5JrXo0cPnXXWWcXuywsvvFA33HCD0tPTC/25mjJlin777TeNGDFCf/rTn3ItO+ecc3THHXfou+++09q1awPad8OGDZWcnKy0tLTsv4R5++Kpp55SdHR0rr6ZN2+eqlSponbt2mXPK+6xrFWrVq6/ovjicrl033336eGHH1bv3r311VdfqXr16gG9t0jC0BoAgH9bFhZ/uzDfyWbEiBGS3MNoEhMT1alTJ/3lL3/Rn//853zrtm3bNt+87777TpLUqVMnVahQId/y1NRUTZ06Vd99951uueWWQuvZsGGD9u3bpyZNmuiZZ57xuU7lypW1bl3gX4LatGmTb179+vUlSQcOHAi4nVDsY/ny5ZLcQ0jyXogsKXss9bp16/INr/HVP14//fSTnn/+ec2bN08//fSTjh07lmt5zrH8X3/9tSR3QI6KCv65zEOHDmnTpk2qW7euz4uUU1NTJf3xs5VTy5Ytc32586pfv372sSuOkSNHatasWdlfaP19UfHuY82aNT77Z8OGDZLc/ZM36PuTmpqqt956S6tXr9YFF1yg+fPnq06dOmrfvr1at26dHeR//fVXff/99+revbsqVqwoqWTHskWLFoqNjS2wtr59+2r27NkaNGiQxowZUyo/D6FAkAcA+HfiUGi3CyLvWcBA1K5dO9887zjsOnXq+NzGO/+3334LaB/79u2T5A6s3i8Zvhw+fDig9qQ/xiPn5D1zmZWVFXA7odiH9/1PmzatwPV8vX9f/SNJW7ZsUdu2bXXgwAF16tRJ3bt3V0JCgqKjo5WRkaG3335bJ06cyF7f21d169YNuO6iKMnPjK/jLLmPdd6LoIsiOTlZgwYN0ksvvaSxY8f6/EuE9Ef/TJgwocD2ivLz2a1bN7311luaN2+eWrRooQULFujyyy/PXvbCCy/o4MGDmj9/vqy1ucbHl+RY+vt5yWnRokWKiYlRr169HBviJe5aAwAoSGx8aLcLE18P/fHeu/2XX37xuc2uXbtyrVcY73q9e/cucMzr1q1bi/MWIp73/X/44YcFvn9fQyL8PZRp9OjR2rdvn958800tWLBA48aN09NPP63hw4erR48e+db3huWcZ+mDKdg/M8Hy+OOPq3r16ho5cqT27t3rcx1vTWvWrCmwf2699daA9+s9a/7VV19p9erV2rdvX3ZYT01NVVZWltLS0rLPzHvXz1lPcY5lIA/xSktLU7Vq1dSrVy99+umnAb+nSBO0IG+MqWeMecsYs9MYc8IYk2GMGWOMqRaOdgAAQdCwc+HrBHO7COIdk71kyRJlZmbmW+69+4b3Lh6SsodG+DpT3axZMyUmJurrr7/WqVOnSqPksCvo/bdv316StHjx4qDtz/tk0r59++Zb5r11pK8a5syZE9BZ7oLejy/x8fFq1KiRfv7553y3XZR8/8yEQmJiop588kkdPHjQ71+DitM/hR2f2rVr609/+pMWL16sL774QtIfYT0lJUWxsbGaN2+e5s+fr2rVquW6DqK0j+X555+vhQsXqnr16urTp49mz55drHbCLShB3hjTSNIqSQMlrZT0iqQtkoZIWm6MOT2U7QAAgqRmc/fDnooiqWPYx8cHQ7169XTppZcqIyNDY8aMybVsxYoVeu+991StWjX17t07e/7pp7s/pn766ad87cXExGjQoEHatWuXBg8enG8st+Q+yxjoxYSRqKD3f/XVV6tRo0b65z//qc8++8zn9suXL9fRo0cD3p/3VpB57xE+Z84cnxdBtm7dWh06dNDq1av1/PPP51u+b98+HT9+PPvfBb0ff2677TZZa/X3v/89V8Ddu3dv9q0wb7vttoDbC5a//vWvatSokd54441czzXwGjhwoBITEzVixAifF9e6XK58xzmQ45OamqqjR49q7NixatKkSfbF2ZUrV9ZFF12k//znP9q8ebO6dOmSb4hLaR/L5s2ba9GiRapVq5auu+46ffDBB8VuK1yCNUb+NUk1JQ221r7qnWmMGS3pAUnPSro7hO0AAIKl81D3w54Ku4+8JJkoqfPfS7+mEHn99deVkpKiv//975o7d67atGmTfR/5qKgoTZo0SfHxfwwjuuiiixQXF6cxY8Zo//79qlWrliRp0KBBSkhI0JNPPqk1a9bo9ddf18cff6zU1FTVrVtXe/bs0caNG7V06VI9++yzAV9MGGm6deumadOmqU+fPurZs6cqV66spKQk9e/fXxUqVNDMmTPVo0cPXXHFFerQoYNatmypuLg4bd++Xd988422bNmiXbt2KS4uLqD9/fWvf9WkSZN03XXXqW/fvqpbt66+//57ffHFF7r++ut9BrOpU6eqS5cueuyxxzRjxgx16dJF1lpt3LhRc+fO1fr167O/IBT0fvz529/+ps8//1wffvihWrRooZ49e+ro0aOaNm2a9uzZo6FDh6pjx47FOr4lUbFiRY0cOVLXX3+9tm3blm/56aefrunTp6t3795q3769unXrpnPOOUdRUVH66aeftHz58nxfdLp166YXX3xRd9xxh6699lqddtppSkxM1H333ZdrnfHjx2vPnj3q06dPrn1269Yt+8tB3gdESaE5lo0bN9bixYuVmpqqm2++WSdOnAjo4vVIUeIgb4xpKKm7pAxJ/8yzeJikOyX1N8Y8ZK09UtrtAACCrGEXqdfYwh8KZaKkXuMi9mFQxdGwYUN9++23euaZZ/TZZ59pwYIFqlq1qi677DI9/vjjuvDCC3OtX61aNc2YMUMjRozQpEmTdOSI++Pqz3/+sxISElShQgXNnj1bU6dO1eTJk/XJJ5/o8OHDOuOMM9SgQQM9/fTTuvnmm8PxVoPi9ttv17Zt2/T+++/rhRdeUGZmpjp37pwdfM8//3ytWbNGo0eP1ieffKJJkyYpKipKderU0QUXXKARI0aoRo0aAe/v/PPPV1pamp544gl99tlnyszMVIsWLTRz5kwlJib6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\\n\"}}]}}, \"7afbde8d5d4f4dba8e160f3a998779ad\": {\"model_name\": \"LayoutModel\", \"model_module\": \"@jupyter-widgets/base\", \"model_module_version\": \"1.2.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/base\", \"_model_module_version\": \"1.2.0\", \"_model_name\": \"LayoutModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"LayoutView\", \"align_content\": null, \"align_items\": null, \"align_self\": null, \"border\": null, \"bottom\": null, \"display\": null, \"flex\": null, \"flex_flow\": null, \"grid_area\": null, \"grid_auto_columns\": null, \"grid_auto_flow\": null, \"grid_auto_rows\": null, \"grid_column\": null, \"grid_gap\": null, \"grid_row\": null, \"grid_template_areas\": null, \"grid_template_columns\": null, \"grid_template_rows\": null, \"height\": null, \"justify_content\": null, \"justify_items\": null, \"left\": null, \"margin\": null, \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"object_fit\": null, \"object_position\": null, \"order\": null, \"overflow\": null, \"overflow_x\": null, \"overflow_y\": null, \"padding\": null, \"right\": null, \"top\": null, \"visibility\": null, \"width\": null}}, \"ba3939632fa041be9152e920f7da4a9b\": {\"model_name\": \"SliderStyleModel\", \"model_module\": \"@jupyter-widgets/controls\", \"model_module_version\": \"1.5.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/controls\", \"_model_module_version\": \"1.5.0\", \"_model_name\": \"SliderStyleModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"StyleView\", \"description_width\": \"\", \"handle_color\": null}}, \"33b18a2e103f4bed8eb2b55964b6f954\": {\"model_name\": \"FloatSliderModel\", \"model_module\": \"@jupyter-widgets/controls\", \"model_module_version\": \"1.5.0\", \"state\": {\"_dom_classes\": [], \"_model_module\": \"@jupyter-widgets/controls\", \"_model_module_version\": \"1.5.0\", \"_model_name\": \"FloatSliderModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/controls\", \"_view_module_version\": \"1.5.0\", \"_view_name\": \"FloatSliderView\", \"continuous_update\": true, \"description\": \"p\", \"description_tooltip\": null, \"disabled\": false, \"layout\": \"IPY_MODEL_7afbde8d5d4f4dba8e160f3a998779ad\", \"max\": 0.1, \"min\": 0.0, \"orientation\": \"horizontal\", \"readout\": true, \"readout_format\": \".2f\", \"step\": 0.001, \"style\": \"IPY_MODEL_ba3939632fa041be9152e920f7da4a9b\", \"value\": 0.1}}, \"14b6c84e418f419aba299d59cc8c1885\": {\"model_name\": \"LayoutModel\", \"model_module\": \"@jupyter-widgets/base\", \"model_module_version\": \"1.2.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/base\", \"_model_module_version\": \"1.2.0\", \"_model_name\": \"LayoutModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"LayoutView\", \"align_content\": null, \"align_items\": null, \"align_self\": null, \"border\": null, \"bottom\": null, \"display\": null, \"flex\": null, \"flex_flow\": null, \"grid_area\": null, \"grid_auto_columns\": null, \"grid_auto_flow\": null, \"grid_auto_rows\": null, \"grid_column\": null, \"grid_gap\": null, \"grid_row\": null, \"grid_template_areas\": null, \"grid_template_columns\": null, \"grid_template_rows\": null, \"height\": null, \"justify_content\": null, \"justify_items\": null, \"left\": null, \"margin\": null, \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"object_fit\": null, \"object_position\": null, \"order\": null, \"overflow\": null, \"overflow_x\": null, \"overflow_y\": null, \"padding\": null, \"right\": null, \"top\": null, \"visibility\": null, \"width\": null}}, \"3ee97d640e0b4782a0df7124e47ca031\": {\"model_name\": \"VBoxModel\", \"model_module\": \"@jupyter-widgets/controls\", \"model_module_version\": \"1.5.0\", \"state\": {\"_dom_classes\": [\"widget-interact\"], \"_model_module\": \"@jupyter-widgets/controls\", \"_model_module_version\": \"1.5.0\", \"_model_name\": \"VBoxModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/controls\", \"_view_module_version\": \"1.5.0\", \"_view_name\": \"VBoxView\", \"box_style\": \"\", \"children\": [\"IPY_MODEL_33b18a2e103f4bed8eb2b55964b6f954\", \"IPY_MODEL_50ad2676ee0446418057a2e4e66b93dd\"], \"layout\": \"IPY_MODEL_14b6c84e418f419aba299d59cc8c1885\"}}, \"01ad7a53d77b47bfb92494396f88b77c\": {\"model_name\": \"LayoutModel\", \"model_module\": \"@jupyter-widgets/base\", \"model_module_version\": \"1.2.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/base\", \"_model_module_version\": \"1.2.0\", \"_model_name\": \"LayoutModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"LayoutView\", \"align_content\": null, \"align_items\": null, \"align_self\": null, \"border\": null, \"bottom\": null, \"display\": null, \"flex\": null, \"flex_flow\": null, \"grid_area\": null, \"grid_auto_columns\": null, \"grid_auto_flow\": null, \"grid_auto_rows\": null, \"grid_column\": null, \"grid_gap\": null, \"grid_row\": null, \"grid_template_areas\": null, \"grid_template_columns\": null, \"grid_template_rows\": null, \"height\": null, \"justify_content\": null, \"justify_items\": null, \"left\": null, \"margin\": null, \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"object_fit\": null, \"object_position\": null, \"order\": null, \"overflow\": null, \"overflow_x\": null, \"overflow_y\": null, \"padding\": null, \"right\": null, \"top\": null, \"visibility\": null, \"width\": null}}, \"50ad2676ee0446418057a2e4e66b93dd\": {\"model_name\": \"OutputModel\", \"model_module\": \"@jupyter-widgets/output\", \"model_module_version\": \"1.0.0\", \"state\": {\"_dom_classes\": [], \"_model_module\": \"@jupyter-widgets/output\", \"_model_module_version\": \"1.0.0\", \"_model_name\": \"OutputModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/output\", \"_view_module_version\": \"1.0.0\", \"_view_name\": \"OutputView\", \"layout\": \"IPY_MODEL_01ad7a53d77b47bfb92494396f88b77c\", \"msg_id\": \"\", \"outputs\": [{\"output_type\": \"display_data\", \"metadata\": {\"image/png\": {\"width\": 372, \"height\": 263}, \"needs_background\": \"light\"}, \"data\": {\"text/plain\": \"<Figure size 432x288 with 1 Axes>\", \"image/png\": \"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zz7T8ePHixzvDnjZ1EUbXA3nxkhVK8dpUIeT9ODQ9rnLB5zWUANOC/5XMOTnpXnQkde7Y6RXgs8TXC5MJan+qdKl/5Fu+lI6b4rU9x7f/U1fSneska7+SLrgYemcidLvJvrGcJ99A2HbA1o1SFLXZnVKtY+X538trfj4eF1xxRXKzs4uNG7566+/1muvvVZon9TUVLVu3Vqff/65Zs6cmW/dzJkz9emnn6pVq1a5s6ls2rRJK1euLFRn7969Onr0aNCTR8tixIgRateunT755BOlpfkmtxo0aJBatGihf/zjH/rwww+D7vfFF1/o0KHwx5jGxcXpuuuu048//qirr75aknTDDTeEXTc5OTn3RNARI0bovffeC7rdoUOHdOzYsVLXDwwfKviF66OPPtKLL75Y7L6TJ0/ONx7/yJEjGj9+vCRp9Gj+oIvIsXZXtro/ON+VYS3dW9TVhItO1bw/9dKmBy7Uqsnn5wvnKB2OoHvRiwOkbUvK9zFMvFS/lVS7hdThUqnNhfnXE7ojzm39T9HIfy0JaapFL83/WtyVRC+++GJ16NAhpDp///vfNX/+fD3xxBP6+uuvc+dBnzFjhi644AK9++67+bY3xujll1/WOeeco0suuUSDBg1SmzZttGbNGs2ePVtJSUl65ZVXFBfnO46xYsUKDR48WJ07d9bpp5+uk046ST/99JPmzJmjY8eO5Y5JD5cxRpMmTdLgwYN19913a/HixYqPj9fbb7+tc889VxdeeKG6d++uDh06KDExUVu3btXSpUu1ceNG7dixQ4mJiWH38Mc//lH33Xeftm/frjPOOCPoNJVlMWrUKB09elRjxozRwIED1bZtW6Wmpqp+/fo6cOCAtm3bpnnz5unAgQPq2bNnqWrfdNNNmjZtmoYPH66hQ4eqUaNG+u677zR37lyNGDFCM2bMKHLftm3b6rTTTss3D/qGDRt04YUXFjqyDnhRcVeQLm+RMitKpCGge827Y8o3nHe8Uhr0dMnbIeKktqynB4acEfI0VF75MC1qmkXJd1Q01IBer149paen669//avee+89ff3112rdurX++c9/KiUlpVBAl6SzzjpLS5cu1d/+9jd98skneu+991SvXj1ddtlluvfee9W6devcbbt06aLx48dr0aJFmjt3rvbu3asTTjhBnTt31pgxY3T++eeX+rkX5eKLL1bn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WGtt06ZNbdOmTfMt+/vf/24l2fPPP98eO3Ysd/muXbts06ZNrSSbnp6euzzwGkuyEydOzFdr7ty5ubVCFXiMY8eO2a+++soaY2ynTp1sTk5Ooee1bt263GVZWVm2Vq1atm7dunblypX5an733Xe2evXqtmPHjvmWB96HmzZtKtTHhg0brCQ7bNiw3GWrV6+2kuw555xjJdlPPvkkd93tt99uJdlPP/00d1k4v8vx48cH/f0UfE2nTJlijTE2NTXV7tmzJ+g+BZXr5205mvb5Rtv0rvfDvj23sPD/51CxOnXqZCUts2XIrAxxiWQdL3e7A3jFj6uKHtZSlM2f+/Zz2cSJEzVx4kTdfffdGjZsmM477zxZa3X77bcXOkJ23XXXqWPHjvmWbdu2TfPmzdPJJ59caJhA9+7dddlllykrK0tvv/12SP3k5OTomWeeUcOGDfX444+rUqVKuesqVaqkRx99VMaYUs0083//9386+eSTc3+uXLly7jCbr776KuQ6xRkzZozOOOOMfMuuvfbaUj/GBx98oA0bNujWW29V7975Z3046aSTNHbsWO3cuTPoiZfBXp+AYOPAq1SpoptvvlnHjx/PV2/ZsmVavHixOnTooLvuuqvQfoGhJeF46aWXZIzRY489psqVf/tjcv369XXvvfdKkl588cVC+zVt2lT33HNPvmXnnnuuTj755DK/lmeeeaYuueQSZWRklPi+euWVV7Rv3z5NmjRJp556ar51p512mq699lp98803+v7770N67ObNmyslJUVpaWm5f7kKvBb33XefKlWqlO+1mT9/vqpXr66zzjord1lZf5cNGjTI91ePYHJycnTLLbforrvu0uDBg/XJJ5+oTp06IT23SPX0gnUlbxQCplSMbAxxiWSDnna7A3jFxkVl38/lmV0mTfKdj2GMUa1atdSzZ09dc801+sMf/lBo265dC5/o9M0330iSevbsqfj4+ELr+/Xrp1dffVXffPONrrzyyhL7Wbt2rfbs2aNTTjlFf/vb34JuU61aNa1aFfqXmy5duhRa1qRJE0nS3r17Q65TEY/xxRdfSPIN5Sh4Aq+k3LHKq1atKjTMJdjrE7BlyxZNmTJF8+fP15YtW3T4cP4rI+YdK//ll19K8gXfuDjnjyNlZ2dr/fr1atSoUdCTe/v16yfpt/dWXh06dMj3pS2gSZMmub+7snjggQf0zjvv5H5RLeoLSOAxVqxYEfT1Wbt2rSTf61MwwBelX79+eumll7R8+XJ17NhRCxYs0Iknnqizzz5bnTt3zg3oP/30k7777jsNGDBAVapUkRTe77J9+/ZKSEgotrehQ4dq9uzZuvXWW/XEE0+Uy/vBa/YcPOZ2C/AAAnqkOqmz2x3AS45mV+x+DgoctQtFw4aFL1EdGOd84oknBt0nsHzfvn0hPcaePXsk+YJo4MtDMAcOHAipnvTbeN+8Akcaf/3115DrVMRjBJ7/W2+9Vex2wZ5/sNdHkjZu3KiuXbtq79696tmzpwYMGKDk5GRVqlRJmZmZevnll3X06NHc7QOvVaNGjULuuzTCec8E+z1Lvt91wZOHSyMlJUW33nqrHnnkET355JNB/3Ig/fb6vPDCC8XWK837s3///nrppZc0f/58tW/fXgsXLtT555+fu+6hhx7S/v37tWDBAllr840/D+d3WdT7Ja9PP/1UlStX1kUXXRQT4fwvby53pE6j5OK/+MD7ov/dHo0S60nXOXNiGaJEQlLF7ueSYBejCcw9vnPnzqD77NixI992JQlsN3jw4GLHB27aFJ3XMAg8/zlz5hT7/IMNTSjqYkGPPfaY9uzZo3/9619auHChnnrqKU2ePFkTJ07UueeeW2j7QAjOe1TdSU6/Z5xy9913q06dOnrggQe0e/fuoNsEelqxYkWxr8+oUaNCftzAUe5PPvlEy5cv1549e3JDeL9+/fTrr78qLS0t90h6YPu8/ZTldxnKxaXS0tJUu3ZtXXTRRfrggw9Cfk6RaOqiDZqV4cx7fsLA0x2pA/cQ0CPR2A1udwCvaV7GK8SVdT8PCYx5/vzzz3X8+PFC6wOzUQRmtZCUO0Qh2JHlNm3aqFatWvryyy917Fh0/qm5uOd/9tlnS5I+++wzxx4vcCXMoUOHFloXmCIxWA8fffRRSEeli3s+wSQlJalFixbavn17oekFpeDvmYpQq1Yt3Xvvvdq/f3+Rf70py+tT0u+nYcOGOvXUU/XZZ59p7ty5kn4L4ampqUpISND8+fO1YMEC1a5dO995BuX9u2zXrp0WLVqkOnXqaMiQIZo9e3aZ6kSCB/672pE6RtKA00r+6wS8jYAORIP6bX0XISqNpj1cH3/uhMaNG+ucc85RZmamnnjiiXzrlixZov/85z+qXbu2Bg8enLu8bt26knzjoguqXLmybr31Vu3YsUNjxowpNFZa8h0VDPUkPC8q7vkPGjRILVq00D/+8Q99+OGHQff/4osvdOjQoZAfLzDlYcE5rj/66KOgJw927txZ3bt31/LlyzVlypRC6/fs2aMjR367wmJxz6coV199tay1uvPOO/MF1927d+dO+Xj11VeHXM8pN910k1q0aKGpU6fmm5c/YPTo0apVq5YmTZoU9KTUnJycQr/nUH4//fr106FDh/Tkk0/qlFNOyT2puVq1aurWrZvefPNNbdiwQX369Ck01KS8f5dt27bVp59+qgYNGmj48OGaMWNGmWt5Vb+H0xyrNe58LpoWDRiDDkSL3mN9FyEqaR50STJxUu87y7+nCvLcc88pNTVVd955p+bNm6cuXbrkzoMeFxenadOmKSnpt+E83bp1U2Jiop544gllZWWpQYMGkqRbb71VycnJuvfee7VixQo999xzeu+999SvXz81atRIP/74o9atW6f09HTdf//9IZ+E5zX9+/fXW2+9pSFDhuiCCy5QtWrV1LRpU40cOVLx8fF6++23de655+rCCy9U9+7d1aFDByUmJmrr1q1aunSpNm7cqB07digxMTGkx7vppps0bdo0DR8+XEOHDlWjRo303Xffae7cuRoxYkTQwPXqq6+qT58++utf/6pZs2apT58+stZq3bp1mjdvnlavXp0b/It7PkW544479N///ldz5sxR+/btdcEFF+jQoUN666239OOPP2rs2LHq0aNHmX6/4ahSpYoeeOABjRgxQps3by60vm7dupo5c6YGDx6ss88+W/3799dpp52muLg4bdmyRV988UWhLzD9+/fXww8/rGuvvVbDhg1TjRo1VKtWLd1yyy35tnnmmWf0448/asiQIfkes3///rmhv+CFi6SK+V22bNlSn332mfr166crrrhCR48eDemk70gwfta32rgn9C+8xRneuTGzt0QJAjoQLZr3kS56suSLFZk46aKnPHuRorJo3ry5vv76a/3tb3/Thx9+qIULF6pmzZo677zzdPfdd+vMM8/Mt33t2rU1a9YsTZo0SdOmTdPBgwclSX/4wx+UnJys+Ph4zZ49W6+++qqmT5+u999/XwcOHNAJJ5ygZs2aafLkybriiivceKqO+OMf/6jNmzfrjTfe0EMPPaTjx4+rd+/euYG2Xbt2WrFihR57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\\n\"}}]}}, \"23b177b0cb0b45d4b4bfbf36c1f720d7\": {\"model_name\": \"LayoutModel\", \"model_module\": \"@jupyter-widgets/base\", \"model_module_version\": \"1.2.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/base\", \"_model_module_version\": \"1.2.0\", \"_model_name\": \"LayoutModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"LayoutView\", \"align_content\": null, \"align_items\": null, \"align_self\": null, \"border\": null, \"bottom\": null, \"display\": null, \"flex\": null, \"flex_flow\": null, \"grid_area\": null, \"grid_auto_columns\": null, \"grid_auto_flow\": null, \"grid_auto_rows\": null, \"grid_column\": null, \"grid_gap\": null, \"grid_row\": null, \"grid_template_areas\": null, \"grid_template_columns\": null, \"grid_template_rows\": null, \"height\": null, \"justify_content\": null, \"justify_items\": null, \"left\": null, \"margin\": null, \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"object_fit\": null, \"object_position\": null, \"order\": null, \"overflow\": null, \"overflow_x\": null, \"overflow_y\": null, \"padding\": null, \"right\": null, \"top\": null, \"visibility\": null, \"width\": null}}, \"34113cf945a04b189886b2c847785cbc\": {\"model_name\": \"ProgressStyleModel\", \"model_module\": \"@jupyter-widgets/controls\", \"model_module_version\": \"1.5.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/controls\", \"_model_module_version\": \"1.5.0\", \"_model_name\": \"ProgressStyleModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"StyleView\", \"bar_color\": null, \"description_width\": \"\"}}, \"09848e34af634b95a86b940f0c097d0b\": {\"model_name\": \"FloatProgressModel\", \"model_module\": \"@jupyter-widgets/controls\", \"model_module_version\": \"1.5.0\", \"state\": {\"_dom_classes\": [], \"_model_module\": \"@jupyter-widgets/controls\", \"_model_module_version\": \"1.5.0\", \"_model_name\": \"FloatProgressModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/controls\", \"_view_module_version\": \"1.5.0\", \"_view_name\": \"ProgressView\", \"bar_style\": \"success\", \"description\": \"\", \"description_tooltip\": null, \"layout\": \"IPY_MODEL_23b177b0cb0b45d4b4bfbf36c1f720d7\", \"max\": 100.0, \"min\": 0.0, \"orientation\": \"horizontal\", \"style\": \"IPY_MODEL_34113cf945a04b189886b2c847785cbc\", \"value\": 100.0}}, \"12b0cdcfbb584e8eba4140c8309479f1\": {\"model_name\": \"LayoutModel\", \"model_module\": \"@jupyter-widgets/base\", \"model_module_version\": \"1.2.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/base\", \"_model_module_version\": \"1.2.0\", \"_model_name\": \"LayoutModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"LayoutView\", \"align_content\": null, \"align_items\": null, \"align_self\": null, \"border\": null, \"bottom\": null, \"display\": null, \"flex\": null, \"flex_flow\": null, \"grid_area\": null, \"grid_auto_columns\": null, \"grid_auto_flow\": null, \"grid_auto_rows\": null, \"grid_column\": null, \"grid_gap\": null, \"grid_row\": null, \"grid_template_areas\": null, \"grid_template_columns\": null, \"grid_template_rows\": null, \"height\": null, \"justify_content\": null, \"justify_items\": null, \"left\": null, \"margin\": null, \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"object_fit\": null, \"object_position\": null, \"order\": null, \"overflow\": null, \"overflow_x\": null, \"overflow_y\": null, \"padding\": null, \"right\": null, \"top\": null, \"visibility\": null, \"width\": null}}, \"6c270123ee254b159c45605a5ac865db\": {\"model_name\": \"DescriptionStyleModel\", \"model_module\": \"@jupyter-widgets/controls\", \"model_module_version\": \"1.5.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/controls\", \"_model_module_version\": \"1.5.0\", \"_model_name\": \"DescriptionStyleModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"StyleView\", \"description_width\": \"\"}}, \"9b97e25a5de244deb5f14f39f45c6462\": {\"model_name\": \"HTMLModel\", \"model_module\": \"@jupyter-widgets/controls\", \"model_module_version\": \"1.5.0\", \"state\": {\"_dom_classes\": [], \"_model_module\": \"@jupyter-widgets/controls\", \"_model_module_version\": \"1.5.0\", \"_model_name\": \"HTMLModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/controls\", \"_view_module_version\": \"1.5.0\", \"_view_name\": \"HTMLView\", \"description\": \"\", \"description_tooltip\": null, \"layout\": \"IPY_MODEL_12b0cdcfbb584e8eba4140c8309479f1\", \"placeholder\": \"\\u200b\", \"style\": \"IPY_MODEL_6c270123ee254b159c45605a5ac865db\", \"value\": \"100%\"}}, \"016fc318ad244a9bbb74e10f3b52c083\": {\"model_name\": \"LayoutModel\", \"model_module\": \"@jupyter-widgets/base\", \"model_module_version\": \"1.2.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/base\", \"_model_module_version\": \"1.2.0\", \"_model_name\": \"LayoutModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"LayoutView\", \"align_content\": null, \"align_items\": null, \"align_self\": null, \"border\": null, \"bottom\": null, \"display\": null, \"flex\": null, \"flex_flow\": null, \"grid_area\": null, \"grid_auto_columns\": null, \"grid_auto_flow\": null, \"grid_auto_rows\": null, \"grid_column\": null, \"grid_gap\": null, \"grid_row\": null, \"grid_template_areas\": null, \"grid_template_columns\": null, \"grid_template_rows\": null, \"height\": null, \"justify_content\": null, \"justify_items\": null, \"left\": null, \"margin\": null, \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"object_fit\": null, \"object_position\": null, \"order\": null, \"overflow\": null, \"overflow_x\": null, \"overflow_y\": null, \"padding\": null, \"right\": null, \"top\": null, \"visibility\": null, \"width\": null}}, \"091115de01f742ae8eb17466596bba96\": {\"model_name\": \"DescriptionStyleModel\", \"model_module\": \"@jupyter-widgets/controls\", \"model_module_version\": \"1.5.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/controls\", \"_model_module_version\": \"1.5.0\", \"_model_name\": \"DescriptionStyleModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"StyleView\", \"description_width\": \"\"}}, \"ba872c5ed8ad4f39be4ad24057fc5724\": {\"model_name\": \"HTMLModel\", \"model_module\": \"@jupyter-widgets/controls\", \"model_module_version\": \"1.5.0\", \"state\": {\"_dom_classes\": [], \"_model_module\": \"@jupyter-widgets/controls\", \"_model_module_version\": \"1.5.0\", \"_model_name\": \"HTMLModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/controls\", \"_view_module_version\": \"1.5.0\", \"_view_name\": \"HTMLView\", \"description\": \"\", \"description_tooltip\": null, \"layout\": \"IPY_MODEL_016fc318ad244a9bbb74e10f3b52c083\", \"placeholder\": \"\\u200b\", \"style\": \"IPY_MODEL_091115de01f742ae8eb17466596bba96\", \"value\": \" 100/100 [00:20&lt;00:00, 4.96it/s]\"}}, \"11fd0bbc7dc54811a88c7d88705153f6\": {\"model_name\": \"LayoutModel\", \"model_module\": \"@jupyter-widgets/base\", \"model_module_version\": \"1.2.0\", \"state\": {\"_model_module\": \"@jupyter-widgets/base\", \"_model_module_version\": \"1.2.0\", \"_model_name\": \"LayoutModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/base\", \"_view_module_version\": \"1.2.0\", \"_view_name\": \"LayoutView\", \"align_content\": null, \"align_items\": null, \"align_self\": null, \"border\": null, \"bottom\": null, \"display\": null, \"flex\": null, \"flex_flow\": null, \"grid_area\": null, \"grid_auto_columns\": null, \"grid_auto_flow\": null, \"grid_auto_rows\": null, \"grid_column\": null, \"grid_gap\": null, \"grid_row\": null, \"grid_template_areas\": null, \"grid_template_columns\": null, \"grid_template_rows\": null, \"height\": null, \"justify_content\": null, \"justify_items\": null, \"left\": null, \"margin\": null, \"max_height\": null, \"max_width\": null, \"min_height\": null, \"min_width\": null, \"object_fit\": null, \"object_position\": null, \"order\": null, \"overflow\": null, \"overflow_x\": null, \"overflow_y\": null, \"padding\": null, \"right\": null, \"top\": null, \"visibility\": null, \"width\": null}}, \"da4ded8cd54a4191adf92cb7e70cce31\": {\"model_name\": \"HBoxModel\", \"model_module\": \"@jupyter-widgets/controls\", \"model_module_version\": \"1.5.0\", \"state\": {\"_dom_classes\": [], \"_model_module\": \"@jupyter-widgets/controls\", \"_model_module_version\": \"1.5.0\", \"_model_name\": \"HBoxModel\", \"_view_count\": null, \"_view_module\": \"@jupyter-widgets/controls\", \"_view_module_version\": \"1.5.0\", \"_view_name\": \"HBoxView\", \"box_style\": \"\", \"children\": [\"IPY_MODEL_9b97e25a5de244deb5f14f39f45c6462\", \"IPY_MODEL_09848e34af634b95a86b940f0c097d0b\", \"IPY_MODEL_ba872c5ed8ad4f39be4ad24057fc5724\"], \"layout\": \"IPY_MODEL_11fd0bbc7dc54811a88c7d88705153f6\"}}}, \"version_major\": 2, \"version_minor\": 0}","title":"Interpretation"},{"location":"05-casestudies/01-gameofthrones/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); % load_ext autoreload % autoreload 2 % matplotlib inline % config InlineBackend . figure_format = 'retina' import pandas as pd import networkx as nx import community import numpy as np import matplotlib.pyplot as plt Introduction In this chapter, we will use Game of Thrones as a case study to practice our newly learnt skills of network analysis. It is suprising right? What is the relationship between a fatansy TV show/novel and network science or Python(not dragons). If you haven't heard of Game of Thrones, then you must be really good at hiding. Game of Thrones is a hugely popular television series by HBO based on the (also) hugely popular book series A Song of Ice and Fire by George R.R. Martin. In this notebook, we will analyze the co-occurrence network of the characters in the Game of Thrones books. Here, two characters are considered to co-occur if their names appear in the vicinity of 15 words from one another in the books. The figure below is a precusor of what we will analyse in this chapter. The dataset is publicly avaiable for the 5 books at https://github.com/mathbeveridge/asoiaf. This is an interaction network and were created by connecting two characters whenever their names (or nicknames) appeared within 15 words of one another in one of the books. The edge weight corresponds to the number of interactions. Blog: https://networkofthrones.wordpress.com from nams import load_data as cf books = cf . load_game_of_thrones_data () The resulting DataFrame books has 5 columns: Source, Target, Type, weight, and book. Source and target are the two nodes that are linked by an edge. As we know a network can have directed or undirected edges and in this network all the edges are undirected. The weight attribute of every edge tells us the number of interactions that the characters have had over the book, and the book column tells us the book number. Let's have a look at the data. # We also add this weight_inv to our dataset. # Why? we will discuss it in a later section. books [ 'weight_inv' ] = 1 / books . weight books . head () id Source Target Type weight book weight_inv 0 Addam-Marbrand Jaime-Lannister Undirected 3 1 0.333333 1 Addam-Marbrand Tywin-Lannister Undirected 6 1 0.166667 2 Aegon-I-Targaryen Daenerys-Targaryen Undirected 5 1 0.2 3 Aegon-I-Targaryen Eddard-Stark Undirected 4 1 0.25 4 Aemon-Targaryen-(Maester-Aemon) Alliser-Thorne Undirected 4 1 0.25 From the above data we can see that the characters Addam Marbrand and Tywin Lannister have interacted 6 times in the first book. We can investigate this data by using the pandas DataFrame. Let's find all the interactions of Robb Stark in the third book. robbstark = ( books . query ( \"book == 3\" ) . query ( \"Source == 'Robb-Stark' or Target == 'Robb-Stark'\" ) ) robbstark . head () id Source Target Type weight book weight_inv 1468 Aegon-Frey-(son-of-Stevron) Robb-Stark Undirected 5 3 0.2 1582 Arya-Stark Robb-Stark Undirected 14 3 0.0714286 1604 Balon-Greyjoy Robb-Stark Undirected 6 3 0.166667 1677 Bran-Stark Robb-Stark Undirected 18 3 0.0555556 1683 Brandon-Stark Robb-Stark Undirected 3 3 0.333333 As you can see this data easily translates to a network problem. Now it's time to create a network. We create a graph for each book. It's possible to create one MultiGraph (Graph with multiple edges between nodes) instead of 5 graphs, but it is easier to analyse and manipulate individual Graph objects rather than a MultiGraph . # example of creating a MultiGraph # all_books_multigraph = nx.from_pandas_edgelist( # books, source='Source', target='Target', # edge_attr=['weight', 'book'], # create_using=nx.MultiGraph) # we create a list of graph objects using # nx.from_pandas_edgelist and specifying # the edge attributes. graphs = [ nx . from_pandas_edgelist ( books [ books . book == i ], source = 'Source' , target = 'Target' , edge_attr = [ 'weight' , 'weight_inv' ]) for i in range ( 1 , 6 )] # The Graph object associated with the first book. graphs [ 0 ] <networkx.classes.graph.Graph at 0x7f676403c940> # To access the relationship edges in the graph with # the edge attribute weight data (data=True) relationships = list ( graphs [ 0 ] . edges ( data = True )) relationships [ 0 : 3 ] [('Addam-Marbrand', 'Jaime-Lannister', {'weight': 3, 'weight_inv': 0.3333333333333333}), ('Addam-Marbrand', 'Tywin-Lannister', {'weight': 6, 'weight_inv': 0.16666666666666666}), ('Jaime-Lannister', 'Aerys-II-Targaryen', {'weight': 5, 'weight_inv': 0.2})] Finding the most important node i.e character in these networks. Let's use our network analysis knowledge to decrypt these Graphs that we have just created. Is it Jon Snow, Tyrion, Daenerys, or someone else? Let's see! Network Science offers us many different metrics to measure the importance of a node in a network as we saw in the first part of the tutorial. Note that there is no \"correct\" way of calculating the most important node in a network, every metric has a different meaning. First, let's measure the importance of a node in a network by looking at the number of neighbors it has, that is, the number of nodes it is connected to. For example, an influential account on Twitter, where the follower-followee relationship forms the network, is an account which has a high number of followers. This measure of importance is called degree centrality. Using this measure, let's extract the top ten important characters from the first book ( graphs[0] ) and the fifth book ( graphs[4] ). NOTE: We are using zero-indexing and that's why the graph of the first book is acceseed by graphs[0] . # We use the in-built degree_centrality method deg_cen_book1 = nx . degree_centrality ( graphs [ 0 ]) deg_cen_book5 = nx . degree_centrality ( graphs [ 4 ]) degree_centrality returns a dictionary and to access the results we can directly use the name of the character. deg_cen_book1 [ 'Daenerys-Targaryen' ] 0.11290322580645162 Top 5 important characters in the first book according to degree centrality. # The following expression sorts the dictionary by # degree centrality and returns the top 5 from a graph sorted ( deg_cen_book1 . items (), key = lambda x : x [ 1 ], reverse = True )[ 0 : 5 ] [('Eddard-Stark', 0.3548387096774194), ('Robert-Baratheon', 0.2688172043010753), ('Tyrion-Lannister', 0.24731182795698928), ('Catelyn-Stark', 0.23118279569892475), ('Jon-Snow', 0.19892473118279572)] Top 5 important characters in the fifth book according to degree centrality. sorted ( deg_cen_book5 . items (), key = lambda x : x [ 1 ], reverse = True )[ 0 : 5 ] [('Jon-Snow', 0.1962025316455696), ('Daenerys-Targaryen', 0.18354430379746836), ('Stannis-Baratheon', 0.14873417721518986), ('Tyrion-Lannister', 0.10443037974683544), ('Theon-Greyjoy', 0.10443037974683544)] To visualize the distribution of degree centrality let's plot a histogram of degree centrality. plt . hist ( deg_cen_book1 . values (), bins = 30 ) plt . show () The above plot shows something that is expected, a high portion of characters aren't connected to lot of other characters while some characters are highly connected all through the network. A close real world example of this is a social network like Twitter where a few people have millions of connections(followers) but majority of users aren't connected to that many other users. This exponential decay like property resembles power law in real life networks. # A log-log plot to show the \"signature\" of power law in graphs. from collections import Counter hist = Counter ( deg_cen_book1 . values ()) plt . scatter ( np . log2 ( list ( hist . keys ())), np . log2 ( list ( hist . values ())), alpha = 0.9 ) plt . show () Exercise Create a new centrality measure, weighted_degree(Graph, weight) which takes in Graph and the weight attribute and returns a weighted degree dictionary. Weighted degree is calculated by summing the weight of the all edges of a node and find the top five characters according to this measure. from nams.solutions.got import weighted_degree plt . hist ( list ( weighted_degree ( graphs [ 0 ], 'weight' ) . values ()), bins = 30 ) plt . show () sorted ( weighted_degree ( graphs [ 0 ], 'weight' ) . items (), key = lambda x : x [ 1 ], reverse = True )[ 0 : 5 ] [('Eddard-Stark', 1284), ('Robert-Baratheon', 941), ('Jon-Snow', 784), ('Tyrion-Lannister', 650), ('Sansa-Stark', 545)] Betweeness centrality Let's do this for Betweeness centrality and check if this makes any difference. As different centrality method use different measures underneath, they find nodes which are important in the network. A centrality method like Betweeness centrality finds nodes which are structurally important to the network, which binds the network together and densely. # First check unweighted (just the structure) sorted ( nx . betweenness_centrality ( graphs [ 0 ]) . items (), key = lambda x : x [ 1 ], reverse = True )[ 0 : 10 ] [('Eddard-Stark', 0.2696038913836117), ('Robert-Baratheon', 0.21403028397371796), ('Tyrion-Lannister', 0.1902124972697492), ('Jon-Snow', 0.17158135899829566), ('Catelyn-Stark', 0.1513952715347627), ('Daenerys-Targaryen', 0.08627015537511595), ('Robb-Stark', 0.07298399629664767), ('Drogo', 0.06481224290874964), ('Bran-Stark', 0.05579958811784442), ('Sansa-Stark', 0.03714483664326785)] # Let's care about interactions now sorted ( nx . betweenness_centrality ( graphs [ 0 ], weight = 'weight_inv' ) . items (), key = lambda x : x [ 1 ], reverse = True )[ 0 : 10 ] [('Eddard-Stark', 0.5926474861958733), ('Catelyn-Stark', 0.36855565242662014), ('Jon-Snow', 0.3514094739901191), ('Robert-Baratheon', 0.3329991281604185), ('Tyrion-Lannister', 0.27137460040685846), ('Daenerys-Targaryen', 0.202615518744551), ('Bran-Stark', 0.0945655332752107), ('Robb-Stark', 0.09177564661435629), ('Arya-Stark', 0.06939843068875327), ('Sansa-Stark', 0.06870095902353966)] We can see there are some differences between the unweighted and weighted centrality measures. Another thing to note is that we are using the weight_inv attribute instead of weight(the number of interactions between characters). This decision is based on the way we want to assign the notion of \"importance\" of a character. The basic idea behind betweenness centrality is to find nodes which are essential to the structure of the network. As betweenness centrality computes shortest paths underneath, in the case of weighted betweenness centrality it will end up penalising characters with high number of interactions. By using weight_inv we will prop up the characters with high interactions with other characters. PageRank The billion dollar algorithm, PageRank works by counting the number and quality of links to a page to determine a rough estimate of how important the website is. The underlying assumption is that more important websites are likely to receive more links from other websites. NOTE: We don't need to worry about weight and weight_inv in PageRank as the algorithm uses weights in the opposite sense (larger weights are better). This may seem confusing as different centrality measures have different definition of weights. So it is always better to have a look at documentation before using weights in a centrality measure. # by default weight attribute in PageRank is weight # so we use weight=None to find the unweighted results sorted ( nx . pagerank_numpy ( graphs [ 0 ], weight = None ) . items (), key = lambda x : x [ 1 ], reverse = True )[ 0 : 10 ] [('Eddard-Stark', 0.04552079222830671), ('Tyrion-Lannister', 0.03301362462493269), ('Catelyn-Stark', 0.030193105286631914), ('Robert-Baratheon', 0.02983474222773675), ('Jon-Snow', 0.02683449952206619), ('Robb-Stark', 0.021562941297247524), ('Sansa-Stark', 0.020008034042864654), ('Bran-Stark', 0.019945786786238318), ('Jaime-Lannister', 0.017507847202846937), ('Cersei-Lannister', 0.017082604584758087)] sorted ( nx . pagerank_numpy ( graphs [ 0 ], weight = 'weight' ) . items (), key = lambda x : x [ 1 ], reverse = True )[ 0 : 10 ] [('Eddard-Stark', 0.0723940110049824), ('Robert-Baratheon', 0.0485172757050994), ('Jon-Snow', 0.04770689062474911), ('Tyrion-Lannister', 0.04367437892706296), ('Catelyn-Stark', 0.034667034701307414), ('Bran-Stark', 0.029774200539800212), ('Robb-Stark', 0.02921618364519686), ('Daenerys-Targaryen', 0.027089622513021085), ('Sansa-Stark', 0.026961778915683125), ('Cersei-Lannister', 0.02163167939741897)] Exercise Is there a correlation between these techniques? Find the correlation between these four techniques. pagerank (weight = 'weight') betweenness_centrality (weight = 'weight_inv') weighted_degree degree centrality HINT: Use pandas correlation from nams.solutions.got import correlation_centrality correlation_centrality ( graphs [ 0 ]) 0 1 2 3 0 1 0.910352 0.992166 0.949307 1 0.910352 1 0.87924 0.790526 2 0.992166 0.87924 1 0.95506 3 0.949307 0.790526 0.95506 1 Evolution of importance of characters over the books According to degree centrality the most important character in the first book is Eddard Stark but he is not even in the top 10 of the fifth book. The importance changes over the course of five books, because you know stuff happens ;) Let's look at the evolution of degree centrality of a couple of characters like Eddard Stark, Jon Snow, Tyrion which showed up in the top 10 of degree centrality in first book. We create a dataframe with character columns and index as books where every entry is the degree centrality of the character in that particular book and plot the evolution of degree centrality Eddard Stark, Jon Snow and Tyrion. We can see that the importance of Eddard Stark in the network dies off and with Jon Snow there is a drop in the fourth book but a sudden rise in the fifth book evol = [ nx . degree_centrality ( graph ) for graph in graphs ] evol_df = pd . DataFrame . from_records ( evol ) . fillna ( 0 ) evol_df [[ 'Eddard-Stark' , 'Tyrion-Lannister' , 'Jon-Snow' ]] . plot () plt . show () set_of_char = set () for i in range ( 5 ): set_of_char |= set ( list ( evol_df . T [ i ] . sort_values ( ascending = False )[ 0 : 5 ] . index )) set_of_char {'Arya-Stark', 'Brienne-of-Tarth', 'Catelyn-Stark', 'Cersei-Lannister', 'Daenerys-Targaryen', 'Eddard-Stark', 'Jaime-Lannister', 'Joffrey-Baratheon', 'Jon-Snow', 'Margaery-Tyrell', 'Robb-Stark', 'Robert-Baratheon', 'Sansa-Stark', 'Stannis-Baratheon', 'Theon-Greyjoy', 'Tyrion-Lannister'} Exercise Plot the evolution of betweenness centrality of the above mentioned characters over the 5 books. from nams.solutions.got import evol_betweenness evol_betweenness ( graphs ) So what's up with Stannis Baratheon? sorted ( nx . degree_centrality ( graphs [ 4 ]) . items (), key = lambda x : x [ 1 ], reverse = True )[: 5 ] [('Jon-Snow', 0.1962025316455696), ('Daenerys-Targaryen', 0.18354430379746836), ('Stannis-Baratheon', 0.14873417721518986), ('Tyrion-Lannister', 0.10443037974683544), ('Theon-Greyjoy', 0.10443037974683544)] sorted ( nx . betweenness_centrality ( graphs [ 4 ]) . items (), key = lambda x : x [ 1 ], reverse = True )[: 5 ] [('Stannis-Baratheon', 0.45283060689247934), ('Daenerys-Targaryen', 0.2959459062106149), ('Jon-Snow', 0.24484873673158666), ('Tyrion-Lannister', 0.20961613179551256), ('Robert-Baratheon', 0.17716906651536968)] nx . draw ( nx . barbell_graph ( 5 , 1 ), with_labels = True ) As we know the a higher betweenness centrality means that the node is crucial for the structure of the network, and in the case of Stannis Baratheon in the fifth book it seems like Stannis Baratheon has characterstics similar to that of node 5 in the above example as it seems to be the holding the network together. As evident from the betweenness centrality scores of the above example of barbell graph, node 5 is the most important node in this network. nx . betweenness_centrality ( nx . barbell_graph ( 5 , 1 )) {0: 0.0, 1: 0.0, 2: 0.0, 3: 0.0, 4: 0.5333333333333333, 6: 0.5333333333333333, 7: 0.0, 8: 0.0, 9: 0.0, 10: 0.0, 5: 0.5555555555555556} Community detection in Networks A network is said to have community structure if the nodes of the network can be easily grouped into (potentially overlapping) sets of nodes such that each set of nodes is densely connected internally. There are multiple algorithms and definitions to calculate these communites in a network. We will use louvain community detection algorithm to find the modules in our graph. import nxviz as nv from nxviz import annotate plt . figure ( figsize = ( 8 , 8 )) partition = community . best_partition ( graphs [ 0 ], randomize = False ) # Annotate nodes' partitions for n in graphs [ 0 ] . nodes (): graphs [ 0 ] . nodes [ n ][ \"partition\" ] = partition [ n ] graphs [ 0 ] . nodes [ n ][ \"degree\" ] = graphs [ 0 ] . degree ( n ) nv . matrix ( graphs [ 0 ], group_by = \"partition\" , sort_by = \"degree\" , node_color_by = \"partition\" ) annotate . matrix_block ( graphs [ 0 ], group_by = \"partition\" , color_by = \"partition\" ) annotate . matrix_group ( graphs [ 0 ], group_by = \"partition\" , offset =- 8 ) /home/runner/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.0 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.6.3, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( A common defining quality of a community is that the within-community edges are denser than the between-community edges. # louvain community detection find us 8 different set of communities partition_dict = {} for character , par in partition . items (): if par in partition_dict : partition_dict [ par ] . append ( character ) else : partition_dict [ par ] = [ character ] len ( partition_dict ) 8 partition_dict [ 2 ] ['Bran-Stark', 'Rickon-Stark', 'Robb-Stark', 'Luwin', 'Theon-Greyjoy', 'Hali', 'Hallis-Mollen', 'Hodor', 'Hullen', 'Joseth', 'Nan', 'Osha', 'Rickard-Karstark', 'Rickard-Stark', 'Stiv', 'Jon-Umber-(Greatjon)', 'Galbart-Glover', 'Roose-Bolton', 'Maege-Mormont'] If we plot these communities of the network we see a denser network as compared to the original network which contains all the characters. nx . draw ( nx . subgraph ( graphs [ 0 ], partition_dict [ 3 ])) nx . draw ( nx . subgraph ( graphs [ 0 ], partition_dict [ 1 ])) We can test this by calculating the density of the network and the community. Like in the following example the network between characters in a community is 5 times more dense than the original network. nx . density ( nx . subgraph ( graphs [ 0 ], partition_dict [ 4 ]) ) / nx . density ( graphs [ 0 ]) 25.42543859649123 Exercise Find the most important node in the partitions according to degree centrality of the nodes using the partition_dict we have already created. from nams.solutions.got import most_important_node_in_partition most_important_node_in_partition ( graphs [ 0 ], partition_dict ) {7: 'Tyrion-Lannister', 1: 'Daenerys-Targaryen', 6: 'Eddard-Stark', 3: 'Jon-Snow', 5: 'Sansa-Stark', 2: 'Robb-Stark', 0: 'Waymar-Royce', 4: 'Danwell-Frey'} Solutions Here are the solutions to the exercises above. from nams.solutions import got import inspect print ( inspect . getsource ( got )) import pandas as pd import networkx as nx def weighted_degree(G, weight): result = dict() for node in G.nodes(): weight_degree = 0 for n in G.edges([node], data=True): weight_degree += n[2][\"weight\"] result[node] = weight_degree return result def correlation_centrality(G): cor = pd.DataFrame.from_records( [ nx.pagerank_numpy(G, weight=\"weight\"), nx.betweenness_centrality(G, weight=\"weight_inv\"), weighted_degree(G, \"weight\"), nx.degree_centrality(G), ] ) return cor.T.corr() def evol_betweenness(graphs): evol = [nx.betweenness_centrality(graph, weight=\"weight_inv\") for graph in graphs] evol_df = pd.DataFrame.from_records(evol).fillna(0) set_of_char = set() for i in range(5): set_of_char |= set(list(evol_df.T[i].sort_values(ascending=False)[0:5].index)) evol_df[list(set_of_char)].plot(figsize=(19, 10)) def most_important_node_in_partition(graph, partition_dict): max_d = {} deg = nx.degree_centrality(graph) for group in partition_dict: temp = 0 for character in partition_dict[group]: if deg[character] > temp: max_d[group] = character temp = deg[character] return max_d","title":"Chapter 12: Game of Thrones"},{"location":"05-casestudies/01-gameofthrones/#introduction","text":"In this chapter, we will use Game of Thrones as a case study to practice our newly learnt skills of network analysis. It is suprising right? What is the relationship between a fatansy TV show/novel and network science or Python(not dragons). If you haven't heard of Game of Thrones, then you must be really good at hiding. Game of Thrones is a hugely popular television series by HBO based on the (also) hugely popular book series A Song of Ice and Fire by George R.R. Martin. In this notebook, we will analyze the co-occurrence network of the characters in the Game of Thrones books. Here, two characters are considered to co-occur if their names appear in the vicinity of 15 words from one another in the books. The figure below is a precusor of what we will analyse in this chapter. The dataset is publicly avaiable for the 5 books at https://github.com/mathbeveridge/asoiaf. This is an interaction network and were created by connecting two characters whenever their names (or nicknames) appeared within 15 words of one another in one of the books. The edge weight corresponds to the number of interactions. Blog: https://networkofthrones.wordpress.com from nams import load_data as cf books = cf . load_game_of_thrones_data () The resulting DataFrame books has 5 columns: Source, Target, Type, weight, and book. Source and target are the two nodes that are linked by an edge. As we know a network can have directed or undirected edges and in this network all the edges are undirected. The weight attribute of every edge tells us the number of interactions that the characters have had over the book, and the book column tells us the book number. Let's have a look at the data. # We also add this weight_inv to our dataset. # Why? we will discuss it in a later section. books [ 'weight_inv' ] = 1 / books . weight books . head () id Source Target Type weight book weight_inv 0 Addam-Marbrand Jaime-Lannister Undirected 3 1 0.333333 1 Addam-Marbrand Tywin-Lannister Undirected 6 1 0.166667 2 Aegon-I-Targaryen Daenerys-Targaryen Undirected 5 1 0.2 3 Aegon-I-Targaryen Eddard-Stark Undirected 4 1 0.25 4 Aemon-Targaryen-(Maester-Aemon) Alliser-Thorne Undirected 4 1 0.25 From the above data we can see that the characters Addam Marbrand and Tywin Lannister have interacted 6 times in the first book. We can investigate this data by using the pandas DataFrame. Let's find all the interactions of Robb Stark in the third book. robbstark = ( books . query ( \"book == 3\" ) . query ( \"Source == 'Robb-Stark' or Target == 'Robb-Stark'\" ) ) robbstark . head () id Source Target Type weight book weight_inv 1468 Aegon-Frey-(son-of-Stevron) Robb-Stark Undirected 5 3 0.2 1582 Arya-Stark Robb-Stark Undirected 14 3 0.0714286 1604 Balon-Greyjoy Robb-Stark Undirected 6 3 0.166667 1677 Bran-Stark Robb-Stark Undirected 18 3 0.0555556 1683 Brandon-Stark Robb-Stark Undirected 3 3 0.333333 As you can see this data easily translates to a network problem. Now it's time to create a network. We create a graph for each book. It's possible to create one MultiGraph (Graph with multiple edges between nodes) instead of 5 graphs, but it is easier to analyse and manipulate individual Graph objects rather than a MultiGraph . # example of creating a MultiGraph # all_books_multigraph = nx.from_pandas_edgelist( # books, source='Source', target='Target', # edge_attr=['weight', 'book'], # create_using=nx.MultiGraph) # we create a list of graph objects using # nx.from_pandas_edgelist and specifying # the edge attributes. graphs = [ nx . from_pandas_edgelist ( books [ books . book == i ], source = 'Source' , target = 'Target' , edge_attr = [ 'weight' , 'weight_inv' ]) for i in range ( 1 , 6 )] # The Graph object associated with the first book. graphs [ 0 ] <networkx.classes.graph.Graph at 0x7f676403c940> # To access the relationship edges in the graph with # the edge attribute weight data (data=True) relationships = list ( graphs [ 0 ] . edges ( data = True )) relationships [ 0 : 3 ] [('Addam-Marbrand', 'Jaime-Lannister', {'weight': 3, 'weight_inv': 0.3333333333333333}), ('Addam-Marbrand', 'Tywin-Lannister', {'weight': 6, 'weight_inv': 0.16666666666666666}), ('Jaime-Lannister', 'Aerys-II-Targaryen', {'weight': 5, 'weight_inv': 0.2})]","title":"Introduction"},{"location":"05-casestudies/01-gameofthrones/#finding-the-most-important-node-ie-character-in-these-networks","text":"Let's use our network analysis knowledge to decrypt these Graphs that we have just created. Is it Jon Snow, Tyrion, Daenerys, or someone else? Let's see! Network Science offers us many different metrics to measure the importance of a node in a network as we saw in the first part of the tutorial. Note that there is no \"correct\" way of calculating the most important node in a network, every metric has a different meaning. First, let's measure the importance of a node in a network by looking at the number of neighbors it has, that is, the number of nodes it is connected to. For example, an influential account on Twitter, where the follower-followee relationship forms the network, is an account which has a high number of followers. This measure of importance is called degree centrality. Using this measure, let's extract the top ten important characters from the first book ( graphs[0] ) and the fifth book ( graphs[4] ). NOTE: We are using zero-indexing and that's why the graph of the first book is acceseed by graphs[0] . # We use the in-built degree_centrality method deg_cen_book1 = nx . degree_centrality ( graphs [ 0 ]) deg_cen_book5 = nx . degree_centrality ( graphs [ 4 ]) degree_centrality returns a dictionary and to access the results we can directly use the name of the character. deg_cen_book1 [ 'Daenerys-Targaryen' ] 0.11290322580645162 Top 5 important characters in the first book according to degree centrality. # The following expression sorts the dictionary by # degree centrality and returns the top 5 from a graph sorted ( deg_cen_book1 . items (), key = lambda x : x [ 1 ], reverse = True )[ 0 : 5 ] [('Eddard-Stark', 0.3548387096774194), ('Robert-Baratheon', 0.2688172043010753), ('Tyrion-Lannister', 0.24731182795698928), ('Catelyn-Stark', 0.23118279569892475), ('Jon-Snow', 0.19892473118279572)] Top 5 important characters in the fifth book according to degree centrality. sorted ( deg_cen_book5 . items (), key = lambda x : x [ 1 ], reverse = True )[ 0 : 5 ] [('Jon-Snow', 0.1962025316455696), ('Daenerys-Targaryen', 0.18354430379746836), ('Stannis-Baratheon', 0.14873417721518986), ('Tyrion-Lannister', 0.10443037974683544), ('Theon-Greyjoy', 0.10443037974683544)] To visualize the distribution of degree centrality let's plot a histogram of degree centrality. plt . hist ( deg_cen_book1 . values (), bins = 30 ) plt . show () The above plot shows something that is expected, a high portion of characters aren't connected to lot of other characters while some characters are highly connected all through the network. A close real world example of this is a social network like Twitter where a few people have millions of connections(followers) but majority of users aren't connected to that many other users. This exponential decay like property resembles power law in real life networks. # A log-log plot to show the \"signature\" of power law in graphs. from collections import Counter hist = Counter ( deg_cen_book1 . values ()) plt . scatter ( np . log2 ( list ( hist . keys ())), np . log2 ( list ( hist . values ())), alpha = 0.9 ) plt . show ()","title":"Finding the most important node i.e character in these networks."},{"location":"05-casestudies/01-gameofthrones/#exercise","text":"Create a new centrality measure, weighted_degree(Graph, weight) which takes in Graph and the weight attribute and returns a weighted degree dictionary. Weighted degree is calculated by summing the weight of the all edges of a node and find the top five characters according to this measure. from nams.solutions.got import weighted_degree plt . hist ( list ( weighted_degree ( graphs [ 0 ], 'weight' ) . values ()), bins = 30 ) plt . show () sorted ( weighted_degree ( graphs [ 0 ], 'weight' ) . items (), key = lambda x : x [ 1 ], reverse = True )[ 0 : 5 ] [('Eddard-Stark', 1284), ('Robert-Baratheon', 941), ('Jon-Snow', 784), ('Tyrion-Lannister', 650), ('Sansa-Stark', 545)]","title":"Exercise"},{"location":"05-casestudies/01-gameofthrones/#betweeness-centrality","text":"Let's do this for Betweeness centrality and check if this makes any difference. As different centrality method use different measures underneath, they find nodes which are important in the network. A centrality method like Betweeness centrality finds nodes which are structurally important to the network, which binds the network together and densely. # First check unweighted (just the structure) sorted ( nx . betweenness_centrality ( graphs [ 0 ]) . items (), key = lambda x : x [ 1 ], reverse = True )[ 0 : 10 ] [('Eddard-Stark', 0.2696038913836117), ('Robert-Baratheon', 0.21403028397371796), ('Tyrion-Lannister', 0.1902124972697492), ('Jon-Snow', 0.17158135899829566), ('Catelyn-Stark', 0.1513952715347627), ('Daenerys-Targaryen', 0.08627015537511595), ('Robb-Stark', 0.07298399629664767), ('Drogo', 0.06481224290874964), ('Bran-Stark', 0.05579958811784442), ('Sansa-Stark', 0.03714483664326785)] # Let's care about interactions now sorted ( nx . betweenness_centrality ( graphs [ 0 ], weight = 'weight_inv' ) . items (), key = lambda x : x [ 1 ], reverse = True )[ 0 : 10 ] [('Eddard-Stark', 0.5926474861958733), ('Catelyn-Stark', 0.36855565242662014), ('Jon-Snow', 0.3514094739901191), ('Robert-Baratheon', 0.3329991281604185), ('Tyrion-Lannister', 0.27137460040685846), ('Daenerys-Targaryen', 0.202615518744551), ('Bran-Stark', 0.0945655332752107), ('Robb-Stark', 0.09177564661435629), ('Arya-Stark', 0.06939843068875327), ('Sansa-Stark', 0.06870095902353966)] We can see there are some differences between the unweighted and weighted centrality measures. Another thing to note is that we are using the weight_inv attribute instead of weight(the number of interactions between characters). This decision is based on the way we want to assign the notion of \"importance\" of a character. The basic idea behind betweenness centrality is to find nodes which are essential to the structure of the network. As betweenness centrality computes shortest paths underneath, in the case of weighted betweenness centrality it will end up penalising characters with high number of interactions. By using weight_inv we will prop up the characters with high interactions with other characters.","title":"Betweeness centrality"},{"location":"05-casestudies/01-gameofthrones/#pagerank","text":"The billion dollar algorithm, PageRank works by counting the number and quality of links to a page to determine a rough estimate of how important the website is. The underlying assumption is that more important websites are likely to receive more links from other websites. NOTE: We don't need to worry about weight and weight_inv in PageRank as the algorithm uses weights in the opposite sense (larger weights are better). This may seem confusing as different centrality measures have different definition of weights. So it is always better to have a look at documentation before using weights in a centrality measure. # by default weight attribute in PageRank is weight # so we use weight=None to find the unweighted results sorted ( nx . pagerank_numpy ( graphs [ 0 ], weight = None ) . items (), key = lambda x : x [ 1 ], reverse = True )[ 0 : 10 ] [('Eddard-Stark', 0.04552079222830671), ('Tyrion-Lannister', 0.03301362462493269), ('Catelyn-Stark', 0.030193105286631914), ('Robert-Baratheon', 0.02983474222773675), ('Jon-Snow', 0.02683449952206619), ('Robb-Stark', 0.021562941297247524), ('Sansa-Stark', 0.020008034042864654), ('Bran-Stark', 0.019945786786238318), ('Jaime-Lannister', 0.017507847202846937), ('Cersei-Lannister', 0.017082604584758087)] sorted ( nx . pagerank_numpy ( graphs [ 0 ], weight = 'weight' ) . items (), key = lambda x : x [ 1 ], reverse = True )[ 0 : 10 ] [('Eddard-Stark', 0.0723940110049824), ('Robert-Baratheon', 0.0485172757050994), ('Jon-Snow', 0.04770689062474911), ('Tyrion-Lannister', 0.04367437892706296), ('Catelyn-Stark', 0.034667034701307414), ('Bran-Stark', 0.029774200539800212), ('Robb-Stark', 0.02921618364519686), ('Daenerys-Targaryen', 0.027089622513021085), ('Sansa-Stark', 0.026961778915683125), ('Cersei-Lannister', 0.02163167939741897)]","title":"PageRank"},{"location":"05-casestudies/01-gameofthrones/#exercise_1","text":"","title":"Exercise"},{"location":"05-casestudies/01-gameofthrones/#is-there-a-correlation-between-these-techniques","text":"Find the correlation between these four techniques. pagerank (weight = 'weight') betweenness_centrality (weight = 'weight_inv') weighted_degree degree centrality HINT: Use pandas correlation from nams.solutions.got import correlation_centrality correlation_centrality ( graphs [ 0 ]) 0 1 2 3 0 1 0.910352 0.992166 0.949307 1 0.910352 1 0.87924 0.790526 2 0.992166 0.87924 1 0.95506 3 0.949307 0.790526 0.95506 1","title":"Is there a correlation between these techniques?"},{"location":"05-casestudies/01-gameofthrones/#evolution-of-importance-of-characters-over-the-books","text":"According to degree centrality the most important character in the first book is Eddard Stark but he is not even in the top 10 of the fifth book. The importance changes over the course of five books, because you know stuff happens ;) Let's look at the evolution of degree centrality of a couple of characters like Eddard Stark, Jon Snow, Tyrion which showed up in the top 10 of degree centrality in first book. We create a dataframe with character columns and index as books where every entry is the degree centrality of the character in that particular book and plot the evolution of degree centrality Eddard Stark, Jon Snow and Tyrion. We can see that the importance of Eddard Stark in the network dies off and with Jon Snow there is a drop in the fourth book but a sudden rise in the fifth book evol = [ nx . degree_centrality ( graph ) for graph in graphs ] evol_df = pd . DataFrame . from_records ( evol ) . fillna ( 0 ) evol_df [[ 'Eddard-Stark' , 'Tyrion-Lannister' , 'Jon-Snow' ]] . plot () plt . show () set_of_char = set () for i in range ( 5 ): set_of_char |= set ( list ( evol_df . T [ i ] . sort_values ( ascending = False )[ 0 : 5 ] . index )) set_of_char {'Arya-Stark', 'Brienne-of-Tarth', 'Catelyn-Stark', 'Cersei-Lannister', 'Daenerys-Targaryen', 'Eddard-Stark', 'Jaime-Lannister', 'Joffrey-Baratheon', 'Jon-Snow', 'Margaery-Tyrell', 'Robb-Stark', 'Robert-Baratheon', 'Sansa-Stark', 'Stannis-Baratheon', 'Theon-Greyjoy', 'Tyrion-Lannister'}","title":"Evolution of importance of characters over the books"},{"location":"05-casestudies/01-gameofthrones/#exercise_2","text":"Plot the evolution of betweenness centrality of the above mentioned characters over the 5 books. from nams.solutions.got import evol_betweenness evol_betweenness ( graphs )","title":"Exercise"},{"location":"05-casestudies/01-gameofthrones/#so-whats-up-with-stannis-baratheon","text":"sorted ( nx . degree_centrality ( graphs [ 4 ]) . items (), key = lambda x : x [ 1 ], reverse = True )[: 5 ] [('Jon-Snow', 0.1962025316455696), ('Daenerys-Targaryen', 0.18354430379746836), ('Stannis-Baratheon', 0.14873417721518986), ('Tyrion-Lannister', 0.10443037974683544), ('Theon-Greyjoy', 0.10443037974683544)] sorted ( nx . betweenness_centrality ( graphs [ 4 ]) . items (), key = lambda x : x [ 1 ], reverse = True )[: 5 ] [('Stannis-Baratheon', 0.45283060689247934), ('Daenerys-Targaryen', 0.2959459062106149), ('Jon-Snow', 0.24484873673158666), ('Tyrion-Lannister', 0.20961613179551256), ('Robert-Baratheon', 0.17716906651536968)] nx . draw ( nx . barbell_graph ( 5 , 1 ), with_labels = True ) As we know the a higher betweenness centrality means that the node is crucial for the structure of the network, and in the case of Stannis Baratheon in the fifth book it seems like Stannis Baratheon has characterstics similar to that of node 5 in the above example as it seems to be the holding the network together. As evident from the betweenness centrality scores of the above example of barbell graph, node 5 is the most important node in this network. nx . betweenness_centrality ( nx . barbell_graph ( 5 , 1 )) {0: 0.0, 1: 0.0, 2: 0.0, 3: 0.0, 4: 0.5333333333333333, 6: 0.5333333333333333, 7: 0.0, 8: 0.0, 9: 0.0, 10: 0.0, 5: 0.5555555555555556}","title":"So what's up with Stannis Baratheon?"},{"location":"05-casestudies/01-gameofthrones/#community-detection-in-networks","text":"A network is said to have community structure if the nodes of the network can be easily grouped into (potentially overlapping) sets of nodes such that each set of nodes is densely connected internally. There are multiple algorithms and definitions to calculate these communites in a network. We will use louvain community detection algorithm to find the modules in our graph. import nxviz as nv from nxviz import annotate plt . figure ( figsize = ( 8 , 8 )) partition = community . best_partition ( graphs [ 0 ], randomize = False ) # Annotate nodes' partitions for n in graphs [ 0 ] . nodes (): graphs [ 0 ] . nodes [ n ][ \"partition\" ] = partition [ n ] graphs [ 0 ] . nodes [ n ][ \"degree\" ] = graphs [ 0 ] . degree ( n ) nv . matrix ( graphs [ 0 ], group_by = \"partition\" , sort_by = \"degree\" , node_color_by = \"partition\" ) annotate . matrix_block ( graphs [ 0 ], group_by = \"partition\" , color_by = \"partition\" ) annotate . matrix_group ( graphs [ 0 ], group_by = \"partition\" , offset =- 8 ) /home/runner/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.0 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.6.3, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( A common defining quality of a community is that the within-community edges are denser than the between-community edges. # louvain community detection find us 8 different set of communities partition_dict = {} for character , par in partition . items (): if par in partition_dict : partition_dict [ par ] . append ( character ) else : partition_dict [ par ] = [ character ] len ( partition_dict ) 8 partition_dict [ 2 ] ['Bran-Stark', 'Rickon-Stark', 'Robb-Stark', 'Luwin', 'Theon-Greyjoy', 'Hali', 'Hallis-Mollen', 'Hodor', 'Hullen', 'Joseth', 'Nan', 'Osha', 'Rickard-Karstark', 'Rickard-Stark', 'Stiv', 'Jon-Umber-(Greatjon)', 'Galbart-Glover', 'Roose-Bolton', 'Maege-Mormont'] If we plot these communities of the network we see a denser network as compared to the original network which contains all the characters. nx . draw ( nx . subgraph ( graphs [ 0 ], partition_dict [ 3 ])) nx . draw ( nx . subgraph ( graphs [ 0 ], partition_dict [ 1 ])) We can test this by calculating the density of the network and the community. Like in the following example the network between characters in a community is 5 times more dense than the original network. nx . density ( nx . subgraph ( graphs [ 0 ], partition_dict [ 4 ]) ) / nx . density ( graphs [ 0 ]) 25.42543859649123","title":"Community detection in Networks"},{"location":"05-casestudies/01-gameofthrones/#exercise_3","text":"Find the most important node in the partitions according to degree centrality of the nodes using the partition_dict we have already created. from nams.solutions.got import most_important_node_in_partition most_important_node_in_partition ( graphs [ 0 ], partition_dict ) {7: 'Tyrion-Lannister', 1: 'Daenerys-Targaryen', 6: 'Eddard-Stark', 3: 'Jon-Snow', 5: 'Sansa-Stark', 2: 'Robb-Stark', 0: 'Waymar-Royce', 4: 'Danwell-Frey'}","title":"Exercise"},{"location":"05-casestudies/01-gameofthrones/#solutions","text":"Here are the solutions to the exercises above. from nams.solutions import got import inspect print ( inspect . getsource ( got )) import pandas as pd import networkx as nx def weighted_degree(G, weight): result = dict() for node in G.nodes(): weight_degree = 0 for n in G.edges([node], data=True): weight_degree += n[2][\"weight\"] result[node] = weight_degree return result def correlation_centrality(G): cor = pd.DataFrame.from_records( [ nx.pagerank_numpy(G, weight=\"weight\"), nx.betweenness_centrality(G, weight=\"weight_inv\"), weighted_degree(G, \"weight\"), nx.degree_centrality(G), ] ) return cor.T.corr() def evol_betweenness(graphs): evol = [nx.betweenness_centrality(graph, weight=\"weight_inv\") for graph in graphs] evol_df = pd.DataFrame.from_records(evol).fillna(0) set_of_char = set() for i in range(5): set_of_char |= set(list(evol_df.T[i].sort_values(ascending=False)[0:5].index)) evol_df[list(set_of_char)].plot(figsize=(19, 10)) def most_important_node_in_partition(graph, partition_dict): max_d = {} deg = nx.degree_centrality(graph) for group in partition_dict: temp = 0 for character in partition_dict[group]: if deg[character] > temp: max_d[group] = character temp = deg[character] return max_d","title":"Solutions"},{"location":"05-casestudies/02-airport/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); % load_ext autoreload % autoreload 2 % matplotlib inline % config InlineBackend . figure_format = 'retina' import networkx as nx import pandas as pd import matplotlib.pyplot as plt import numpy as np Introduction In this chapter, we will analyse the evolution of US Airport Network between 1990 and 2015. This dataset contains data for 25 years[1995-2015] of flights between various US airports and metadata about these routes. Taken from Bureau of Transportation Statistics, United States Department of Transportation. Let's see what can we make out of this! from nams import load_data as cf pass_air_data = cf . load_airports_data () In the pass_air_data dataframe we have the information of number of people that fly every year on a particular route on the list of airlines that fly that route. pass_air_data . head () id YEAR ORIGIN DEST UNIQUE_CARRIER_NAME PASSENGERS 0 1990 ABE ACY {'US Airways Inc.'} 73 1 1990 ABE ATL {'Eastern Air Lines Inc.'} 73172 2 1990 ABE AVL {'Westair Airlines Inc.'} 0 3 1990 ABE AVP {'Westair Airlines Inc.', 'US Airways Inc.', 'E... 8397 4 1990 ABE BHM {'Eastern Air Lines Inc.'} 59 Every row in this dataset is a unique route between 2 airports in United States territory in a particular year. Let's see how many people flew from New York JFK to Austin in 2006. NOTE: This will be a fun chapter if you are an aviation geek and like guessing airport IATA codes. jfk_aus_2006 = ( pass_air_data . query ( 'YEAR == 2006' ) . query ( \"ORIGIN == 'JFK' and DEST == 'AUS'\" )) jfk_aus_2006 . head () id YEAR ORIGIN DEST UNIQUE_CARRIER_NAME PASSENGERS 215634 2006 JFK AUS {'Shuttle America Corp.', 'Ameristar Air Cargo'... 105290 From the above pandas query we see that according to this dataset 105290 passengers travelled from JFK to AUS in the year 2006. But how does this dataset translate to an applied network analysis problem? In the previous chapter we created different graph objects for every book. Let's create a graph object which encompasses all the edges. NetworkX provides us with Multi(Di)Graphs to model networks with multiple edges between two nodes. In this case every row in the dataframe represents a directed edge between two airports, common sense suggests that if there is a flight from airport A to airport B there should definitely be a flight from airport B to airport A, i.e direction of the edge shouldn't matter. But in this dataset we have data for individual directions (A -> B and B -> A) so we create a MultiDiGraph. passenger_graph = nx . from_pandas_edgelist ( pass_air_data , source = 'ORIGIN' , target = 'DEST' , edge_key = 'YEAR' , edge_attr = [ 'PASSENGERS' , 'UNIQUE_CARRIER_NAME' ], create_using = nx . MultiDiGraph ()) We have created a MultiDiGraph object passenger_graph which contains all the information from the dataframe pass_air_data . ORIGIN and DEST represent the column names in the dataframe pass_air_data used to construct the edge. As this is a MultiDiGraph we can also give a name/key to the multiple edges between two nodes and edge_key is used to represent that name and in this graph YEAR is used to distinguish between multiple edges between two nodes. PASSENGERS and UNIQUE_CARRIER_NAME are added as edge attributes which can be accessed using the nodes and the key form the MultiDiGraph object. Let's check if can access the same information (the 2006 route between JFK and AUS) using our passenger_graph . To check an edge between two nodes in a Graph we can use the syntax GraphObject[source][target] and further specify the edge attribute using GraphObject[source][target][attribute] . passenger_graph [ 'JFK' ][ 'AUS' ][ 2006 ] {'PASSENGERS': 105290.0, 'UNIQUE_CARRIER_NAME': \"{'Shuttle America Corp.', 'Ameristar Air Cargo', 'JetBlue Airways', 'United Parcel Service'}\"} Now let's use our new constructed passenger graph to look at the evolution of passenger load over 25 years. # Route betweeen New York-JFK and SFO values = [( year , attr [ 'PASSENGERS' ]) for year , attr in passenger_graph [ 'JFK' ][ 'SFO' ] . items ()] x , y = zip ( * values ) plt . plot ( x , y ) plt . show () We see some usual trends all across the datasets like steep drops in 2001 (after 9/11) and 2008 (recession). # Route betweeen SFO and Chicago-ORD values = [( year , attr [ 'PASSENGERS' ]) for year , attr in passenger_graph [ 'SFO' ][ 'ORD' ] . items ()] x , y = zip ( * values ) plt . plot ( x , y ) plt . show () To find the overall trend, we can use our pass_air_data dataframe to calculate total passengers flown in a year. pass_air_data . groupby ( [ 'YEAR' ]) . sum ()[ 'PASSENGERS' ] . plot () plt . show () Exercise Find the busiest route in 1990 and in 2015 according to number of passengers, and plot the time series of number of passengers on these routes. You can use the DataFrame instead of working with the network. It will be faster :) from nams.solutions.airport import busiest_route , plot_time_series busiest_route ( pass_air_data , 1990 ) . head () id YEAR ORIGIN DEST UNIQUE_CARRIER_NAME PASSENGERS 3917 1990 LAX HNL {'Heavylift Cargo Airlines Lt', 'Hawaiian Airli... 1.82716e+06 plot_time_series ( pass_air_data , 'LAX' , 'HNL' ) busiest_route ( pass_air_data , 2015 ) . head () id YEAR ORIGIN DEST UNIQUE_CARRIER_NAME PASSENGERS 445978 2015 LAX SFO {'Hawaiian Airlines Inc.', 'Delta Air Lines Inc... 1.86907e+06 plot_time_series ( pass_air_data , 'LAX' , 'SFO' ) Before moving to the next part of the chapter let's create a method to extract edges from passenger_graph for a particular year so we can better analyse the data on a granular scale. def year_network ( G , year ): \"\"\" Extract edges for a particular year from a MultiGraph. The edge is also populated with two attributes, weight and weight_inv where weight is the number of passengers and weight_inv the inverse of it. \"\"\" year_network = nx . DiGraph () for edge in G . edges : source , target , edge_year = edge if edge_year == year : attr = G [ source ][ target ][ edge_year ] year_network . add_edge ( source , target , weight = attr [ 'PASSENGERS' ], weight_inv = 1 / ( attr [ 'PASSENGERS' ] if attr [ 'PASSENGERS' ] != 0.0 else 1 ), airlines = attr [ 'UNIQUE_CARRIER_NAME' ]) return year_network pass_2015_network = year_network ( passenger_graph , 2015 ) # Extracted a Directed Graph from the Multi Directed Graph # Number of nodes = airports # Number of edges = routes print ( nx . info ( pass_2015_network )) Name: Type: DiGraph Number of nodes: 1258 Number of edges: 25354 Average in degree: 20.1542 Average out degree: 20.1542 Visualise the airports # Loadin the GPS coordinates of all the airports from nams import load_data as cf lat_long = cf . load_airports_GPS_data () lat_long . columns = [ \"CODE4\" , \"CODE3\" , \"CITY\" , \"PROVINCE\" , \"COUNTRY\" , \"UNKNOWN1\" , \"UNKNOWN2\" , \"UNKNOWN3\" , \"UNKNOWN4\" , \"UNKNOWN5\" , \"UNKNOWN6\" , \"UNKNOWN7\" , \"UNKNOWN8\" , \"UNKNOWN9\" , \"LATITUDE\" , \"LONGITUDE\" ] lat_long wanted_nodes = list ( pass_2015_network . nodes ()) us_airports = lat_long . query ( \"CODE3 in @wanted_nodes\" ) . drop_duplicates ( subset = [ \"CODE3\" ]) . set_index ( \"CODE3\" ) us_airports # us_airports CODE3 CODE4 CITY PROVINCE COUNTRY UNKNOWN1 UNKNOWN2 UNKNOWN3 UNKNOWN4 UNKNOWN5 UNKNOWN6 UNKNOWN7 UNKNOWN8 UNKNOWN9 LATITUDE LONGITUDE ABI KABI ABILENE RGNL ABILENE USA 32 24 40 N 99 40 54 W 546 32.411 -99.682 ABQ KABQ nan ALBUQUERQUE USA 0 0 0 U 0 0 0 U 0 0 0 ACK KACK NANTUCKET MEM NANTUCKET USA 41 15 10 N 70 3 36 W 15 41.253 -70.06 ACT KACT WACO RGNL WACO USA 31 36 40 N 97 13 49 W 158 31.611 -97.23 ACY KACY ATLANTIC CITY INTERNATIONAL ATLANTIC CITY USA 39 27 27 N 74 34 37 W 23 39.458 -74.577 ADW KADW ANDREWS AFB CAMP SPRINGS USA 38 48 38 N 76 52 1 W 86 38.811 -76.867 AEX KAEX ALEXANDRIA INTERNATIONAL ALEXANDRIA USA 31 19 38 N 92 32 54 W 28 31.327 -92.548 AGS KAGS AUGUSTA RGNL AT BUSH FLD BUSH FIELD USA 33 22 11 N 81 57 52 W 44 33.37 -81.964 ALB KALB ALBANY INTERNATIONAL ALBANY USA 42 44 53 N 73 48 10 W 87 42.748 -73.803 AMA KAMA AMARILLO INTERNATIONAL AMARILLO USA 35 13 9 N 101 42 21 W 1100 35.219 -101.706 ANB KANB ANNISTON METROPOLITAN ANNISTON USA 33 35 17 N 85 51 29 W 187 33.588 -85.858 AOO KAOO ALTOONA BLAIR CO ALTOONA USA 40 17 47 N 78 19 12 W 459 40.296 -78.32 ARA KARA ACADIANA REGIONAL LOUISIANA USA 30 2 15 N 91 53 2 W 8 30.038 -91.884 ART KART WATERTOWN INTERNATIONAL WATERTOWN USA 43 59 30 N 76 1 18 W 100 43.992 -76.022 ATL KATL THE WILLIAM B HARTSFIELD ATLANTA INTERNATIONAL ATLANTA USA 33 38 25 N 84 25 37 W 313 33.64 -84.427 AUG KAUG AUGUSTA STATE AUGUSTA USA 44 19 14 N 69 47 50 W 108 44.321 -69.797 AUS KAUS AUSTIN BERGSTROM INTERNATIONAL AUSTIN USA 30 11 40 N 97 40 11 W 166 30.194 -97.67 BAD KBAD BARKSDALE AFB SHREVEPORT USA 32 30 6 N 93 39 45 W 51 32.502 -93.663 BCT KBCT BOCA RATON BOCA RATON USA 26 22 42 N 80 6 27 W 4 26.378 -80.107 BDL KBDL BRADLEY INTERNATIONAL WINDSOR LOCKS USA 41 56 20 N 72 40 59 W 53 41.939 -72.683 BDR KBDR IGOR I SIKORSKY MEM STRATFORD USA 41 9 48 N 73 7 34 W 3 41.163 -73.126 BED KBED LAURENCE G HANSCOM FLD BEDFORD USA 42 28 11 N 71 17 20 W 41 42.47 -71.289 BFI KBFI BOEING FLD KING CO INTERNATIONAL SEATTLE USA 47 31 47 N 122 18 7 W 6 47.53 -122.302 BFL KBFL MEADOWS FLD BAKERSFIELD USA 35 26 0 N 119 3 24 W 155 35.433 -119.057 BFM KBFM MOBILE DOWNTOWN MOBILE USA 30 37 35 N 88 4 4 W 8 30.626 -88.068 BGR KBGR BANGOR INTERNATIONAL BANGOR USA 44 48 26 N 68 49 41 W 59 44.807 -68.828 BHM KBHM BIRMINGHAM INTERNATIONAL BIRMINGHAM USA 33 33 46 N 86 45 12 W 197 33.563 -86.753 BIF KBIF BIGGS AAF EL PASO USA 31 50 58 N 106 22 48 W 1203 31.849 -106.38 BLI KBLI BELLINGHAM INTERNATIONAL BELLINGHAM USA 48 47 33 N 122 32 15 W 52 48.792 -122.537 BLV KBLV SCOTT AFB MIDAMERICA BELLEVILLE USA 38 32 42 N 89 50 6 W 140 38.545 -89.835 BNA KBNA NASHVILLE INTERNATIONAL NASHVILLE USA 36 7 28 N 86 40 41 W 183 36.124 -86.678 BOI KBOI BOISE AIR TERMINAL BOISE USA 43 33 51 N 116 13 22 W 876 43.564 -116.223 BOS KBOS GENERAL EDWARD LAWRENCE LOGAN INTERNATIONAL BOSTON USA 42 21 51 N 71 0 18 W 6 42.364 -71.005 BPT KBPT SOUTHEAST TEXAS RGNL BEAUMONT USA 29 57 3 N 94 1 14 W 5 29.951 -94.021 BRO KBRO BROWNSVILLE SOUTH PADRE ISLAND INTERNATIONAL BROWNSVILLE USA 25 54 24 N 97 25 33 W 7 25.907 -97.426 BTR KBTR BATON ROUGE METRO RYAN FLD BATON ROUGE USA 30 31 59 N 91 8 58 W 22 30.533 -91.149 BTV KBTV BURLINGTON INTERNATIONAL BURLINGTON USA 44 28 18 N 73 9 11 W 103 44.472 -73.153 BUF KBUF BUFFALO NIAGARA INTERNATIONAL BUFFALO USA 42 56 25 N 78 43 55 W 221 42.94 -78.732 BUR KBUR BURBANK GLENDALE PASADENA BURBANK USA 34 12 2 N 118 21 31 W 238 34.201 -118.359 BWI KBWI BALTIMORE WASHINGTON INTERNATIONAL BALTIMORE USA 39 10 31 N 76 40 6 W 45 39.175 -76.668 CAE KCAE COLUMBIA METROPOLITAN COLOMBIA USA 33 56 19 N 81 7 10 W 72 33.939 -81.119 CDC KCDC CEDAR CITY RGNL CEDAR CITY USA 37 42 3 N 113 5 55 W 1714 37.701 -113.099 CEF KCEF WESTOVER ARB METROPOLITAN CHICOPEE FALLS USA 42 11 53 N 72 32 3 W 75 42.198 -72.534 CEW KCEW BOB SIKES CRESTVIEW USA 30 46 43 N 86 31 19 W 65 30.779 -86.522 CHA KCHA LOVELL FLD CHATTANOOGA USA 35 2 7 N 85 12 13 W 208 35.035 -85.204 CHS KCHS CHARLESTON AFB INTERNATIONAL CHARLESTON USA 32 53 55 N 80 2 25 W 14 32.899 -80.04 CIC KCIC CHICO MUNI CHICO USA 39 47 43 N 121 51 30 W 73 39.795 -121.858 CLE KCLE CLEVELAND HOPKINS INTERNATIONAL CLEVELAND USA 41 24 42 N 81 50 59 W 242 41.412 -81.85 CLL KCLL EASTERWOOD FLD COLLEGE STATION USA 30 35 18 N 96 21 49 W 98 30.588 -96.364 CLT KCLT CHARLOTTE DOUGLAS INTERNATIONAL CHARLOTTE USA 35 12 50 N 80 56 35 W 229 35.214 -80.943 CMH KCMH PORT COLUMBUS INTERNATIONAL COLUMBUS USA 39 59 52 N 82 53 30 W 249 39.998 -82.892 CNM KCNM CAVERN CITY AIR TERMINAL CARLSBAD USA 32 20 14 N 104 15 47 W 1005 32.337 -104.263 COS KCOS CITY OF COLORADO SPRINGS MUNI COLORADO SPRINGS USA 38 48 20 N 104 42 0 W 1885 38.806 -104.7 COU KCOU COLUMBIA RGNL COLUMBIA USA 38 49 5 N 92 13 10 W 271 38.818 -92.219 CPR KCPR NATRONA CO INTERNATIONAL CASPER USA 42 54 28 N 106 27 51 W 1631 42.908 -106.464 CRP KCRP CORPUS CHRISTI INTERNATIONAL CORPUS CHRISTI USA 27 46 13 N 97 30 4 W 14 27.77 -97.501 CVG KCVG CINCINNATI NORTHERN KENTUCKY INTERNATIONAL CINCINNATI USA 39 2 46 N 84 39 43 W 274 39.046 -84.662 CVS KCVS CANNON AFB CLOVIS USA 34 22 57 N 103 19 19 W 1310 34.383 -103.322 CYS KCYS CHEYENNE CHEYENNE USA 41 9 20 N 104 48 42 W 1877 41.156 -104.812 DAL KDAL DALLAS LOVE FLD DALLAS USA 32 50 49 N 96 51 6 W 149 32.847 -96.852 DAY KDAY JAMES M COX DAYTON INTERNATIONAL DAYTON USA 39 54 8 N 84 13 9 W 308 39.902 -84.219 DCA KDCA RONALD REAGAN WASHINGTON NATIONAL WASHINGTON USA 38 51 7 N 77 2 15 W 5 38.852 -77.037 DEN KDEN DENVER INTERNATIONAL DENVER USA 39 51 30 N 104 40 1 W 1656 39.858 -104.667 DET KDET DETROIT CITY DETROIT USA 42 24 33 N 83 0 35 W 191 42.409 -83.01 DFW KDFW DALLAS FORT WORTH INTERNATIONAL DALLAS-FORT WORTH USA 32 53 47 N 97 2 15 W 184 32.896 -97.037 DHN KDHN DOTHAN RGNL DOTHAN USA 31 19 16 N 85 26 58 W 123 31.321 -85.449 DLH KDLH DULUTH INTERNATIONAL DULUTH USA 46 50 31 N 92 11 37 W 436 46.842 -92.194 DMA KDMA DAVIS MONTHAN AFB TUCSON USA 32 9 59 N 110 52 59 W 825 32.166 -110.883 DOV KDOV DOVER AFB DOVER USA 39 7 48 N 75 27 59 W 10 39.13 -75.466 DPA KDPA DU PAGE WEST CHICAGO USA 41 54 28 N 88 14 55 W 232 41.908 -88.249 DRO KDRO DURANGO LA PLATA CO DURANGO USA 37 9 5 N 107 45 13 W 2038 37.151 -107.754 DRT KDRT DEL RIO INTERNATIONAL DEL RIO USA 29 22 22 N 100 55 33 W 305 29.373 -100.926 DSM KDSM DES MOINES INTERNATIONAL DES MOINES USA 41 32 2 N 93 39 45 W 292 41.534 -93.663 DTW KDTW DETROIT METRO WAYNE CO DETROIT USA 42 12 44 N 83 21 12 W 197 42.212 -83.353 EDW KEDW EDWARDS AFB EDWARDS AFB USA 34 54 19 N 117 53 1 W 702 34.905 -117.884 EFD KEFD ELLINGTON FLD HOUSTON USA 29 36 26 N 95 9 31 W 10 29.607 -95.159 ELD KELD SOUTH ARKANSAS RGNL AT GOODWIN FLD EL DORADO USA 33 13 15 N 92 48 47 W 85 33.221 -92.813 ELP KELP EL PASO INTERNATIONAL EL PASO USA 31 48 24 N 106 22 40 W 1207 31.807 -106.378 ENV KENV WENDOVER WENDOVER USA 40 43 7 N 114 1 51 W 1291 40.719 -114.031 EWN KEWN CRAVEN CO RGNL NEW BERN USA 35 4 22 N 77 2 34 W 6 35.073 -77.043 EWR KEWR NEWARK LIBERTY INTERNATIONAL NEWARK USA 40 41 32 N 74 10 7 W 6 40.692 -74.169 EYW KEYW KEY WEST INTERNATIONAL KEY WEST USA 24 33 22 N 81 45 34 W 1 24.556 -81.759 FAT KFAT FRESNO YOSEMITE INTERNATIONAL FRESNO USA 36 46 34 N 119 43 5 W 103 36.776 -119.718 FFO KFFO WRIGHT PATTERSON AFB DAYTON USA 39 49 34 N 84 2 54 W 251 39.826 -84.048 FLL KFLL FORT LAUDERDALE HOLLYWOOD INTERNATIONAL FORT LAUDERDALE USA 26 4 21 N 80 9 9 W 3 26.072 -80.153 FLO KFLO FLORENCE RGNL FLORENCE USA 34 11 7 N 79 43 26 W 45 34.185 -79.724 FMH KFMH OTIS ANGB FALMOUTH USA 41 39 30 N 70 31 17 W 40 41.658 -70.521 FMN KFMN FOUR CORNERS RGNL FARMINGTON USA 36 44 28 N 108 13 47 W 1679 36.741 -108.23 FMY KFMY PAGE FLD FORT MYERS USA 26 35 11 N 81 51 47 W 6 26.586 -81.863 FOD KFOD FORT DODGE RGNL FORT DODGE USA 42 33 5 N 94 11 33 W 353 42.551 -94.193 FOE KFOE FORBES FLD TOPEKA USA 38 57 3 N 95 39 49 W 329 38.951 -95.664 FOK KFOK THE FRANCIS S GABRESKI WEST HAMPTON BEACH USA 40 50 37 N 72 37 54 W 21 40.844 -72.632 FSI KFSI HENRY POST AAF FORT SILL USA 34 38 59 N 98 24 7 W 363 34.65 -98.402 FSM KFSM FORT SMITH RGNL FORT SMITH USA 35 20 11 N 94 22 2 W 143 35.336 -94.367 FTW KFTW FORT WORTH MEACHAM INTERNATIONAL FORT WORTH USA 32 49 11 N 97 21 44 W 217 32.82 -97.362 FXE KFXE FORT LAUDERDALE EXECUTIVE FORT LAUDERDALE USA 26 11 50 N 80 10 14 W 5 26.197 -80.171 FYV KFYV DRAKE FLD FAYETTEVILLE USA 36 0 18 N 94 10 12 W 382 36.005 -94.17 GCK KGCK GARDEN CITY RGNL GARDEN CITY USA 37 55 39 N 100 43 27 W 881 37.927 -100.724 GEG KGEG SPOKANE INTERNATIONAL SPOKANE USA 47 37 11 N 117 32 1 W 723 47.62 -117.534 GFK KGFK GRAND FORKS INTERNATIONAL GRAND FORKS USA 47 56 57 N 97 10 34 W 258 47.949 -97.176 GGG KGGG EAST TEXAS RGNL LONGVIEW USA 32 23 5 N 94 42 41 W 112 32.385 -94.711 GNV KGNV GAINESVILLE RGNL GAINESVILLE USA 29 41 24 N 82 16 18 W 47 29.69 -82.272 GRB KGRB AUSTIN STRAUBEL INTERNATIONAL GREEN BAY USA 44 29 6 N 88 7 46 W 212 44.485 -88.129 GRF KGRF GRAY AAF FORT LEWIS USA 47 4 45 N 122 34 50 W 93 47.079 -122.581 GRK KGRK ROBERT GRAY AAF KILLEEN USA 31 4 2 N 97 49 44 W 311 31.067 -97.829 GRR KGRR GERALD R FORD INTERNATIONAL GRAND RAPIDS USA 42 52 51 N 85 31 22 W 242 42.881 -85.523 GSB KGSB SEYMOUR JOHNSON AFB GOLDSBORO USA 35 20 21 N 77 57 38 W 34 35.339 -77.961 GTF KGTF GREAT FALLS INTERNATIONAL GREAT FALLS USA 47 28 55 N 111 22 14 W 1121 47.482 -111.371 GUS KGUS GRISSOM ARB PERU USA 40 38 53 N 86 9 7 W 248 40.648 -86.152 GVT KGVT MAJORS GREENVILE USA 33 4 4 N 96 3 55 W 164 33.068 -96.065 HFD KHFD HARTFORD BRAINARD HARTFORD USA 41 44 10 N 72 39 0 W 6 41.736 -72.65 HIB KHIB CHISHOLM HIBBING HIBBING USA 47 23 11 N 92 50 20 W 413 47.386 -92.839 HKY KHKY HICKORY RGNL HICKORY USA 35 44 28 N 81 23 22 W 363 35.741 -81.389 HLN KHLN HELENA RGNL HELENA USA 46 36 24 N 111 58 57 W 1182 46.607 -111.983 HMN KHMN HOLLOMAN AFB ALAMOGORDO USA 32 51 9 N 106 6 23 W 1248 32.852 -106.106 HOB KHOB LEA CO RGNL HOBBS USA 32 41 15 N 103 13 1 W 1116 32.688 -103.217 HON KHON HURON RGNL HURON USA 44 23 6 N 98 13 42 W 393 44.385 -98.228 HOP KHOP CAMPBELL AAF HOPKINSVILLE USA 36 40 6 N 87 29 46 W 175 36.668 -87.496 HOU KHOU WILLIAM P HOBBY HOUSTON USA 29 38 43 N 95 16 44 W 15 29.645 -95.279 HPN KHPN WESTCHESTER CO WHITE PLAINS USA 41 4 1 N 73 42 27 W 134 41.067 -73.707 HRL KHRL VALLEY INTERNATIONAL HARLINGEN USA 26 13 42 N 97 39 15 W 11 26.228 -97.654 HRO KHRO BOONE CO HARRISON USA 36 15 41 N 93 9 17 W 417 36.261 -93.155 HUF KHUF TERRE HAUTE INTERNATIONAL HULMAN FLD TERRE HAUTE USA 39 27 5 N 87 18 27 W 180 39.451 -87.307 HVR KHVR HAVRE CITY CO HAVRE USA 48 32 34 N 109 45 44 W 790 48.543 -109.762 IAB KIAB MC CONNELL AFB WICHITA USA 37 37 22 N 97 16 2 W 418 37.623 -97.267 IAD KIAD WASHINGTON DULLES INTERNATIONAL WASHINGTON USA 38 56 40 N 77 27 20 W 96 38.944 -77.456 IAG KIAG NIAGARA FALLS INTERNATIONAL NIAGARA FALLS USA 43 6 26 N 78 56 46 W 180 43.107 -78.946 IAH KIAH GEORGE BUSH INTCNTL HOUSTON HOUSTON USA 29 58 49 N 95 20 23 W 30 29.98 -95.34 ICT KICT WICHITA MID CONTINENT WICHITA USA 37 38 59 N 97 25 59 W 407 37.65 -97.433 ILG KILG NEW CASTLE CO WILMINGTON USA 39 40 43 N 75 36 23 W 25 39.679 -75.606 ILM KILM WILMINGTON INTERNATIONAL WILMINGTON USA 34 16 14 N 77 54 9 W 10 34.271 -77.903 IND KIND INDIANAPOLIS INTERNATIONAL INDIANAPOLIS USA 39 43 2 N 86 17 39 W 243 39.717 -86.294 INL KINL FALLS INTERNATIONAL INTERNATIONAL FALLS USA 48 33 58 N 93 24 11 W 362 48.566 -93.403 INT KINT SMITH REYNOLDS WINSTON-SALEM USA 36 8 1 N 80 13 19 W 296 36.134 -80.222 IPL KIPL IMPERIAL CO IMPERIAL USA 32 50 3 N 115 34 43 W -17 32.834 -115.579 IPT KIPT WILLIAMSPORT RGNL WILLIAMSPORT USA 41 14 31 N 76 55 16 W 162 41.242 -76.921 ISN KISN SLOULIN FLD INTERNATIONAL WILLISTON USA 48 10 40 N 103 38 32 W 605 48.178 -103.642 ISP KISP LONG ISLAND MAC ARTHUR ISLIP USA 40 47 42 N 73 6 0 W 31 40.795 -73.1 JAN KJAN JACKSON INTERNATIONAL JACKSON USA 32 18 40 N 90 4 33 W 106 32.311 -90.076 JAX KJAX JACKSONVILLE INTERNATIONAL JACKSONVILLE USA 30 29 38 N 81 41 16 W 10 30.494 -81.688 JBR KJBR JONESBORO MUNI JONESBORO USA 35 49 54 N 90 38 46 W 80 35.832 -90.646 JFK KJFK JOHN F KENNEDY INTERNATIONAL NEW YORK USA 40 38 23 N 73 46 44 W 4 40.64 -73.779 LAN KLAN CAPITAL CITY LANSING USA 42 46 43 N 84 35 14 W 263 42.779 -84.587 LAS KLAS MC CARRAN INTERNATIONAL LAS VEGAS USA 36 4 49 N 115 9 8 W 665 36.08 -115.152 LAX KLAX LOS ANGELES INTERNATIONAL LOS ANGELES USA 33 56 33 N 118 24 29 W 39 33.942 -118.408 LBB KLBB LUBBOCK INTERNATIONAL LUBBOCK USA 33 39 49 N 101 49 22 W 1001 33.664 -101.823 LCH KLCH LAKE CHARLES RGNL LAKE CHARLES USA 30 7 34 N 93 13 24 W 5 30.126 -93.223 LCK KLCK RICKENBACKER INTERNATIONAL COLUMBUS USA 39 48 49 N 82 55 40 W 227 39.814 -82.928 LFI KLFI LANGLEY AFB HAMPTON USA 37 4 58 N 76 21 37 W 4 37.083 -76.36 LFT KLFT LAFAYETTE RGNL LAFAYETTE USA 30 12 19 N 91 59 15 W 13 30.205 -91.987 LGA KLGA LA GUARDIA NEW YORK USA 40 46 38 N 73 52 21 W 7 40.777 -73.872 LGB KLGB LONG BEACH LONG BEACH USA 33 49 3 N 118 9 5 W 19 33.818 -118.151 LIT KLIT ADAMS FLD LITTLE ROCK USA 34 43 46 N 92 13 27 W 80 34.729 -92.224 LNK KLNK LINCOLN MUNI LINCOLN USA 40 51 3 N 96 45 33 W 372 40.851 -96.759 LRD KLRD LAREDO INTERNATIONAL LAREDO USA 27 32 37 N 99 27 41 W 155 27.544 -99.461 LSF KLSF LAWSON AAF FORT BENNING USA 32 20 14 N 84 59 28 W 71 32.337 -84.991 LSV KLSV NELLIS AFB LAS VEGAS USA 36 14 10 N 115 2 3 W 570 36.236 -115.034 LUK KLUK CINCINNATI MUNI LUNKEN FLD CINCINNATI USA 39 6 12 N 84 25 7 W 148 39.103 -84.419 MAF KMAF MIDLAND INTERNATIONAL MIDLAND USA 31 56 33 N 102 12 6 W 876 31.942 -102.202 MCC KMCC MC CLELLAN AFLD SACRAMENTO USA 38 40 3 N 121 24 2 W 23 38.667 -121.401 MCF KMCF MACDILL AFB TAMPA USA 27 50 57 N 82 31 16 W 5 27.849 -82.521 MCI KMCI KANSAS CITY INTERNATIONAL KANSAS CITY USA 39 17 51 N 94 42 50 W 313 39.297 -94.714 MCN KMCN MIDDLE GEORGIA RGNL MACON USA 32 41 34 N 83 38 57 W 108 32.693 -83.649 MCO KMCO ORLANDO INTERNATIONAL ORLANDO USA 28 25 44 N 81 18 57 W 30 28.429 -81.316 MDT KMDT HARRISBURG INTERNATIONAL HARRISBURG USA 40 11 36 N 76 45 48 W 95 40.193 -76.763 MDW KMDW CHICAGO MIDWAY INTERNATIONAL CHICAGO USA 41 47 9 N 87 45 8 W 189 41.786 -87.752 MEM KMEM MEMPHIS INTERNATIONAL MEMPHIS USA 35 2 32 N 89 58 36 W 104 35.042 -89.977 MER KMER CASTLE MERCED USA 37 22 49 N 120 34 5 W 58 37.38 -120.568 MFE KMFE MC ALLEN MILLER INTERNATIONAL MCALLEN USA 26 10 33 N 98 14 19 W 33 26.176 -98.239 MHR KMHR SACRAMENTO MATHER SACRAMENTO USA 38 33 14 N 121 17 51 W 30 38.554 -121.297 MIA KMIA MIAMI INTERNATIONAL MIAMI USA 25 47 35 N 80 17 26 W 3 25.793 -80.291 MIB KMIB MINOT AFB MINOT USA 48 24 56 N 101 21 27 W 509 48.416 -101.357 MKE KMKE GENERAL MITCHELL INTERNATIONAL MILWAUKEE USA 42 56 50 N 87 53 47 W 221 42.947 -87.896 MKL KMKL MC KELLAR SIPES RGNL JACKSON USA 35 35 59 N 88 54 56 W 133 35.6 -88.916 MLB KMLB MELBOURNE INTERNATIONAL MELBOURNE USA 28 6 9 N 80 38 42 W 11 28.103 -80.645 MLU KMLU MONROE RGNL MONROE USA 32 30 39 N 92 2 15 W 25 32.511 -92.037 MOB KMOB MOBILE RGNL MOBILE USA 30 41 29 N 88 14 34 W 67 30.691 -88.243 MOD KMOD MODESTO CITY CO HARRY SHAM MODESTO USA 37 37 32 N 120 57 15 W 30 37.626 -120.954 MOT KMOT MINOT INTERNATIONAL MINOT USA 48 15 33 N 101 16 49 W 519 48.259 -101.28 MQT KMQT SAWYER INTERNATIONAL MARQUETTE USA 46 32 2 N 87 33 42 W 433 46.534 -87.562 MSN KMSN DANE CO RGNL TRUAX FLD MADISON USA 43 8 23 N 89 20 15 W 271 43.14 -89.337 MSP KMSP MINNEAPOLIS ST PAUL INTERNATIONAL MINNEAPOLIS USA 44 52 49 N 93 13 0 W 257 44.88 -93.217 MSS KMSS MASSENA INTERNATIONAL RICHARDS FLD MASSENA USA 44 56 9 N 74 50 43 W 66 44.936 -74.845 MSY KMSY LOUIS ARMSTRONG NEW ORLEANS INTERNATIONAL NEW ORLEANS USA 29 59 36 N 90 15 28 W 2 29.993 -90.258 MWH KMWH GRANT CO INTERNATIONAL GRANT COUNTY AIRPORT USA 47 12 27 N 119 19 12 W 362 47.208 -119.32 MXF KMXF MAXWELL AFB MONTGOMERY USA 32 22 45 N 86 21 45 W 53 32.379 -86.362 MYR KMYR MYRTLE BEACH INTERNATIONAL MYRTLE BEACH USA 33 40 47 N 78 55 42 W 8 33.68 -78.928 NBG KNBG NEW ORLEANS NAS JRB NEW ORLEANS USA 29 49 31 N 90 2 6 W 1 29.825 -90.035 NGU KNGU NORFOLK NS NORFOLK USA 36 56 15 N 76 17 21 W 5 36.938 -76.289 NIP KNIP JACKSONVILLE NAS JACKSONVILLE USA 30 14 9 N 81 40 50 W 7 30.236 -81.681 NJK KNJK EL CENTRO NAF EL CENTRO USA 32 49 45 N 115 40 18 W -13 32.829 -115.672 NKX KNKX MIRAMAR MCAS MIRAMAR USA 32 52 6 N 117 8 33 W 146 32.868 -117.143 NPA KNPA PENSACOLA NAS PENSACOLA USA 30 21 9 N 87 19 7 W 9 30.353 -87.319 NQA KNQA MILLINGTON MUNI MILLINGTON USA 35 21 24 N 89 52 13 W 98 35.357 -89.87 NQX KNQX KEY WEST NAS KEY WEST USA 24 34 33 N 81 41 20 W 2 24.576 -81.689 NTD KNTD POINT MUGU NAS POINT MUGU USA 34 7 13 N 119 7 15 W 4 34.12 -119.121 NTU KNTU OCEANA NAS OCEANA USA 36 49 14 N 76 2 0 W 7 36.821 -76.033 NUQ KNUQ MOFFETT FEDERAL AFLD MOUNTAIN VIEW USA 37 24 54 N 122 2 53 W 10 37.415 -122.048 NUW KNUW WHIDBEY ISLAND NAS WHIDBEY ISLAND USA 48 21 6 N 122 39 21 W 15 48.352 -122.656 NZC KNZC CECIL FLD JACKSONVILLE USA 30 13 7 N 81 52 35 W 25 30.219 -81.876 NZY KNZY NORTH ISLAND NAS SAN DIEGO USA 32 41 57 N 117 12 55 W 8 32.699 -117.215 OAK KOAK METROPOLITAN OAKLAND INTERNATIONAL OAKLAND USA 37 43 16 N 122 13 14 W 2 37.721 -122.221 OFF KOFF OFFUTT AFB OMAHA USA 41 7 6 N 95 54 45 W 321 41.118 -95.913 OGS KOGS OGDENSBURG INTERNATIONAL OGDENSBURG USA 44 40 55 N 75 27 56 W 91 44.682 -75.466 OKC KOKC WILL ROGERS WORLD OKLAHOMA CITY USA 35 23 35 N 97 36 2 W 395 35.393 -97.601 OMA KOMA EPPLEY AFLD OMAHA USA 41 18 9 N 95 53 37 W 300 41.302 -95.894 ONT KONT ONTARIO INTERNATIONAL ONTARIO USA 34 3 21 N 117 36 4 W 288 34.056 -117.601 OPF KOPF OPA LOCKA MIAMI USA 25 54 25 N 80 16 42 W 3 25.907 -80.278 ORD KORD CHICAGO OHARE INTERNATIONAL CHICAGO USA 41 58 46 N 87 54 16 W 204 41.979 -87.904 ORF KORF NORFOLK INTERNATIONAL NORFOLK USA 36 53 40 N 76 12 4 W 8 36.894 -76.201 ORL KORL EXECUTIVE ORLANDO USA 28 32 43 N 81 19 58 W 35 28.545 -81.333 PAE KPAE SNOHOMISH CO EVERETT USA 47 54 22 N 122 16 53 W 185 47.906 -122.281 PAM KPAM TYNDALL AFB PANAMA CITY USA 30 4 11 N 85 34 35 W 6 30.07 -85.576 PBG KPBG PLATTSBURGH INTERNATIONAL PLATTSBURGH USA 44 39 3 N 73 28 5 W 72 44.651 -73.468 PBI KPBI PALM BEACH INTERNATIONAL WEST PALM BEACH USA 26 40 59 N 80 5 44 W 6 26.683 -80.096 PDX KPDX PORTLAND INTERNATIONAL PORTLAND USA 45 35 19 N 122 35 51 W 10 45.589 -122.597 PHF KPHF NEWPORT NEWS WILLIAMSBURG INTERNATIONAL NEWPORT NEWS USA 37 7 54 N 76 29 34 W 14 37.132 -76.493 PHL KPHL PHILADELPHIA INTERNATIONAL PHILADELPHIA USA 39 52 19 N 75 14 28 W 12 39.872 -75.241 PHN KPHN ST CLAIR CO INTERNATIONAL PORT HURON USA 42 54 39 N 82 31 43 W 199 42.911 -82.529 PHX KPHX PHOENIX SKY HARBOR INTERNATIONAL PHOENIX USA 33 26 3 N 112 0 29 W 346 33.434 -112.008 PIE KPIE ST PETERSBURG CLEARWATER INTERNATIONAL ST. PETERSBURG USA 27 54 38 N 82 41 14 W 4 27.911 -82.687 PIT KPIT PITTSBURGH INTERNATIONAL PITTSBURGH (PENNSYLVA) USA 40 29 29 N 80 13 58 W 367 40.491 -80.233 PNE KPNE NORTHEAST PHILADELPHIA PHILADELPHIA USA 40 4 55 N 75 0 38 W 37 40.082 -75.011 PNS KPNS PENSACOLA RGNL PENSACOLA USA 30 28 23 N 87 11 14 W 37 30.473 -87.187 POB KPOB POPE AFB FAYETTEVILLE USA 35 10 15 N 79 0 52 W 67 35.171 -79.014 PQI KPQI NORTHERN MAINE RGNL AT PRESQUE ISLE PRESQUE ISLE USA 46 41 20 N 68 2 41 W 163 46.689 -68.045 PRC KPRC ERNEST A LOVE FLD PRESCOTT USA 34 39 16 N 112 25 10 W 1538 34.654 -112.419 PSP KPSP PALM SPRINGS INTERNATIONAL PALM SPRINGS USA 33 49 46 N 116 30 24 W 145 33.829 -116.507 PUB KPUB PUEBLO MEM PUEBLO MEMORIAL USA 38 17 20 N 104 29 47 W 1441 38.289 -104.496 PVD KPVD THEODORE FRANCIS GREEN STATE PROVIDENCE USA 41 43 26 N 71 25 41 W 17 41.724 -71.428 PWM KPWM PORTLAND INTERNATIONAL JETPORT PORTLAND USA 43 38 46 N 70 18 31 W 23 43.646 -70.309 RCA KRCA ELLSWORTH AFB RAPID CITY USA 44 8 42 N 103 6 12 W 1000 44.145 -103.103 RDU KRDU RALEIGH DURHAM INTERNATIONAL RALEIGH-DURHAM USA 35 52 39 N 78 47 14 W 133 35.877 -78.787 RIC KRIC RICHMOND INTERNATIONAL RICHMOND USA 37 30 18 N 77 19 10 W 51 37.505 -77.319 RIV KRIV MARCH ARB RIVERSIDE USA 33 52 50 N 117 15 34 W 468 33.881 -117.259 RME KRME GRIFFISS AIRPARK ROME USA 43 14 1 N 75 24 25 W 154 43.234 -75.407 RNO KRNO RENO TAHOE INTERNATIONAL RENO USA 39 29 54 N 119 46 5 W 1345 39.498 -119.768 ROC KROC GREATER ROCHESTER INTERNATIONAL ROCHESTER USA 43 7 7 N 77 40 20 W 171 43.119 -77.672 ROW KROW ROSWELL INDUSTRIAL AIR CENTER ROSWELL USA 33 18 5 N 104 31 50 W 1119 33.301 -104.531 RSW KRSW SOUTHWEST FLORIDA INTERNATIONAL FORT MYERS USA 26 32 10 N 81 45 18 W 10 26.536 -81.755 SAC KSAC SACRAMENTO EXECUTIVE SACRAMENTO USA 38 30 45 N 121 29 36 W 8 38.513 -121.493 SAF KSAF SANTA FE MUNI SANTA FE USA 35 37 0 N 106 5 17 W 1935 35.617 -106.088 SAN KSAN SAN DIEGO INTERNATIONAL LINDBERGH FLD SAN DIEGO USA 32 44 0 N 117 11 22 W 5 32.733 -117.189 SAT KSAT SAN ANTONIO INTERNATIONAL SAN ANTONIO USA 29 32 1 N 98 28 11 W 247 29.534 -98.47 SAV KSAV SAVANNAH HILTON HEAD INTERNATIONAL SAVANNAH USA 32 7 39 N 81 12 7 W 16 32.127 -81.202 SBY KSBY SALISBURY OCEAN CITY WICOMICO RGNL SALISBURY USA 38 20 25 N 75 30 37 W 16 38.34 -75.51 SCK KSCK STOCKTON METROPOLITAN STOCKTON USA 37 53 39 N 121 14 19 W 10 37.894 -121.239 SEA KSEA SEATTLE TACOMA INTERNATIONAL SEATTLE USA 47 26 56 N 122 18 33 W 131 47.449 -122.309 SFO KSFO SAN FRANCISCO INTERNATIONAL SAN FRANCISCO USA 37 37 8 N 122 22 29 W 4 37.619 -122.375 SFZ KSFZ NORTH CENTRAL STATE SMITHFIELD USA 41 55 14 N 71 29 28 W 135 41.921 -71.491 SHV KSHV SHREVEPORT RGNL SHREVEPORT USA 32 26 47 N 93 49 32 W 79 32.446 -93.826 SJC KSJC NORMAN Y MINETA SAN JOSE INTERNATIONAL SAN JOSE USA 37 21 42 N 121 55 44 W 18 37.362 -121.929 SJT KSJT SAN ANGELO RGNL MATHIS FLD SAN ANGELO USA 31 21 27 N 100 29 46 W 585 31.358 -100.496 SKF KSKF LACKLAND AFB KELLY FLD ANNEX SAN ANTONIO USA 29 23 3 N 98 34 51 W 211 29.384 -98.581 SLC KSLC SALT LAKE CITY INTERNATIONAL SALT LAKE CITY USA 40 47 18 N 111 58 39 W 1289 40.788 -111.978 SMF KSMF SACRAMENTO INTERNATIONAL SACRAMENTO USA 38 41 43 N 121 35 26 W 9 38.695 -121.591 SNA KSNA JOHN WAYNE ARPT ORANGE CO SANTA ANA USA 33 40 32 N 117 52 5 W 18 33.676 -117.868 SPB KSPB SCAPPOOSE INDUSTRIAL AIRPARK SAN LUIS USA 45 46 21 N 122 51 44 W 18 45.773 -122.862 SPS KSPS SHEPPARD AFB WICHITA FALLS MUNI WICHITA FALLS USA 33 59 19 N 98 29 30 W 311 33.989 -98.492 SSC KSSC SHAW AFB SUMTER USA 33 58 22 N 80 28 22 W 74 33.973 -80.473 STL KSTL LAMBERT ST LOUIS INTERNATIONAL ST. LOUIS USA 38 44 51 N 90 21 35 W 185 38.748 -90.36 SUU KSUU TRAVIS AFB FAIRFIELD USA 38 15 45 N 121 55 38 W 19 38.263 -121.927 SUX KSUX SIOUX GATEWAY COL BUD DAY FLD SIOUX CITY USA 42 24 9 N 96 23 3 W 335 42.402 -96.384 SVN KSVN HUNTER AAF HUNTER AAF USA 32 0 36 N 81 8 44 W 13 32.01 -81.146 SWF KSWF STEWART INTERNATIONAL NEWBURGH USA 41 30 14 N 74 6 17 W 150 41.504 -74.105 SYR KSYR SYRACUSE HANCOCK INTERNATIONAL SYRACUSE USA 43 6 40 N 76 6 22 W 129 43.111 -76.106 SZL KSZL WHITEMAN AFB KNOBNOSTER USA 38 43 49 N 93 32 52 W 266 38.73 -93.548 TBN KTBN WAYNESVILLE RGNL ARPT AT FORNEY FLD FORT LEONARDWOOD USA 37 44 29 N 92 8 26 W 354 37.741 -92.141 TEB KTEB TETERBORO TETERBORO USA 40 50 59 N 74 3 39 W 3 40.85 -74.061 TIK KTIK TINKER AFB OKLAHOMA CITY USA 35 24 53 N 97 23 11 W 394 35.415 -97.386 TLH KTLH TALLAHASSEE RGNL TALLAHASSEE USA 30 23 47 N 84 21 1 W 25 30.396 -84.35 TMB KTMB KENDALL TAMIAMI EXECUTIVE KENDALL-TAMIAMI USA 25 38 52 N 80 25 58 W 3 25.648 -80.433 TNT KTNT DADE COLLIER TRAINING AND TRANSITION MIAMI USA 25 51 42 N 80 53 49 W 4 25.862 -80.897 TPA KTPA TAMPA INTERNATIONAL TAMPA USA 27 58 31 N 82 31 59 W 8 27.975 -82.533 TTN KTTN TRENTON MERCER TRENTON USA 40 16 36 N 74 48 48 W 65 40.277 -74.813 TUL KTUL TULSA INTERNATIONAL TULSA USA 36 11 54 N 95 53 17 W 207 36.198 -95.888 TUS KTUS TUCSON INTERNATIONAL TUCSON USA 32 6 58 N 110 56 29 W 806 32.116 -110.941 TXK KTXK TEXARKANA RGNL WEBB FLD TEXARKANA USA 33 27 13 N 93 59 27 W 119 33.454 -93.991 TYR KTYR TYLER POUNDS RGNL TYLER USA 32 21 14 N 95 24 8 W 166 32.354 -95.402 TYS KTYS MC GHEE TYSON KNOXVILLE USA 35 48 44 N 83 59 34 W 300 35.812 -83.993 VAD KVAD MOODY AFB VALDOSTA USA 30 58 4 N 83 11 34 W 72 30.968 -83.193 VCV KVCV SOUTHERN CALIFORNIA LOGISTICS VICTORVILLE USA 34 35 35 N 117 22 46 W 880 34.593 -117.379 VPS KVPS EGLIN AFB VALPARAISO USA 30 28 59 N 86 31 31 W 27 30.483 -86.525 VRB KVRB VERO BEACH MUNI VERO BEACH USA 27 39 20 N 80 25 4 W 8 27.656 -80.418 WRB KWRB ROBINS AFB MACON USA 32 38 24 N 83 35 30 W 90 32.64 -83.592 WRI KWRI MC GUIRE AFB WRIGHTSTOWN USA 40 0 56 N 74 35 37 W 41 40.016 -74.594 WWD KWWD CAPE MAY CO WILDWOOD USA 39 0 30 N 74 54 29 W 8 39.008 -74.908 YIP KYIP WILLOW RUN DETROIT USA 42 14 16 N 83 31 49 W 219 42.238 -83.53 YNG KYNG YOUNGSTOWN WARREN RGNL YOUNGSTOWN USA 41 15 38 N 80 40 44 W 365 41.261 -80.679 YUM KYUM YUMA MCAS YUMA INTERNATIONAL YUMA USA 32 39 23 N 114 36 21 W 65 32.656 -114.606 PCA MMPC INGENIERO JUAN GUILLERMO VILLASANA PACHUCA MEXICO 20 4 38 N 98 46 56 W 2317 20.077 -98.782 PPG NSTU PAGO PAGO INTERNATIONAL PAGO PAGO SAMOA 14 19 51 S 170 42 37 W 10 -14.331 -170.71 PAQ PAAQ PALMER MUNI PALMER USA 61 35 41 N 149 5 19 W 76 61.595 -149.089 BTI PABA BARTER ISLAND LRRS BARTER ISLAND USA 70 8 2 N 143 34 37 W 2 70.134 -143.577 BET PABE BETHEL BETHEL USA 60 46 47 N 161 50 16 W 38 60.78 -161.838 BRW PABR WILEY POST WILL ROGERS MEM BARROW USA 71 17 7 N 156 45 57 W 14 71.285 -156.766 BTT PABT BETTLES BETTLES USA 66 54 55 N 151 31 41 W 196 66.915 -151.528 CDB PACD COLD BAY COLD BAY USA 55 12 20 N 162 43 27 W 30 55.206 -162.724 CDV PACV MERLE K MUDHOLE SMITH CORDOVA USA 60 29 30 N 145 28 39 W 13 60.492 -145.477 ADK PADK ADAK ADAK ISLAND USA 51 52 40 N 176 38 45 W 7 51.878 -176.646 DLG PADL DILLINGHAM DILLINGHAM USA 59 2 43 N 158 30 12 W 27 59.045 -158.503 ADQ PADQ KODIAK KODIAK USA 57 45 0 N 152 29 37 W 23 57.75 -152.494 DUT PADU UNALASKA UNALASKA USA 53 54 0 N 166 32 36 W 7 53.9 -166.543 EDF PAED ELMENDORF AFB ANCHORAGE USA 61 15 4 N 149 48 23 W 65 61.251 -149.806 EHM PAEH CAPE NEWENHAM LRRS CAPE NEWENHAM USA 58 38 50 N 162 3 38 W 165 58.647 -162.061 EIL PAEI EIELSON AFB FAIRBANKS USA 64 39 56 N 147 6 5 W 168 64.666 -147.101 ENA PAEN KENAI MUNI KENAI USA 60 34 23 N 151 14 42 W 31 60.573 -151.245 FAI PAFA FAIRBANKS INTERNATIONAL FAIRBANKS USA 64 48 54 N 147 51 22 W 133 64.815 -147.856 FBK PAFB WAINWRIGHT AAF FORT WAINWRIGHT USA 64 50 15 N 147 36 52 W 139 64.837 -147.614 GAL PAGA EDWARD G PITKA SR GALENA USA 64 44 10 N 156 56 14 W 47 64.736 -156.937 GKN PAGK GULKANA GULKANA USA 62 9 17 N 145 27 23 W 482 62.155 -145.456 SGY PAGY SKAGWAY SKAGWAY USA 59 27 36 N 135 18 56 W 14 59.46 -135.316 HOM PAHO HOMER HOMER USA 59 38 44 N 151 28 35 W 26 59.646 -151.476 ILI PAIL ILIAMNA ILIAMNA USA 59 45 13 N 154 54 39 W 57 59.754 -154.911 UTO PAIM INDIAN MOUNTAIN LRRS INDIAN MOUNTAINS USA 65 59 34 N 153 42 15 W 372 65.993 -153.704 JNU PAJN JUNEAU INTERNATIONAL JUNEAU USA 58 21 17 N 134 34 34 W 6 58.355 -134.576 AKN PAKN KING SALMON KING SALMON USA 58 40 36 N 156 38 57 W 18 58.677 -156.649 KTN PAKT KETCHIKAN INTERNATIONAL KETCHIKAN USA 55 21 20 N 131 42 49 W 30 55.356 -131.714 LUR PALU CAPE LISBURNE LRRS CAPE LISBURNE USA 68 52 30 N 166 6 36 W 4 68.875 -166.11 MCG PAMC MC GRATH MCGRATH USA 62 57 10 N 155 36 20 W 103 62.953 -155.606 MRI PAMR MERRILL FLD ANCHORAGE USA 61 12 51 N 149 50 46 W 42 61.214 -149.846 ANC PANC TED STEVENS ANCHORAGE INTERNATIONAL ANCHORAGE USA 61 10 27 N 149 59 46 W 47 61.174 -149.996 OME PAOM NOME NOME USA 64 30 43 N 165 26 42 W 12 64.512 -165.445 ORT PAOR NORTHWAY NORTHWAY USA 62 57 40 N 141 55 44 W 524 62.961 -141.929 OTZ PAOT RALPH WIEN MEM KOTZEBUE USA 66 53 4 N 162 35 54 W 4 66.884 -162.598 PML PAPM PLATINUM PORT MOLLER USA 59 0 40 N 161 49 10 W 5 59.011 -161.819 SCC PASC DEADHORSE DEADHORSE USA 70 11 41 N 148 27 54 W 19 70.195 -148.465 SIT PASI SITKA ROCKY GUTIERREZ SITKA USA 57 2 49 N 135 21 41 W 8 57.047 -135.361 SNP PASN ST PAUL ISLAND ST. PAUL ISLAND USA 57 10 2 N 170 13 13 W 20 57.167 -170.22 SVW PASV SPARREVOHN LRRS SPARREVOHN USA 61 5 50 N 155 34 27 W 484 61.097 -155.574 SYA PASY EARECKSON AS SHEMYA USA 52 42 44 N 174 6 49 E 30 52.712 174.114 TAL PATA RALPH M CALHOUN TANANA USA 65 10 27 N 152 6 33 W 70 65.174 -152.109 TNC PATC TIN CITY LRRS TIN CITY USA 65 33 47 N 167 55 20 W 83 65.563 -167.922 TKA PATK TALKEETNA TALKEETNA USA 62 19 13 N 150 5 37 W 110 62.32 -150.094 TLJ PATL TATALINA LRRS TATALINA USA 62 53 39 N 155 58 35 W 294 62.894 -155.976 UNK PAUN UNALAKLEET UNALAKLEET USA 63 53 18 N 160 47 56 W 7 63.888 -160.799 VDZ PAVD VALDEZ PIONEER FIELD VALDEZ USA 61 8 2 N 146 14 54 W 37 61.134 -146.248 AIN PAWT WAINWRIGHT AS FORT WAINWRIGHT USA 70 36 48 N 159 51 37 W 11 70.613 -159.86 YAK PAYA YAKUTAT YAKUTAT USA 59 30 11 N 139 39 36 W 12 59.503 -139.66 FYU PFYU FORT YUKON FORT YUKON USA 66 34 17 N 145 15 1 W 132 66.571 -145.25 ROP PGRO ROTA INTERNATIONAL ROTA MARIANA ISLANDS 14 10 28 N 145 14 36 E 186 14.174 145.243 SPN PGSN SAIPAN INTERNATIONAL SAIPAN MARIANA ISLANDS 15 7 10 N 145 43 45 E 66 15.119 145.729 UAM PGUA ANDERSEN AFB ANDERSEN MARIANA ISLANDS 13 35 2 N 144 55 48 E 192 13.584 144.93 GUM PGUM GUAM INTERNATIONAL AGANA MARIANA ISLANDS 13 29 2 N 144 47 49 E 91 13.484 144.797 HNM PHHN HANA HANA USA 20 47 44 N 156 0 51 W 24 20.796 -156.014 JHM PHJH KAPALUA LAHANIA-KAPALUA USA 20 57 46 N 156 40 27 W 79 20.963 -156.674 KOA PHKO KONA INTERNATIONAL AT KEAHOLE KONA USA 19 44 19 N 156 2 44 W 15 19.739 -156.046 LIH PHLI LIHUE LIHUE USA 21 58 34 N 159 20 19 W 47 21.976 -159.339 MKK PHMK MOLOKAI MOLOKAI USA 21 9 10 N 157 5 46 W 139 21.153 -157.096 MUE PHMU WAIMEA KOHALA KAMUELA USA 20 0 4 N 155 40 5 W 815 20.001 -155.668 NGF PHNG KANEOHE BAY MCAF KANEOHE BAY USA 21 26 57 N 157 46 4 W 6 21.449 -157.768 HNL PHNL HONOLULU INTERNATIONAL HONOLULU USA 21 18 57 N 157 55 36 W 4 21.316 -157.927 LNY PHNY LANAI LANAI USA 20 47 8 N 156 57 5 W 399 20.786 -156.951 OGG PHOG KAHULUI KAHULUI USA 20 53 55 N 156 25 50 W 17 20.899 -156.431 ITO PHTO HILO INTERNATIONAL HILO USA 19 43 13 N 155 2 55 W 12 19.72 -155.049 PIZ PPIZ POINT LAY LRRS POINT LAY USA 69 43 58 N 163 0 19 W 8 69.733 -163.005 STT TIST CYRIL E KING ST. THOMAS VIRGIN ISL. 18 20 14 N 64 58 24 W 8 18.337 -64.973 STX TISX HENRY E ROHLSEN ST. CRIOX ISLAND VIRGIN ISL. 17 42 6 N 64 47 54 W 20 17.702 -64.798 BQN TJBQ RAFAEL HERNANDEZ AGUADILLA PUERTO RICO 18 29 41 N 67 7 46 W 73 18.495 -67.129 SIG TJIG FERNANDO LUIS RIBAS DOMINICCI SAN JUAN PUERTO RICO 18 27 24 N 66 5 53 W 4 18.457 -66.098 MAZ TJMZ EUGENIO MARIA DE HOSTOS MAYAGUEZ PUERTO RICO 18 15 20 N 67 8 54 W 9 18.256 -67.148 PSE TJPS MERCEDITA PONCE PUERTO RICO 18 0 29 N 66 33 46 W 8 18.008 -66.563 SJU TJSJ LUIS MUNOZ MARIN INTERNATIONAL SAN JUAN PUERTO RICO 18 26 21 N 66 0 6 W 3 18.439 -66.002 # Annotate graph with latitude and longitude no_gps = [] for n , d in pass_2015_network . nodes ( data = True ): try : pass_2015_network . nodes [ n ][ \"longitude\" ] = us_airports . loc [ n , \"LONGITUDE\" ] pass_2015_network . nodes [ n ][ \"latitude\" ] = us_airports . loc [ n , \"LATITUDE\" ] pass_2015_network . nodes [ n ][ \"degree\" ] = pass_2015_network . degree ( n ) # Some of the nodes are not represented except KeyError : no_gps . append ( n ) # Get subgraph of nodes that do have GPS coords has_gps = set ( pass_2015_network . nodes ()) . difference ( no_gps ) g = pass_2015_network . subgraph ( has_gps ) Let's first plot only the nodes, i.e airports. Places like Guam, US Virgin Islands are also included in this dataset as they are treated as domestic airports in this dataset. import nxviz as nv from nxviz import nodes , plots , edges plt . figure ( figsize = ( 20 , 9 )) pos = nodes . geo ( g , aesthetics_kwargs = { \"size_scale\" : 1 }) plots . aspect_equal () plots . despine () /home/runner/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.0 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.6.3, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( Let's also plot the routes(edges). import nxviz as nv from nxviz import nodes , plots , edges , annotate plt . figure ( figsize = ( 20 , 9 )) pos = nodes . geo ( g , color_by = \"degree\" , aesthetics_kwargs = { \"size_scale\" : 1 }) edges . line ( g , pos , aesthetics_kwargs = { \"alpha_scale\" : 0.1 }) annotate . node_colormapping ( g , color_by = \"degree\" ) plots . aspect_equal () plots . despine () Before we proceed further, let's take a detour to briefly discuss directed networks and PageRank. Directed Graphs and PageRank The figure below explains the basic idea behind the PageRank algorithm. The \"importance\" of the node depends on the incoming links to the node, i.e if an \"important\" node A points towards a node B it will increase the PageRank score of node B, and this is run iteratively. In the given figure, even though node C is only connected to one node it is considered \"important\" as the connection is to node B, which is an \"important\" node. Source: Wikipedia To better understand this let's work through an example. # Create an empty directed graph object G = nx . DiGraph () # Add an edge from 1 to 2 with weight 4 G . add_edge ( 1 , 2 , weight = 4 ) print ( G . edges ( data = True )) [(1, 2, {'weight': 4})] # Access edge from 1 to 2 G [ 1 ][ 2 ] {'weight': 4} What happens when we try to access the edge from 2 to 1? G [ 2 ][ 1 ] --------------------------------------------------------------------------- KeyError Traceback ( most recent call last ) < ipython - input - 137 - d6b8db3142ef > in < module > 1 # Access edge from 2 to 1 ----> 2 G [ 2 ][ 1 ] ~/ miniconda3 / envs / nams / lib / python3 . 7 / site - packages / networkx / classes / coreviews . py in __getitem__ ( self , key ) 52 53 def __getitem__ ( self , key ): ---> 54 return self . _atlas [ key ] 55 56 def copy ( self ): KeyError : 1 As expected we get an error when we try to access the edge between 2 to 1 as this is a directed graph. G . add_edges_from ([( 1 , 2 ), ( 3 , 2 ), ( 4 , 2 ), ( 5 , 2 ), ( 6 , 2 ), ( 7 , 2 )]) # nx.draw_spring(G, with_labels=True) nv . circos ( G , node_aes_kwargs = { \"size_scale\" : 0.3 }) <AxesSubplot:> Just by looking at the example above, we can conclude that node 2 should have the highest PageRank score as all the nodes are pointing towards it. This is confirmed by calculating the PageRank of this graph. nx . pagerank ( G ) {1: 0.0826448180198328, 2: 0.5041310918810031, 3: 0.0826448180198328, 4: 0.0826448180198328, 5: 0.0826448180198328, 6: 0.0826448180198328, 7: 0.0826448180198328} What happens when we add an edge from node 5 to node 6. G . add_edge ( 5 , 6 ) nv . circos ( G , node_aes_kwargs = { \"size_scale\" : 0.3 }) # nx.draw_spring(G, with_labels=True) <AxesSubplot:> nx . pagerank ( G ) {1: 0.08024854052495894, 2: 0.4844028780560986, 3: 0.08024854052495894, 4: 0.08024854052495894, 5: 0.08024854052495894, 6: 0.11435441931910648, 7: 0.08024854052495894} As expected there was some change in the scores (an increase for 6) but the overall trend stays the same, with node 2 leading the pack. G . add_edge ( 2 , 8 ) nv . circos ( G , node_aes_kwargs = { \"size_scale\" : 0.3 }) <AxesSubplot:> Now we have an added an edge from 2 to a new node 8. As node 2 already has a high PageRank score, this should be passed on node 8. Let's see how much difference this can make. nx . pagerank ( G ) {1: 0.05378612718073915, 2: 0.3246687852772877, 3: 0.05378612718073915, 4: 0.05378612718073915, 5: 0.05378612718073915, 6: 0.0766454192258098, 7: 0.05378612718073915, 8: 0.3297551595932067} In this example, node 8 is now even more \"important\" than node 2 even though node 8 has only incoming connection. Let's move back to Airports and use this knowledge to analyse the network. Importants Hubs in the Airport Network So let's have a look at the important nodes in this network, i.e. important airports in this network. We'll use centrality measures like pagerank, betweenness centrality and degree centrality which we gone through in this book. Let's try to calculate the PageRank of passenger_graph . nx . pagerank ( passenger_graph ) --------------------------------------------------------------------------- NetworkXNotImplemented Traceback ( most recent call last ) < ipython - input - 144 - 15 a6f513bf9b > in < module > 1 # Let's try to calulate the PageRank measures of this graph. ----> 2 nx . pagerank ( passenger_graph ) < decorator - gen - 435 > in pagerank ( G , alpha , personalization , max_iter , tol , nstart , weight , dangling ) ~/ miniconda3 / envs / nams / lib / python3 . 7 / site - packages / networkx / utils / decorators . py in _not_implemented_for ( not_implement_for_func , * args , ** kwargs ) 78 if match : 79 msg = 'not implemented for %s type' % ' ' . join ( graph_types ) ---> 80 raise nx . NetworkXNotImplemented ( msg ) 81 else : 82 return not_implement_for_func ( * args , ** kwargs ) NetworkXNotImplemented : not implemented for multigraph type As PageRank isn't defined for a MultiGraph in NetworkX we need to use our extracted yearly sub networks. # As pagerank will take weighted measure # by default we pass in None to make this # calculation for unweighted network PR_2015_scores = nx . pagerank ( pass_2015_network , weight = None ) # Let's check the PageRank score for JFK PR_2015_scores [ 'JFK' ] 0.0036376572979606586 # top 10 airports according to unweighted PageRank top_10_pr = sorted ( PR_2015_scores . items (), key = lambda x : x [ 1 ], reverse = True )[: 10 ] # top 10 airports according to unweighted betweenness centrality top_10_bc = sorted ( nx . betweenness_centrality ( pass_2015_network , weight = None ) . items (), key = lambda x : x [ 1 ], reverse = True )[ 0 : 10 ] # top 10 airports according to degree centrality top_10_dc = sorted ( nx . degree_centrality ( pass_2015_network ) . items (), key = lambda x : x [ 1 ], reverse = True )[ 0 : 10 ] Before looking at the results do think about what we just calculated and try to guess which airports should come out at the top and be ready to be surprised :D # PageRank top_10_pr [('ANC', 0.010425531156396332), ('HPN', 0.008715287139161587), ('FAI', 0.007865131822111036), ('DFW', 0.007168038232113773), ('DEN', 0.006557279519803018), ('ATL', 0.006367579588749718), ('ORD', 0.006178836107660135), ('YIP', 0.005821525504523931), ('ADQ', 0.005482597083474197), ('MSP', 0.005481962582230961)] # Betweenness Centrality top_10_bc [('ANC', 0.28907458480586606), ('FAI', 0.08042857784594384), ('SEA', 0.06745549919241699), ('HPN', 0.06046810178534726), ('ORD', 0.045544143864829294), ('ADQ', 0.040170160000905696), ('DEN', 0.038543251364241436), ('BFI', 0.03811277548952854), ('MSP', 0.03774809342340624), ('TEB', 0.036229439542316354)] # Degree Centrality top_10_dc [('ATL', 0.3643595863166269), ('ORD', 0.354813046937152), ('DFW', 0.3420843277645187), ('MSP', 0.3261734287987271), ('DEN', 0.31821797931583135), ('ANC', 0.3046937151949085), ('MEM', 0.29196499602227527), ('LAX', 0.2840095465393795), ('IAH', 0.28082736674622116), ('DTW', 0.27446300715990457)] The Degree Centrality results do make sense at first glance, ATL is Atlanta, ORD is Chicago, these are defintely airports one would expect to be at the top of a list which calculates \"importance\" of an airport. But when we look at PageRank and Betweenness Centrality we have an unexpected airport 'ANC'. Do think about measures like PageRank and Betweenness Centrality and what they calculate. Do note that currently we have used the core structure of the network, no other metadata like number of passengers. These are calculations on the unweighted network. 'ANC' is the airport code of Anchorage airport, a place in Alaska, and according to pagerank and betweenness centrality it is the most important airport in this network. Isn't that weird? Thoughts? Looks like 'ANC' is essential to the core structure of the network, as it is the main airport connecting Alaska with other parts of US. This explains the high Betweenness Centrality score and there are flights from other major airports to 'ANC' which explains the high PageRank score. Related blog post: https://toreopsahl.com/2011/08/12/why-anchorage-is-not-that-important-binary-ties-and-sample-selection/ Let's look at weighted version, i.e taking into account the number of people flying to these places. # Recall from the last chapter we use weight_inv # while calculating betweenness centrality sorted ( nx . betweenness_centrality ( pass_2015_network , weight = 'weight_inv' ) . items (), key = lambda x : x [ 1 ], reverse = True )[ 0 : 10 ] [('SEA', 0.4192179843829966), ('ATL', 0.3589665389741017), ('ANC', 0.32425767084369994), ('LAX', 0.2668567170342895), ('ORD', 0.10008664852621497), ('DEN', 0.0964658422388763), ('MSP', 0.09300021788810685), ('DFW', 0.0926644126226465), ('FAI', 0.08824779747216016), ('BOS', 0.08259764427486331)] sorted ( nx . pagerank ( pass_2015_network , weight = 'weight' ) . items (), key = lambda x : x [ 1 ], reverse = True )[ 0 : 10 ] [('ATL', 0.037535963029303135), ('ORD', 0.028329766122739346), ('SEA', 0.028274564067008245), ('ANC', 0.027127866647567035), ('DFW', 0.02570050418889442), ('DEN', 0.025260024346433315), ('LAX', 0.02394043498608451), ('PHX', 0.018373176636420224), ('CLT', 0.01780703930063076), ('LAS', 0.017649683141049966)] When we adjust for number of passengers we see that we have a reshuffle in the \"importance\" rankings, and they do make a bit more sense now. According to weighted PageRank, Atlanta, Chicago, Seattle the top 3 airports while Anchorage is at 4th rank now. To get an even better picture of this we should do the analyse with more metadata about the routes not just the number of passengers. How reachable is this network? Let's assume you are the Head of Data Science of an airline and your job is to make your airline network as \"connected\" as possible. To translate this problem statement to network science, we calculate the average shortest path length of this network, it gives us an idea about the number of jumps we need to make around the network to go from one airport to any other airport in this network on average. We can use the inbuilt networkx method average_shortest_path_length to find the average shortest path length of a network. nx . average_shortest_path_length ( pass_2015_network ) --------------------------------------------------------------------------- NetworkXError Traceback ( most recent call last ) < ipython - input - 157 - acfe9bf3572a > in < module > ----> 1 nx . average_shortest_path_length ( pass_2015_network ) ~/ miniconda3 / envs / nams / lib / python3 . 7 / site - packages / networkx / algorithms / shortest_paths / generic . py in average_shortest_path_length ( G , weight , method ) 401 # Shortest path length is undefined if the graph is disconnected. 402 if G . is_directed () and not nx . is_weakly_connected ( G ): --> 403 raise nx . NetworkXError ( \"Graph is not weakly connected.\" ) 404 if not G . is_directed () and not nx . is_connected ( G ): 405 raise nx . NetworkXError ( \"Graph is not connected.\" ) NetworkXError : Graph is not weakly connected . Wait, What? This network is not \"connected\" (ignore the term weakly for the moment). That seems weird. It means that there are nodes which aren't reachable from other set of nodes, which isn't good news in especially a transporation network. Let's have a look at these far flung airports which aren't reachable. components = list ( nx . weakly_connected_components ( pass_2015_network )) # There are 3 weakly connected components in the network. for c in components : print ( len ( c )) 1255 2 1 # Let's look at the component with 2 and 1 airports respectively. print ( components [ 1 ]) print ( components [ 2 ]) {'SPB', 'SSB'} {'AIK'} The airports 'SSB' and 'SPB' are codes for Seaplanes airports and they have flights to each other so it makes sense that they aren't connected to the larger network of airports. The airport is even more weird as it is in a component in itself, i.e there is a flight from AIK to AIK. After investigating further it just seems like an anomaly in this dataset. AIK_DEST_2015 = pass_air_data [ ( pass_air_data [ 'YEAR' ] == 2015 ) & ( pass_air_data [ 'DEST' ] == 'AIK' )] AIK_DEST_2015 . head () id YEAR ORIGIN DEST UNIQUE_CARRIER_NAME PASSENGERS 433338 2015 AIK AIK {'Wright Air Service'} 0 # Let's get rid of them, we don't like them pass_2015_network . remove_nodes_from ( [ 'SPB' , 'SSB' , 'AIK' ]) # Our network is now weakly connected nx . is_weakly_connected ( pass_2015_network ) True # It's not strongly connected nx . is_strongly_connected ( pass_2015_network ) False Strongly vs weakly connected graphs. Let's go through an example to understand weakly and strongly connected directed graphs. # NOTE: The notion of strongly and weakly exists only for directed graphs. G = nx . DiGraph () # Let's create a cycle directed graph, 1 -> 2 -> 3 -> 1 G . add_edge ( 1 , 2 ) G . add_edge ( 2 , 3 ) G . add_edge ( 3 , 1 ) nx . draw ( G , with_labels = True ) In the above example we can reach any node irrespective of where we start traversing the network, if we start from 2 we can reach 1 via 3. In this network every node is \"reachable\" from one another, i.e the network is strongly connected. nx . is_strongly_connected ( G ) True # Let's add a new connection G . add_edge ( 3 , 4 ) nx . draw ( G , with_labels = True ) It's evident from the example above that we can't traverse the network graph. If we start from node 4 we are stuck at the node, we don't have any way of leaving node 4. This is assuming we strictly follow the direction of edges. In this case the network isn't strongly connected but if we look at the structure and assume the directions of edges don't matter than we can go to any other node in the network even if we start from node 4. In the case an undirected copy of directed network is connected we call the directed network as weakly connected. nx . is_strongly_connected ( G ) False nx . is_weakly_connected ( G ) True Let's go back to our airport network of 2015. After removing those 3 airports the network is weakly connected. nx . is_weakly_connected ( pass_2015_network ) True nx . is_strongly_connected ( pass_2015_network ) False But our network is still not strongly connected, which essentially means there are airports in the network where you can fly into but not fly back, which doesn't really seem okay strongly_connected_components = list ( nx . strongly_connected_components ( pass_2015_network )) # Let's look at one of the examples of a strong connected component strongly_connected_components [ 0 ] {'BCE'} BCE_DEST_2015 = pass_air_data [ ( pass_air_data [ 'YEAR' ] == 2015 ) & ( pass_air_data [ 'DEST' ] == 'BCE' )] BCE_DEST_2015 . head () id YEAR ORIGIN DEST UNIQUE_CARRIER_NAME PASSENGERS 451074 2015 PGA BCE {'Grand Canyon Airlines, Inc. d/b/a Grand Canyo... 8 BCE_ORI_2015 = pass_air_data [ ( pass_air_data [ 'YEAR' ] == 2015 ) & ( pass_air_data [ 'ORIGIN' ] == 'BCE' )] BCE_ORI_2015 . head () --------------------------------------------------------------------------- ValueError Traceback (most recent call last) ~/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/IPython/core/formatters.py in __call__ (self, obj) 339 pass 340 else : --> 341 return printer ( obj ) 342 # Finally look for special method names 343 method = get_real_method ( obj , self . print_method ) ~/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/mknotebooks/pandas_output_formatter.py in to_md (df, max_colwidth) 24 # Truncate entries wider than max_colwidth 25 return ( ---> 26 df . astype ( str ) 27 .apply( 28 lambda x: [ ~/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/pandas/core/frame.py in apply (self, func, axis, raw, result_type, args, **kwds) 7766 kwds = kwds , 7767 ) -> 7768 return op . get_result ( ) 7769 7770 def applymap ( self , func , na_action : Optional [ str ] = None ) -> DataFrame : ~/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/pandas/core/apply.py in get_result (self) 177 # one axis empty 178 elif not all ( self . obj . shape ) : --> 179 return self . apply_empty_result ( ) 180 181 # raw ~/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/pandas/core/apply.py in apply_empty_result (self) 216 r = np . nan 217 --> 218 return self . obj . _constructor_sliced ( r , index = self . agg_axis ) 219 else : 220 return self . obj . copy ( ) ~/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/pandas/core/series.py in __init__ (self, data, index, dtype, name, copy, fastpath) 348 try : 349 if len ( index ) != len ( data ) : --> 350 raise ValueError( 351 f\"Length of passed values is {len(data)}, \" 352 f\"index implies {len(index)}.\" ValueError : Length of passed values is 0, index implies 5. --------------------------------------------------------------------------- ValueError Traceback (most recent call last) ~/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/IPython/core/formatters.py in __call__ (self, obj) 339 pass 340 else : --> 341 return printer ( obj ) 342 # Finally look for special method names 343 method = get_real_method ( obj , self . print_method ) ~/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/mknotebooks/pandas_output_formatter.py in to_md (df, max_colwidth) 24 # Truncate entries wider than max_colwidth 25 return ( ---> 26 df . astype ( str ) 27 .apply( 28 lambda x: [ ~/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/pandas/core/frame.py in apply (self, func, axis, raw, result_type, args, **kwds) 7766 kwds = kwds , 7767 ) -> 7768 return op . get_result ( ) 7769 7770 def applymap ( self , func , na_action : Optional [ str ] = None ) -> DataFrame : ~/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/pandas/core/apply.py in get_result (self) 177 # one axis empty 178 elif not all ( self . obj . shape ) : --> 179 return self . apply_empty_result ( ) 180 181 # raw ~/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/pandas/core/apply.py in apply_empty_result (self) 216 r = np . nan 217 --> 218 return self . obj . _constructor_sliced ( r , index = self . agg_axis ) 219 else : 220 return self . obj . copy ( ) ~/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/pandas/core/series.py in __init__ (self, data, index, dtype, name, copy, fastpath) 348 try : 349 if len ( index ) != len ( data ) : --> 350 raise ValueError( 351 f\"Length of passed values is {len(data)}, \" 352 f\"index implies {len(index)}.\" ValueError : Length of passed values is 0, index implies 5. Empty DataFrame Columns: [YEAR, ORIGIN, DEST, UNIQUE_CARRIER_NAME, PASSENGERS] Index: [] As we can see above you can fly into 'BCE' but can't fly out, weird indeed. These airport are small airports with one off schedules flights. For the purposes of our analyses we can ignore such airports. # Let's find the biggest strongly connected component pass_2015_strong_nodes = max ( strongly_connected_components , key = len ) # Create a subgraph with the nodes in the # biggest strongly connected component pass_2015_strong = pass_2015_network . subgraph ( nodes = pass_2015_strong_nodes ) nx . is_strongly_connected ( pass_2015_strong ) True After removing multiple airports we now have a strongly connected airport network. We can now travel from one airport to any other airport in the network. # We started with 1258 airports len ( pass_2015_strong ) 1190 nx . average_shortest_path_length ( pass_2015_strong ) 3.174661992635574 The 3.17 number above represents the average length between 2 airports in the network which means that it's possible to go from one airport to another in this network under 3 layovers, which sounds nice. A more reachable network is better, not necessearily in terms of revenue for the airline but for social health of the air transport network. Exercise How can we decrease the average shortest path length of this network? Think of an effective way to add new edges to decrease the average shortest path length. Let's see if we can come up with a nice way to do this. The rules are simple: - You can't add more than 2% of the current edges( ~500 edges) from nams.solutions.airport import add_opinated_edges new_routes_network = add_opinated_edges ( pass_2015_strong ) nx . average_shortest_path_length ( new_routes_network ) 3.0888508809747615 Using an opinionated heuristic we were able to reduce the average shortest path length of the network. Check the solution below to understand the idea behind the heuristic, do try to come up with your own heuristics. Can we find airline specific reachability? Let's see how we can use the airline metadata to calculate the reachability of a specific airline. # We have access to the airlines that fly the route in the edge attribute airlines pass_2015_network [ 'JFK' ][ 'SFO' ] {'weight': 1179941.0, 'weight_inv': 8.4750000211875e-07, 'airlines': \"{'Delta Air Lines Inc.', 'Virgin America', 'American Airlines Inc.', 'Sun Country Airlines d/b/a MN Airlines', 'JetBlue Airways', 'Vision Airlines', 'United Air Lines Inc.'}\"} # A helper function to extract the airlines names from the edge attribute def str_to_list ( a ): return a [ 1 : - 1 ] . split ( ', ' ) for origin , dest in pass_2015_network . edges (): pass_2015_network [ origin ][ dest ][ 'airlines_list' ] = str_to_list ( ( pass_2015_network [ origin ][ dest ][ 'airlines' ])) Let's extract the network of United Airlines from our airport network. united_network = nx . DiGraph () for origin , dest in pass_2015_network . edges (): if \"'United Air Lines Inc.'\" in pass_2015_network [ origin ][ dest ][ 'airlines_list' ]: united_network . add_edge ( origin , dest , weight = pass_2015_network [ origin ][ dest ][ 'weight' ]) # number of nodes -> airports # number of edges -> routes print ( nx . info ( united_network )) Name: Type: DiGraph Number of nodes: 194 Number of edges: 1894 Average in degree: 9.7629 Average out degree: 9.7629 # Let's find United Hubs according to PageRank sorted ( nx . pagerank ( united_network , weight = 'weight' ) . items (), key = lambda x : x [ 1 ], reverse = True )[ 0 : 5 ] [('ORD', 0.08385772266571424), ('DEN', 0.06816244850418422), ('LAX', 0.053065234147240105), ('IAH', 0.044410609028379185), ('SFO', 0.04326197030283029)] # Let's find United Hubs according to Degree Centrality sorted ( nx . degree_centrality ( united_network ) . items (), key = lambda x : x [ 1 ], reverse = True )[ 0 : 5 ] [('ORD', 1.0), ('IAH', 0.9274611398963731), ('DEN', 0.8756476683937824), ('EWR', 0.8134715025906736), ('SFO', 0.6839378238341969)] Solutions Here are the solutions to the exercises above. from nams.solutions import airport import inspect print ( inspect . getsource ( airport )) import networkx as nx import pandas as pd def busiest_route(pass_air_data, year): return pass_air_data[ pass_air_data.groupby([\"YEAR\"])[\"PASSENGERS\"].transform(max) == pass_air_data[\"PASSENGERS\"] ].query(f\"YEAR == {year}\") def plot_time_series(pass_air_data, origin, dest): pass_air_data.query(f\"ORIGIN == '{origin}' and DEST == '{dest}'\").plot( \"YEAR\", \"PASSENGERS\" ) def add_opinated_edges(G): G = nx.DiGraph(G) sort_degree = sorted( nx.degree_centrality(G).items(), key=lambda x: x[1], reverse=True ) top_count = 0 for n, v in sort_degree: count = 0 for node, val in sort_degree: if node != n: if node not in G._adj[n]: G.add_edge(n, node) count += 1 if count == 25: break top_count += 1 if top_count == 20: break return G","title":"Chapter 13: Airport Network"},{"location":"05-casestudies/02-airport/#introduction","text":"In this chapter, we will analyse the evolution of US Airport Network between 1990 and 2015. This dataset contains data for 25 years[1995-2015] of flights between various US airports and metadata about these routes. Taken from Bureau of Transportation Statistics, United States Department of Transportation. Let's see what can we make out of this! from nams import load_data as cf pass_air_data = cf . load_airports_data () In the pass_air_data dataframe we have the information of number of people that fly every year on a particular route on the list of airlines that fly that route. pass_air_data . head () id YEAR ORIGIN DEST UNIQUE_CARRIER_NAME PASSENGERS 0 1990 ABE ACY {'US Airways Inc.'} 73 1 1990 ABE ATL {'Eastern Air Lines Inc.'} 73172 2 1990 ABE AVL {'Westair Airlines Inc.'} 0 3 1990 ABE AVP {'Westair Airlines Inc.', 'US Airways Inc.', 'E... 8397 4 1990 ABE BHM {'Eastern Air Lines Inc.'} 59 Every row in this dataset is a unique route between 2 airports in United States territory in a particular year. Let's see how many people flew from New York JFK to Austin in 2006. NOTE: This will be a fun chapter if you are an aviation geek and like guessing airport IATA codes. jfk_aus_2006 = ( pass_air_data . query ( 'YEAR == 2006' ) . query ( \"ORIGIN == 'JFK' and DEST == 'AUS'\" )) jfk_aus_2006 . head () id YEAR ORIGIN DEST UNIQUE_CARRIER_NAME PASSENGERS 215634 2006 JFK AUS {'Shuttle America Corp.', 'Ameristar Air Cargo'... 105290 From the above pandas query we see that according to this dataset 105290 passengers travelled from JFK to AUS in the year 2006. But how does this dataset translate to an applied network analysis problem? In the previous chapter we created different graph objects for every book. Let's create a graph object which encompasses all the edges. NetworkX provides us with Multi(Di)Graphs to model networks with multiple edges between two nodes. In this case every row in the dataframe represents a directed edge between two airports, common sense suggests that if there is a flight from airport A to airport B there should definitely be a flight from airport B to airport A, i.e direction of the edge shouldn't matter. But in this dataset we have data for individual directions (A -> B and B -> A) so we create a MultiDiGraph. passenger_graph = nx . from_pandas_edgelist ( pass_air_data , source = 'ORIGIN' , target = 'DEST' , edge_key = 'YEAR' , edge_attr = [ 'PASSENGERS' , 'UNIQUE_CARRIER_NAME' ], create_using = nx . MultiDiGraph ()) We have created a MultiDiGraph object passenger_graph which contains all the information from the dataframe pass_air_data . ORIGIN and DEST represent the column names in the dataframe pass_air_data used to construct the edge. As this is a MultiDiGraph we can also give a name/key to the multiple edges between two nodes and edge_key is used to represent that name and in this graph YEAR is used to distinguish between multiple edges between two nodes. PASSENGERS and UNIQUE_CARRIER_NAME are added as edge attributes which can be accessed using the nodes and the key form the MultiDiGraph object. Let's check if can access the same information (the 2006 route between JFK and AUS) using our passenger_graph . To check an edge between two nodes in a Graph we can use the syntax GraphObject[source][target] and further specify the edge attribute using GraphObject[source][target][attribute] . passenger_graph [ 'JFK' ][ 'AUS' ][ 2006 ] {'PASSENGERS': 105290.0, 'UNIQUE_CARRIER_NAME': \"{'Shuttle America Corp.', 'Ameristar Air Cargo', 'JetBlue Airways', 'United Parcel Service'}\"} Now let's use our new constructed passenger graph to look at the evolution of passenger load over 25 years. # Route betweeen New York-JFK and SFO values = [( year , attr [ 'PASSENGERS' ]) for year , attr in passenger_graph [ 'JFK' ][ 'SFO' ] . items ()] x , y = zip ( * values ) plt . plot ( x , y ) plt . show () We see some usual trends all across the datasets like steep drops in 2001 (after 9/11) and 2008 (recession). # Route betweeen SFO and Chicago-ORD values = [( year , attr [ 'PASSENGERS' ]) for year , attr in passenger_graph [ 'SFO' ][ 'ORD' ] . items ()] x , y = zip ( * values ) plt . plot ( x , y ) plt . show () To find the overall trend, we can use our pass_air_data dataframe to calculate total passengers flown in a year. pass_air_data . groupby ( [ 'YEAR' ]) . sum ()[ 'PASSENGERS' ] . plot () plt . show ()","title":"Introduction"},{"location":"05-casestudies/02-airport/#exercise","text":"Find the busiest route in 1990 and in 2015 according to number of passengers, and plot the time series of number of passengers on these routes. You can use the DataFrame instead of working with the network. It will be faster :) from nams.solutions.airport import busiest_route , plot_time_series busiest_route ( pass_air_data , 1990 ) . head () id YEAR ORIGIN DEST UNIQUE_CARRIER_NAME PASSENGERS 3917 1990 LAX HNL {'Heavylift Cargo Airlines Lt', 'Hawaiian Airli... 1.82716e+06 plot_time_series ( pass_air_data , 'LAX' , 'HNL' ) busiest_route ( pass_air_data , 2015 ) . head () id YEAR ORIGIN DEST UNIQUE_CARRIER_NAME PASSENGERS 445978 2015 LAX SFO {'Hawaiian Airlines Inc.', 'Delta Air Lines Inc... 1.86907e+06 plot_time_series ( pass_air_data , 'LAX' , 'SFO' ) Before moving to the next part of the chapter let's create a method to extract edges from passenger_graph for a particular year so we can better analyse the data on a granular scale. def year_network ( G , year ): \"\"\" Extract edges for a particular year from a MultiGraph. The edge is also populated with two attributes, weight and weight_inv where weight is the number of passengers and weight_inv the inverse of it. \"\"\" year_network = nx . DiGraph () for edge in G . edges : source , target , edge_year = edge if edge_year == year : attr = G [ source ][ target ][ edge_year ] year_network . add_edge ( source , target , weight = attr [ 'PASSENGERS' ], weight_inv = 1 / ( attr [ 'PASSENGERS' ] if attr [ 'PASSENGERS' ] != 0.0 else 1 ), airlines = attr [ 'UNIQUE_CARRIER_NAME' ]) return year_network pass_2015_network = year_network ( passenger_graph , 2015 ) # Extracted a Directed Graph from the Multi Directed Graph # Number of nodes = airports # Number of edges = routes print ( nx . info ( pass_2015_network )) Name: Type: DiGraph Number of nodes: 1258 Number of edges: 25354 Average in degree: 20.1542 Average out degree: 20.1542","title":"Exercise"},{"location":"05-casestudies/02-airport/#visualise-the-airports","text":"# Loadin the GPS coordinates of all the airports from nams import load_data as cf lat_long = cf . load_airports_GPS_data () lat_long . columns = [ \"CODE4\" , \"CODE3\" , \"CITY\" , \"PROVINCE\" , \"COUNTRY\" , \"UNKNOWN1\" , \"UNKNOWN2\" , \"UNKNOWN3\" , \"UNKNOWN4\" , \"UNKNOWN5\" , \"UNKNOWN6\" , \"UNKNOWN7\" , \"UNKNOWN8\" , \"UNKNOWN9\" , \"LATITUDE\" , \"LONGITUDE\" ] lat_long wanted_nodes = list ( pass_2015_network . nodes ()) us_airports = lat_long . query ( \"CODE3 in @wanted_nodes\" ) . drop_duplicates ( subset = [ \"CODE3\" ]) . set_index ( \"CODE3\" ) us_airports # us_airports CODE3 CODE4 CITY PROVINCE COUNTRY UNKNOWN1 UNKNOWN2 UNKNOWN3 UNKNOWN4 UNKNOWN5 UNKNOWN6 UNKNOWN7 UNKNOWN8 UNKNOWN9 LATITUDE LONGITUDE ABI KABI ABILENE RGNL ABILENE USA 32 24 40 N 99 40 54 W 546 32.411 -99.682 ABQ KABQ nan ALBUQUERQUE USA 0 0 0 U 0 0 0 U 0 0 0 ACK KACK NANTUCKET MEM NANTUCKET USA 41 15 10 N 70 3 36 W 15 41.253 -70.06 ACT KACT WACO RGNL WACO USA 31 36 40 N 97 13 49 W 158 31.611 -97.23 ACY KACY ATLANTIC CITY INTERNATIONAL ATLANTIC CITY USA 39 27 27 N 74 34 37 W 23 39.458 -74.577 ADW KADW ANDREWS AFB CAMP SPRINGS USA 38 48 38 N 76 52 1 W 86 38.811 -76.867 AEX KAEX ALEXANDRIA INTERNATIONAL ALEXANDRIA USA 31 19 38 N 92 32 54 W 28 31.327 -92.548 AGS KAGS AUGUSTA RGNL AT BUSH FLD BUSH FIELD USA 33 22 11 N 81 57 52 W 44 33.37 -81.964 ALB KALB ALBANY INTERNATIONAL ALBANY USA 42 44 53 N 73 48 10 W 87 42.748 -73.803 AMA KAMA AMARILLO INTERNATIONAL AMARILLO USA 35 13 9 N 101 42 21 W 1100 35.219 -101.706 ANB KANB ANNISTON METROPOLITAN ANNISTON USA 33 35 17 N 85 51 29 W 187 33.588 -85.858 AOO KAOO ALTOONA BLAIR CO ALTOONA USA 40 17 47 N 78 19 12 W 459 40.296 -78.32 ARA KARA ACADIANA REGIONAL LOUISIANA USA 30 2 15 N 91 53 2 W 8 30.038 -91.884 ART KART WATERTOWN INTERNATIONAL WATERTOWN USA 43 59 30 N 76 1 18 W 100 43.992 -76.022 ATL KATL THE WILLIAM B HARTSFIELD ATLANTA INTERNATIONAL ATLANTA USA 33 38 25 N 84 25 37 W 313 33.64 -84.427 AUG KAUG AUGUSTA STATE AUGUSTA USA 44 19 14 N 69 47 50 W 108 44.321 -69.797 AUS KAUS AUSTIN BERGSTROM INTERNATIONAL AUSTIN USA 30 11 40 N 97 40 11 W 166 30.194 -97.67 BAD KBAD BARKSDALE AFB SHREVEPORT USA 32 30 6 N 93 39 45 W 51 32.502 -93.663 BCT KBCT BOCA RATON BOCA RATON USA 26 22 42 N 80 6 27 W 4 26.378 -80.107 BDL KBDL BRADLEY INTERNATIONAL WINDSOR LOCKS USA 41 56 20 N 72 40 59 W 53 41.939 -72.683 BDR KBDR IGOR I SIKORSKY MEM STRATFORD USA 41 9 48 N 73 7 34 W 3 41.163 -73.126 BED KBED LAURENCE G HANSCOM FLD BEDFORD USA 42 28 11 N 71 17 20 W 41 42.47 -71.289 BFI KBFI BOEING FLD KING CO INTERNATIONAL SEATTLE USA 47 31 47 N 122 18 7 W 6 47.53 -122.302 BFL KBFL MEADOWS FLD BAKERSFIELD USA 35 26 0 N 119 3 24 W 155 35.433 -119.057 BFM KBFM MOBILE DOWNTOWN MOBILE USA 30 37 35 N 88 4 4 W 8 30.626 -88.068 BGR KBGR BANGOR INTERNATIONAL BANGOR USA 44 48 26 N 68 49 41 W 59 44.807 -68.828 BHM KBHM BIRMINGHAM INTERNATIONAL BIRMINGHAM USA 33 33 46 N 86 45 12 W 197 33.563 -86.753 BIF KBIF BIGGS AAF EL PASO USA 31 50 58 N 106 22 48 W 1203 31.849 -106.38 BLI KBLI BELLINGHAM INTERNATIONAL BELLINGHAM USA 48 47 33 N 122 32 15 W 52 48.792 -122.537 BLV KBLV SCOTT AFB MIDAMERICA BELLEVILLE USA 38 32 42 N 89 50 6 W 140 38.545 -89.835 BNA KBNA NASHVILLE INTERNATIONAL NASHVILLE USA 36 7 28 N 86 40 41 W 183 36.124 -86.678 BOI KBOI BOISE AIR TERMINAL BOISE USA 43 33 51 N 116 13 22 W 876 43.564 -116.223 BOS KBOS GENERAL EDWARD LAWRENCE LOGAN INTERNATIONAL BOSTON USA 42 21 51 N 71 0 18 W 6 42.364 -71.005 BPT KBPT SOUTHEAST TEXAS RGNL BEAUMONT USA 29 57 3 N 94 1 14 W 5 29.951 -94.021 BRO KBRO BROWNSVILLE SOUTH PADRE ISLAND INTERNATIONAL BROWNSVILLE USA 25 54 24 N 97 25 33 W 7 25.907 -97.426 BTR KBTR BATON ROUGE METRO RYAN FLD BATON ROUGE USA 30 31 59 N 91 8 58 W 22 30.533 -91.149 BTV KBTV BURLINGTON INTERNATIONAL BURLINGTON USA 44 28 18 N 73 9 11 W 103 44.472 -73.153 BUF KBUF BUFFALO NIAGARA INTERNATIONAL BUFFALO USA 42 56 25 N 78 43 55 W 221 42.94 -78.732 BUR KBUR BURBANK GLENDALE PASADENA BURBANK USA 34 12 2 N 118 21 31 W 238 34.201 -118.359 BWI KBWI BALTIMORE WASHINGTON INTERNATIONAL BALTIMORE USA 39 10 31 N 76 40 6 W 45 39.175 -76.668 CAE KCAE COLUMBIA METROPOLITAN COLOMBIA USA 33 56 19 N 81 7 10 W 72 33.939 -81.119 CDC KCDC CEDAR CITY RGNL CEDAR CITY USA 37 42 3 N 113 5 55 W 1714 37.701 -113.099 CEF KCEF WESTOVER ARB METROPOLITAN CHICOPEE FALLS USA 42 11 53 N 72 32 3 W 75 42.198 -72.534 CEW KCEW BOB SIKES CRESTVIEW USA 30 46 43 N 86 31 19 W 65 30.779 -86.522 CHA KCHA LOVELL FLD CHATTANOOGA USA 35 2 7 N 85 12 13 W 208 35.035 -85.204 CHS KCHS CHARLESTON AFB INTERNATIONAL CHARLESTON USA 32 53 55 N 80 2 25 W 14 32.899 -80.04 CIC KCIC CHICO MUNI CHICO USA 39 47 43 N 121 51 30 W 73 39.795 -121.858 CLE KCLE CLEVELAND HOPKINS INTERNATIONAL CLEVELAND USA 41 24 42 N 81 50 59 W 242 41.412 -81.85 CLL KCLL EASTERWOOD FLD COLLEGE STATION USA 30 35 18 N 96 21 49 W 98 30.588 -96.364 CLT KCLT CHARLOTTE DOUGLAS INTERNATIONAL CHARLOTTE USA 35 12 50 N 80 56 35 W 229 35.214 -80.943 CMH KCMH PORT COLUMBUS INTERNATIONAL COLUMBUS USA 39 59 52 N 82 53 30 W 249 39.998 -82.892 CNM KCNM CAVERN CITY AIR TERMINAL CARLSBAD USA 32 20 14 N 104 15 47 W 1005 32.337 -104.263 COS KCOS CITY OF COLORADO SPRINGS MUNI COLORADO SPRINGS USA 38 48 20 N 104 42 0 W 1885 38.806 -104.7 COU KCOU COLUMBIA RGNL COLUMBIA USA 38 49 5 N 92 13 10 W 271 38.818 -92.219 CPR KCPR NATRONA CO INTERNATIONAL CASPER USA 42 54 28 N 106 27 51 W 1631 42.908 -106.464 CRP KCRP CORPUS CHRISTI INTERNATIONAL CORPUS CHRISTI USA 27 46 13 N 97 30 4 W 14 27.77 -97.501 CVG KCVG CINCINNATI NORTHERN KENTUCKY INTERNATIONAL CINCINNATI USA 39 2 46 N 84 39 43 W 274 39.046 -84.662 CVS KCVS CANNON AFB CLOVIS USA 34 22 57 N 103 19 19 W 1310 34.383 -103.322 CYS KCYS CHEYENNE CHEYENNE USA 41 9 20 N 104 48 42 W 1877 41.156 -104.812 DAL KDAL DALLAS LOVE FLD DALLAS USA 32 50 49 N 96 51 6 W 149 32.847 -96.852 DAY KDAY JAMES M COX DAYTON INTERNATIONAL DAYTON USA 39 54 8 N 84 13 9 W 308 39.902 -84.219 DCA KDCA RONALD REAGAN WASHINGTON NATIONAL WASHINGTON USA 38 51 7 N 77 2 15 W 5 38.852 -77.037 DEN KDEN DENVER INTERNATIONAL DENVER USA 39 51 30 N 104 40 1 W 1656 39.858 -104.667 DET KDET DETROIT CITY DETROIT USA 42 24 33 N 83 0 35 W 191 42.409 -83.01 DFW KDFW DALLAS FORT WORTH INTERNATIONAL DALLAS-FORT WORTH USA 32 53 47 N 97 2 15 W 184 32.896 -97.037 DHN KDHN DOTHAN RGNL DOTHAN USA 31 19 16 N 85 26 58 W 123 31.321 -85.449 DLH KDLH DULUTH INTERNATIONAL DULUTH USA 46 50 31 N 92 11 37 W 436 46.842 -92.194 DMA KDMA DAVIS MONTHAN AFB TUCSON USA 32 9 59 N 110 52 59 W 825 32.166 -110.883 DOV KDOV DOVER AFB DOVER USA 39 7 48 N 75 27 59 W 10 39.13 -75.466 DPA KDPA DU PAGE WEST CHICAGO USA 41 54 28 N 88 14 55 W 232 41.908 -88.249 DRO KDRO DURANGO LA PLATA CO DURANGO USA 37 9 5 N 107 45 13 W 2038 37.151 -107.754 DRT KDRT DEL RIO INTERNATIONAL DEL RIO USA 29 22 22 N 100 55 33 W 305 29.373 -100.926 DSM KDSM DES MOINES INTERNATIONAL DES MOINES USA 41 32 2 N 93 39 45 W 292 41.534 -93.663 DTW KDTW DETROIT METRO WAYNE CO DETROIT USA 42 12 44 N 83 21 12 W 197 42.212 -83.353 EDW KEDW EDWARDS AFB EDWARDS AFB USA 34 54 19 N 117 53 1 W 702 34.905 -117.884 EFD KEFD ELLINGTON FLD HOUSTON USA 29 36 26 N 95 9 31 W 10 29.607 -95.159 ELD KELD SOUTH ARKANSAS RGNL AT GOODWIN FLD EL DORADO USA 33 13 15 N 92 48 47 W 85 33.221 -92.813 ELP KELP EL PASO INTERNATIONAL EL PASO USA 31 48 24 N 106 22 40 W 1207 31.807 -106.378 ENV KENV WENDOVER WENDOVER USA 40 43 7 N 114 1 51 W 1291 40.719 -114.031 EWN KEWN CRAVEN CO RGNL NEW BERN USA 35 4 22 N 77 2 34 W 6 35.073 -77.043 EWR KEWR NEWARK LIBERTY INTERNATIONAL NEWARK USA 40 41 32 N 74 10 7 W 6 40.692 -74.169 EYW KEYW KEY WEST INTERNATIONAL KEY WEST USA 24 33 22 N 81 45 34 W 1 24.556 -81.759 FAT KFAT FRESNO YOSEMITE INTERNATIONAL FRESNO USA 36 46 34 N 119 43 5 W 103 36.776 -119.718 FFO KFFO WRIGHT PATTERSON AFB DAYTON USA 39 49 34 N 84 2 54 W 251 39.826 -84.048 FLL KFLL FORT LAUDERDALE HOLLYWOOD INTERNATIONAL FORT LAUDERDALE USA 26 4 21 N 80 9 9 W 3 26.072 -80.153 FLO KFLO FLORENCE RGNL FLORENCE USA 34 11 7 N 79 43 26 W 45 34.185 -79.724 FMH KFMH OTIS ANGB FALMOUTH USA 41 39 30 N 70 31 17 W 40 41.658 -70.521 FMN KFMN FOUR CORNERS RGNL FARMINGTON USA 36 44 28 N 108 13 47 W 1679 36.741 -108.23 FMY KFMY PAGE FLD FORT MYERS USA 26 35 11 N 81 51 47 W 6 26.586 -81.863 FOD KFOD FORT DODGE RGNL FORT DODGE USA 42 33 5 N 94 11 33 W 353 42.551 -94.193 FOE KFOE FORBES FLD TOPEKA USA 38 57 3 N 95 39 49 W 329 38.951 -95.664 FOK KFOK THE FRANCIS S GABRESKI WEST HAMPTON BEACH USA 40 50 37 N 72 37 54 W 21 40.844 -72.632 FSI KFSI HENRY POST AAF FORT SILL USA 34 38 59 N 98 24 7 W 363 34.65 -98.402 FSM KFSM FORT SMITH RGNL FORT SMITH USA 35 20 11 N 94 22 2 W 143 35.336 -94.367 FTW KFTW FORT WORTH MEACHAM INTERNATIONAL FORT WORTH USA 32 49 11 N 97 21 44 W 217 32.82 -97.362 FXE KFXE FORT LAUDERDALE EXECUTIVE FORT LAUDERDALE USA 26 11 50 N 80 10 14 W 5 26.197 -80.171 FYV KFYV DRAKE FLD FAYETTEVILLE USA 36 0 18 N 94 10 12 W 382 36.005 -94.17 GCK KGCK GARDEN CITY RGNL GARDEN CITY USA 37 55 39 N 100 43 27 W 881 37.927 -100.724 GEG KGEG SPOKANE INTERNATIONAL SPOKANE USA 47 37 11 N 117 32 1 W 723 47.62 -117.534 GFK KGFK GRAND FORKS INTERNATIONAL GRAND FORKS USA 47 56 57 N 97 10 34 W 258 47.949 -97.176 GGG KGGG EAST TEXAS RGNL LONGVIEW USA 32 23 5 N 94 42 41 W 112 32.385 -94.711 GNV KGNV GAINESVILLE RGNL GAINESVILLE USA 29 41 24 N 82 16 18 W 47 29.69 -82.272 GRB KGRB AUSTIN STRAUBEL INTERNATIONAL GREEN BAY USA 44 29 6 N 88 7 46 W 212 44.485 -88.129 GRF KGRF GRAY AAF FORT LEWIS USA 47 4 45 N 122 34 50 W 93 47.079 -122.581 GRK KGRK ROBERT GRAY AAF KILLEEN USA 31 4 2 N 97 49 44 W 311 31.067 -97.829 GRR KGRR GERALD R FORD INTERNATIONAL GRAND RAPIDS USA 42 52 51 N 85 31 22 W 242 42.881 -85.523 GSB KGSB SEYMOUR JOHNSON AFB GOLDSBORO USA 35 20 21 N 77 57 38 W 34 35.339 -77.961 GTF KGTF GREAT FALLS INTERNATIONAL GREAT FALLS USA 47 28 55 N 111 22 14 W 1121 47.482 -111.371 GUS KGUS GRISSOM ARB PERU USA 40 38 53 N 86 9 7 W 248 40.648 -86.152 GVT KGVT MAJORS GREENVILE USA 33 4 4 N 96 3 55 W 164 33.068 -96.065 HFD KHFD HARTFORD BRAINARD HARTFORD USA 41 44 10 N 72 39 0 W 6 41.736 -72.65 HIB KHIB CHISHOLM HIBBING HIBBING USA 47 23 11 N 92 50 20 W 413 47.386 -92.839 HKY KHKY HICKORY RGNL HICKORY USA 35 44 28 N 81 23 22 W 363 35.741 -81.389 HLN KHLN HELENA RGNL HELENA USA 46 36 24 N 111 58 57 W 1182 46.607 -111.983 HMN KHMN HOLLOMAN AFB ALAMOGORDO USA 32 51 9 N 106 6 23 W 1248 32.852 -106.106 HOB KHOB LEA CO RGNL HOBBS USA 32 41 15 N 103 13 1 W 1116 32.688 -103.217 HON KHON HURON RGNL HURON USA 44 23 6 N 98 13 42 W 393 44.385 -98.228 HOP KHOP CAMPBELL AAF HOPKINSVILLE USA 36 40 6 N 87 29 46 W 175 36.668 -87.496 HOU KHOU WILLIAM P HOBBY HOUSTON USA 29 38 43 N 95 16 44 W 15 29.645 -95.279 HPN KHPN WESTCHESTER CO WHITE PLAINS USA 41 4 1 N 73 42 27 W 134 41.067 -73.707 HRL KHRL VALLEY INTERNATIONAL HARLINGEN USA 26 13 42 N 97 39 15 W 11 26.228 -97.654 HRO KHRO BOONE CO HARRISON USA 36 15 41 N 93 9 17 W 417 36.261 -93.155 HUF KHUF TERRE HAUTE INTERNATIONAL HULMAN FLD TERRE HAUTE USA 39 27 5 N 87 18 27 W 180 39.451 -87.307 HVR KHVR HAVRE CITY CO HAVRE USA 48 32 34 N 109 45 44 W 790 48.543 -109.762 IAB KIAB MC CONNELL AFB WICHITA USA 37 37 22 N 97 16 2 W 418 37.623 -97.267 IAD KIAD WASHINGTON DULLES INTERNATIONAL WASHINGTON USA 38 56 40 N 77 27 20 W 96 38.944 -77.456 IAG KIAG NIAGARA FALLS INTERNATIONAL NIAGARA FALLS USA 43 6 26 N 78 56 46 W 180 43.107 -78.946 IAH KIAH GEORGE BUSH INTCNTL HOUSTON HOUSTON USA 29 58 49 N 95 20 23 W 30 29.98 -95.34 ICT KICT WICHITA MID CONTINENT WICHITA USA 37 38 59 N 97 25 59 W 407 37.65 -97.433 ILG KILG NEW CASTLE CO WILMINGTON USA 39 40 43 N 75 36 23 W 25 39.679 -75.606 ILM KILM WILMINGTON INTERNATIONAL WILMINGTON USA 34 16 14 N 77 54 9 W 10 34.271 -77.903 IND KIND INDIANAPOLIS INTERNATIONAL INDIANAPOLIS USA 39 43 2 N 86 17 39 W 243 39.717 -86.294 INL KINL FALLS INTERNATIONAL INTERNATIONAL FALLS USA 48 33 58 N 93 24 11 W 362 48.566 -93.403 INT KINT SMITH REYNOLDS WINSTON-SALEM USA 36 8 1 N 80 13 19 W 296 36.134 -80.222 IPL KIPL IMPERIAL CO IMPERIAL USA 32 50 3 N 115 34 43 W -17 32.834 -115.579 IPT KIPT WILLIAMSPORT RGNL WILLIAMSPORT USA 41 14 31 N 76 55 16 W 162 41.242 -76.921 ISN KISN SLOULIN FLD INTERNATIONAL WILLISTON USA 48 10 40 N 103 38 32 W 605 48.178 -103.642 ISP KISP LONG ISLAND MAC ARTHUR ISLIP USA 40 47 42 N 73 6 0 W 31 40.795 -73.1 JAN KJAN JACKSON INTERNATIONAL JACKSON USA 32 18 40 N 90 4 33 W 106 32.311 -90.076 JAX KJAX JACKSONVILLE INTERNATIONAL JACKSONVILLE USA 30 29 38 N 81 41 16 W 10 30.494 -81.688 JBR KJBR JONESBORO MUNI JONESBORO USA 35 49 54 N 90 38 46 W 80 35.832 -90.646 JFK KJFK JOHN F KENNEDY INTERNATIONAL NEW YORK USA 40 38 23 N 73 46 44 W 4 40.64 -73.779 LAN KLAN CAPITAL CITY LANSING USA 42 46 43 N 84 35 14 W 263 42.779 -84.587 LAS KLAS MC CARRAN INTERNATIONAL LAS VEGAS USA 36 4 49 N 115 9 8 W 665 36.08 -115.152 LAX KLAX LOS ANGELES INTERNATIONAL LOS ANGELES USA 33 56 33 N 118 24 29 W 39 33.942 -118.408 LBB KLBB LUBBOCK INTERNATIONAL LUBBOCK USA 33 39 49 N 101 49 22 W 1001 33.664 -101.823 LCH KLCH LAKE CHARLES RGNL LAKE CHARLES USA 30 7 34 N 93 13 24 W 5 30.126 -93.223 LCK KLCK RICKENBACKER INTERNATIONAL COLUMBUS USA 39 48 49 N 82 55 40 W 227 39.814 -82.928 LFI KLFI LANGLEY AFB HAMPTON USA 37 4 58 N 76 21 37 W 4 37.083 -76.36 LFT KLFT LAFAYETTE RGNL LAFAYETTE USA 30 12 19 N 91 59 15 W 13 30.205 -91.987 LGA KLGA LA GUARDIA NEW YORK USA 40 46 38 N 73 52 21 W 7 40.777 -73.872 LGB KLGB LONG BEACH LONG BEACH USA 33 49 3 N 118 9 5 W 19 33.818 -118.151 LIT KLIT ADAMS FLD LITTLE ROCK USA 34 43 46 N 92 13 27 W 80 34.729 -92.224 LNK KLNK LINCOLN MUNI LINCOLN USA 40 51 3 N 96 45 33 W 372 40.851 -96.759 LRD KLRD LAREDO INTERNATIONAL LAREDO USA 27 32 37 N 99 27 41 W 155 27.544 -99.461 LSF KLSF LAWSON AAF FORT BENNING USA 32 20 14 N 84 59 28 W 71 32.337 -84.991 LSV KLSV NELLIS AFB LAS VEGAS USA 36 14 10 N 115 2 3 W 570 36.236 -115.034 LUK KLUK CINCINNATI MUNI LUNKEN FLD CINCINNATI USA 39 6 12 N 84 25 7 W 148 39.103 -84.419 MAF KMAF MIDLAND INTERNATIONAL MIDLAND USA 31 56 33 N 102 12 6 W 876 31.942 -102.202 MCC KMCC MC CLELLAN AFLD SACRAMENTO USA 38 40 3 N 121 24 2 W 23 38.667 -121.401 MCF KMCF MACDILL AFB TAMPA USA 27 50 57 N 82 31 16 W 5 27.849 -82.521 MCI KMCI KANSAS CITY INTERNATIONAL KANSAS CITY USA 39 17 51 N 94 42 50 W 313 39.297 -94.714 MCN KMCN MIDDLE GEORGIA RGNL MACON USA 32 41 34 N 83 38 57 W 108 32.693 -83.649 MCO KMCO ORLANDO INTERNATIONAL ORLANDO USA 28 25 44 N 81 18 57 W 30 28.429 -81.316 MDT KMDT HARRISBURG INTERNATIONAL HARRISBURG USA 40 11 36 N 76 45 48 W 95 40.193 -76.763 MDW KMDW CHICAGO MIDWAY INTERNATIONAL CHICAGO USA 41 47 9 N 87 45 8 W 189 41.786 -87.752 MEM KMEM MEMPHIS INTERNATIONAL MEMPHIS USA 35 2 32 N 89 58 36 W 104 35.042 -89.977 MER KMER CASTLE MERCED USA 37 22 49 N 120 34 5 W 58 37.38 -120.568 MFE KMFE MC ALLEN MILLER INTERNATIONAL MCALLEN USA 26 10 33 N 98 14 19 W 33 26.176 -98.239 MHR KMHR SACRAMENTO MATHER SACRAMENTO USA 38 33 14 N 121 17 51 W 30 38.554 -121.297 MIA KMIA MIAMI INTERNATIONAL MIAMI USA 25 47 35 N 80 17 26 W 3 25.793 -80.291 MIB KMIB MINOT AFB MINOT USA 48 24 56 N 101 21 27 W 509 48.416 -101.357 MKE KMKE GENERAL MITCHELL INTERNATIONAL MILWAUKEE USA 42 56 50 N 87 53 47 W 221 42.947 -87.896 MKL KMKL MC KELLAR SIPES RGNL JACKSON USA 35 35 59 N 88 54 56 W 133 35.6 -88.916 MLB KMLB MELBOURNE INTERNATIONAL MELBOURNE USA 28 6 9 N 80 38 42 W 11 28.103 -80.645 MLU KMLU MONROE RGNL MONROE USA 32 30 39 N 92 2 15 W 25 32.511 -92.037 MOB KMOB MOBILE RGNL MOBILE USA 30 41 29 N 88 14 34 W 67 30.691 -88.243 MOD KMOD MODESTO CITY CO HARRY SHAM MODESTO USA 37 37 32 N 120 57 15 W 30 37.626 -120.954 MOT KMOT MINOT INTERNATIONAL MINOT USA 48 15 33 N 101 16 49 W 519 48.259 -101.28 MQT KMQT SAWYER INTERNATIONAL MARQUETTE USA 46 32 2 N 87 33 42 W 433 46.534 -87.562 MSN KMSN DANE CO RGNL TRUAX FLD MADISON USA 43 8 23 N 89 20 15 W 271 43.14 -89.337 MSP KMSP MINNEAPOLIS ST PAUL INTERNATIONAL MINNEAPOLIS USA 44 52 49 N 93 13 0 W 257 44.88 -93.217 MSS KMSS MASSENA INTERNATIONAL RICHARDS FLD MASSENA USA 44 56 9 N 74 50 43 W 66 44.936 -74.845 MSY KMSY LOUIS ARMSTRONG NEW ORLEANS INTERNATIONAL NEW ORLEANS USA 29 59 36 N 90 15 28 W 2 29.993 -90.258 MWH KMWH GRANT CO INTERNATIONAL GRANT COUNTY AIRPORT USA 47 12 27 N 119 19 12 W 362 47.208 -119.32 MXF KMXF MAXWELL AFB MONTGOMERY USA 32 22 45 N 86 21 45 W 53 32.379 -86.362 MYR KMYR MYRTLE BEACH INTERNATIONAL MYRTLE BEACH USA 33 40 47 N 78 55 42 W 8 33.68 -78.928 NBG KNBG NEW ORLEANS NAS JRB NEW ORLEANS USA 29 49 31 N 90 2 6 W 1 29.825 -90.035 NGU KNGU NORFOLK NS NORFOLK USA 36 56 15 N 76 17 21 W 5 36.938 -76.289 NIP KNIP JACKSONVILLE NAS JACKSONVILLE USA 30 14 9 N 81 40 50 W 7 30.236 -81.681 NJK KNJK EL CENTRO NAF EL CENTRO USA 32 49 45 N 115 40 18 W -13 32.829 -115.672 NKX KNKX MIRAMAR MCAS MIRAMAR USA 32 52 6 N 117 8 33 W 146 32.868 -117.143 NPA KNPA PENSACOLA NAS PENSACOLA USA 30 21 9 N 87 19 7 W 9 30.353 -87.319 NQA KNQA MILLINGTON MUNI MILLINGTON USA 35 21 24 N 89 52 13 W 98 35.357 -89.87 NQX KNQX KEY WEST NAS KEY WEST USA 24 34 33 N 81 41 20 W 2 24.576 -81.689 NTD KNTD POINT MUGU NAS POINT MUGU USA 34 7 13 N 119 7 15 W 4 34.12 -119.121 NTU KNTU OCEANA NAS OCEANA USA 36 49 14 N 76 2 0 W 7 36.821 -76.033 NUQ KNUQ MOFFETT FEDERAL AFLD MOUNTAIN VIEW USA 37 24 54 N 122 2 53 W 10 37.415 -122.048 NUW KNUW WHIDBEY ISLAND NAS WHIDBEY ISLAND USA 48 21 6 N 122 39 21 W 15 48.352 -122.656 NZC KNZC CECIL FLD JACKSONVILLE USA 30 13 7 N 81 52 35 W 25 30.219 -81.876 NZY KNZY NORTH ISLAND NAS SAN DIEGO USA 32 41 57 N 117 12 55 W 8 32.699 -117.215 OAK KOAK METROPOLITAN OAKLAND INTERNATIONAL OAKLAND USA 37 43 16 N 122 13 14 W 2 37.721 -122.221 OFF KOFF OFFUTT AFB OMAHA USA 41 7 6 N 95 54 45 W 321 41.118 -95.913 OGS KOGS OGDENSBURG INTERNATIONAL OGDENSBURG USA 44 40 55 N 75 27 56 W 91 44.682 -75.466 OKC KOKC WILL ROGERS WORLD OKLAHOMA CITY USA 35 23 35 N 97 36 2 W 395 35.393 -97.601 OMA KOMA EPPLEY AFLD OMAHA USA 41 18 9 N 95 53 37 W 300 41.302 -95.894 ONT KONT ONTARIO INTERNATIONAL ONTARIO USA 34 3 21 N 117 36 4 W 288 34.056 -117.601 OPF KOPF OPA LOCKA MIAMI USA 25 54 25 N 80 16 42 W 3 25.907 -80.278 ORD KORD CHICAGO OHARE INTERNATIONAL CHICAGO USA 41 58 46 N 87 54 16 W 204 41.979 -87.904 ORF KORF NORFOLK INTERNATIONAL NORFOLK USA 36 53 40 N 76 12 4 W 8 36.894 -76.201 ORL KORL EXECUTIVE ORLANDO USA 28 32 43 N 81 19 58 W 35 28.545 -81.333 PAE KPAE SNOHOMISH CO EVERETT USA 47 54 22 N 122 16 53 W 185 47.906 -122.281 PAM KPAM TYNDALL AFB PANAMA CITY USA 30 4 11 N 85 34 35 W 6 30.07 -85.576 PBG KPBG PLATTSBURGH INTERNATIONAL PLATTSBURGH USA 44 39 3 N 73 28 5 W 72 44.651 -73.468 PBI KPBI PALM BEACH INTERNATIONAL WEST PALM BEACH USA 26 40 59 N 80 5 44 W 6 26.683 -80.096 PDX KPDX PORTLAND INTERNATIONAL PORTLAND USA 45 35 19 N 122 35 51 W 10 45.589 -122.597 PHF KPHF NEWPORT NEWS WILLIAMSBURG INTERNATIONAL NEWPORT NEWS USA 37 7 54 N 76 29 34 W 14 37.132 -76.493 PHL KPHL PHILADELPHIA INTERNATIONAL PHILADELPHIA USA 39 52 19 N 75 14 28 W 12 39.872 -75.241 PHN KPHN ST CLAIR CO INTERNATIONAL PORT HURON USA 42 54 39 N 82 31 43 W 199 42.911 -82.529 PHX KPHX PHOENIX SKY HARBOR INTERNATIONAL PHOENIX USA 33 26 3 N 112 0 29 W 346 33.434 -112.008 PIE KPIE ST PETERSBURG CLEARWATER INTERNATIONAL ST. PETERSBURG USA 27 54 38 N 82 41 14 W 4 27.911 -82.687 PIT KPIT PITTSBURGH INTERNATIONAL PITTSBURGH (PENNSYLVA) USA 40 29 29 N 80 13 58 W 367 40.491 -80.233 PNE KPNE NORTHEAST PHILADELPHIA PHILADELPHIA USA 40 4 55 N 75 0 38 W 37 40.082 -75.011 PNS KPNS PENSACOLA RGNL PENSACOLA USA 30 28 23 N 87 11 14 W 37 30.473 -87.187 POB KPOB POPE AFB FAYETTEVILLE USA 35 10 15 N 79 0 52 W 67 35.171 -79.014 PQI KPQI NORTHERN MAINE RGNL AT PRESQUE ISLE PRESQUE ISLE USA 46 41 20 N 68 2 41 W 163 46.689 -68.045 PRC KPRC ERNEST A LOVE FLD PRESCOTT USA 34 39 16 N 112 25 10 W 1538 34.654 -112.419 PSP KPSP PALM SPRINGS INTERNATIONAL PALM SPRINGS USA 33 49 46 N 116 30 24 W 145 33.829 -116.507 PUB KPUB PUEBLO MEM PUEBLO MEMORIAL USA 38 17 20 N 104 29 47 W 1441 38.289 -104.496 PVD KPVD THEODORE FRANCIS GREEN STATE PROVIDENCE USA 41 43 26 N 71 25 41 W 17 41.724 -71.428 PWM KPWM PORTLAND INTERNATIONAL JETPORT PORTLAND USA 43 38 46 N 70 18 31 W 23 43.646 -70.309 RCA KRCA ELLSWORTH AFB RAPID CITY USA 44 8 42 N 103 6 12 W 1000 44.145 -103.103 RDU KRDU RALEIGH DURHAM INTERNATIONAL RALEIGH-DURHAM USA 35 52 39 N 78 47 14 W 133 35.877 -78.787 RIC KRIC RICHMOND INTERNATIONAL RICHMOND USA 37 30 18 N 77 19 10 W 51 37.505 -77.319 RIV KRIV MARCH ARB RIVERSIDE USA 33 52 50 N 117 15 34 W 468 33.881 -117.259 RME KRME GRIFFISS AIRPARK ROME USA 43 14 1 N 75 24 25 W 154 43.234 -75.407 RNO KRNO RENO TAHOE INTERNATIONAL RENO USA 39 29 54 N 119 46 5 W 1345 39.498 -119.768 ROC KROC GREATER ROCHESTER INTERNATIONAL ROCHESTER USA 43 7 7 N 77 40 20 W 171 43.119 -77.672 ROW KROW ROSWELL INDUSTRIAL AIR CENTER ROSWELL USA 33 18 5 N 104 31 50 W 1119 33.301 -104.531 RSW KRSW SOUTHWEST FLORIDA INTERNATIONAL FORT MYERS USA 26 32 10 N 81 45 18 W 10 26.536 -81.755 SAC KSAC SACRAMENTO EXECUTIVE SACRAMENTO USA 38 30 45 N 121 29 36 W 8 38.513 -121.493 SAF KSAF SANTA FE MUNI SANTA FE USA 35 37 0 N 106 5 17 W 1935 35.617 -106.088 SAN KSAN SAN DIEGO INTERNATIONAL LINDBERGH FLD SAN DIEGO USA 32 44 0 N 117 11 22 W 5 32.733 -117.189 SAT KSAT SAN ANTONIO INTERNATIONAL SAN ANTONIO USA 29 32 1 N 98 28 11 W 247 29.534 -98.47 SAV KSAV SAVANNAH HILTON HEAD INTERNATIONAL SAVANNAH USA 32 7 39 N 81 12 7 W 16 32.127 -81.202 SBY KSBY SALISBURY OCEAN CITY WICOMICO RGNL SALISBURY USA 38 20 25 N 75 30 37 W 16 38.34 -75.51 SCK KSCK STOCKTON METROPOLITAN STOCKTON USA 37 53 39 N 121 14 19 W 10 37.894 -121.239 SEA KSEA SEATTLE TACOMA INTERNATIONAL SEATTLE USA 47 26 56 N 122 18 33 W 131 47.449 -122.309 SFO KSFO SAN FRANCISCO INTERNATIONAL SAN FRANCISCO USA 37 37 8 N 122 22 29 W 4 37.619 -122.375 SFZ KSFZ NORTH CENTRAL STATE SMITHFIELD USA 41 55 14 N 71 29 28 W 135 41.921 -71.491 SHV KSHV SHREVEPORT RGNL SHREVEPORT USA 32 26 47 N 93 49 32 W 79 32.446 -93.826 SJC KSJC NORMAN Y MINETA SAN JOSE INTERNATIONAL SAN JOSE USA 37 21 42 N 121 55 44 W 18 37.362 -121.929 SJT KSJT SAN ANGELO RGNL MATHIS FLD SAN ANGELO USA 31 21 27 N 100 29 46 W 585 31.358 -100.496 SKF KSKF LACKLAND AFB KELLY FLD ANNEX SAN ANTONIO USA 29 23 3 N 98 34 51 W 211 29.384 -98.581 SLC KSLC SALT LAKE CITY INTERNATIONAL SALT LAKE CITY USA 40 47 18 N 111 58 39 W 1289 40.788 -111.978 SMF KSMF SACRAMENTO INTERNATIONAL SACRAMENTO USA 38 41 43 N 121 35 26 W 9 38.695 -121.591 SNA KSNA JOHN WAYNE ARPT ORANGE CO SANTA ANA USA 33 40 32 N 117 52 5 W 18 33.676 -117.868 SPB KSPB SCAPPOOSE INDUSTRIAL AIRPARK SAN LUIS USA 45 46 21 N 122 51 44 W 18 45.773 -122.862 SPS KSPS SHEPPARD AFB WICHITA FALLS MUNI WICHITA FALLS USA 33 59 19 N 98 29 30 W 311 33.989 -98.492 SSC KSSC SHAW AFB SUMTER USA 33 58 22 N 80 28 22 W 74 33.973 -80.473 STL KSTL LAMBERT ST LOUIS INTERNATIONAL ST. LOUIS USA 38 44 51 N 90 21 35 W 185 38.748 -90.36 SUU KSUU TRAVIS AFB FAIRFIELD USA 38 15 45 N 121 55 38 W 19 38.263 -121.927 SUX KSUX SIOUX GATEWAY COL BUD DAY FLD SIOUX CITY USA 42 24 9 N 96 23 3 W 335 42.402 -96.384 SVN KSVN HUNTER AAF HUNTER AAF USA 32 0 36 N 81 8 44 W 13 32.01 -81.146 SWF KSWF STEWART INTERNATIONAL NEWBURGH USA 41 30 14 N 74 6 17 W 150 41.504 -74.105 SYR KSYR SYRACUSE HANCOCK INTERNATIONAL SYRACUSE USA 43 6 40 N 76 6 22 W 129 43.111 -76.106 SZL KSZL WHITEMAN AFB KNOBNOSTER USA 38 43 49 N 93 32 52 W 266 38.73 -93.548 TBN KTBN WAYNESVILLE RGNL ARPT AT FORNEY FLD FORT LEONARDWOOD USA 37 44 29 N 92 8 26 W 354 37.741 -92.141 TEB KTEB TETERBORO TETERBORO USA 40 50 59 N 74 3 39 W 3 40.85 -74.061 TIK KTIK TINKER AFB OKLAHOMA CITY USA 35 24 53 N 97 23 11 W 394 35.415 -97.386 TLH KTLH TALLAHASSEE RGNL TALLAHASSEE USA 30 23 47 N 84 21 1 W 25 30.396 -84.35 TMB KTMB KENDALL TAMIAMI EXECUTIVE KENDALL-TAMIAMI USA 25 38 52 N 80 25 58 W 3 25.648 -80.433 TNT KTNT DADE COLLIER TRAINING AND TRANSITION MIAMI USA 25 51 42 N 80 53 49 W 4 25.862 -80.897 TPA KTPA TAMPA INTERNATIONAL TAMPA USA 27 58 31 N 82 31 59 W 8 27.975 -82.533 TTN KTTN TRENTON MERCER TRENTON USA 40 16 36 N 74 48 48 W 65 40.277 -74.813 TUL KTUL TULSA INTERNATIONAL TULSA USA 36 11 54 N 95 53 17 W 207 36.198 -95.888 TUS KTUS TUCSON INTERNATIONAL TUCSON USA 32 6 58 N 110 56 29 W 806 32.116 -110.941 TXK KTXK TEXARKANA RGNL WEBB FLD TEXARKANA USA 33 27 13 N 93 59 27 W 119 33.454 -93.991 TYR KTYR TYLER POUNDS RGNL TYLER USA 32 21 14 N 95 24 8 W 166 32.354 -95.402 TYS KTYS MC GHEE TYSON KNOXVILLE USA 35 48 44 N 83 59 34 W 300 35.812 -83.993 VAD KVAD MOODY AFB VALDOSTA USA 30 58 4 N 83 11 34 W 72 30.968 -83.193 VCV KVCV SOUTHERN CALIFORNIA LOGISTICS VICTORVILLE USA 34 35 35 N 117 22 46 W 880 34.593 -117.379 VPS KVPS EGLIN AFB VALPARAISO USA 30 28 59 N 86 31 31 W 27 30.483 -86.525 VRB KVRB VERO BEACH MUNI VERO BEACH USA 27 39 20 N 80 25 4 W 8 27.656 -80.418 WRB KWRB ROBINS AFB MACON USA 32 38 24 N 83 35 30 W 90 32.64 -83.592 WRI KWRI MC GUIRE AFB WRIGHTSTOWN USA 40 0 56 N 74 35 37 W 41 40.016 -74.594 WWD KWWD CAPE MAY CO WILDWOOD USA 39 0 30 N 74 54 29 W 8 39.008 -74.908 YIP KYIP WILLOW RUN DETROIT USA 42 14 16 N 83 31 49 W 219 42.238 -83.53 YNG KYNG YOUNGSTOWN WARREN RGNL YOUNGSTOWN USA 41 15 38 N 80 40 44 W 365 41.261 -80.679 YUM KYUM YUMA MCAS YUMA INTERNATIONAL YUMA USA 32 39 23 N 114 36 21 W 65 32.656 -114.606 PCA MMPC INGENIERO JUAN GUILLERMO VILLASANA PACHUCA MEXICO 20 4 38 N 98 46 56 W 2317 20.077 -98.782 PPG NSTU PAGO PAGO INTERNATIONAL PAGO PAGO SAMOA 14 19 51 S 170 42 37 W 10 -14.331 -170.71 PAQ PAAQ PALMER MUNI PALMER USA 61 35 41 N 149 5 19 W 76 61.595 -149.089 BTI PABA BARTER ISLAND LRRS BARTER ISLAND USA 70 8 2 N 143 34 37 W 2 70.134 -143.577 BET PABE BETHEL BETHEL USA 60 46 47 N 161 50 16 W 38 60.78 -161.838 BRW PABR WILEY POST WILL ROGERS MEM BARROW USA 71 17 7 N 156 45 57 W 14 71.285 -156.766 BTT PABT BETTLES BETTLES USA 66 54 55 N 151 31 41 W 196 66.915 -151.528 CDB PACD COLD BAY COLD BAY USA 55 12 20 N 162 43 27 W 30 55.206 -162.724 CDV PACV MERLE K MUDHOLE SMITH CORDOVA USA 60 29 30 N 145 28 39 W 13 60.492 -145.477 ADK PADK ADAK ADAK ISLAND USA 51 52 40 N 176 38 45 W 7 51.878 -176.646 DLG PADL DILLINGHAM DILLINGHAM USA 59 2 43 N 158 30 12 W 27 59.045 -158.503 ADQ PADQ KODIAK KODIAK USA 57 45 0 N 152 29 37 W 23 57.75 -152.494 DUT PADU UNALASKA UNALASKA USA 53 54 0 N 166 32 36 W 7 53.9 -166.543 EDF PAED ELMENDORF AFB ANCHORAGE USA 61 15 4 N 149 48 23 W 65 61.251 -149.806 EHM PAEH CAPE NEWENHAM LRRS CAPE NEWENHAM USA 58 38 50 N 162 3 38 W 165 58.647 -162.061 EIL PAEI EIELSON AFB FAIRBANKS USA 64 39 56 N 147 6 5 W 168 64.666 -147.101 ENA PAEN KENAI MUNI KENAI USA 60 34 23 N 151 14 42 W 31 60.573 -151.245 FAI PAFA FAIRBANKS INTERNATIONAL FAIRBANKS USA 64 48 54 N 147 51 22 W 133 64.815 -147.856 FBK PAFB WAINWRIGHT AAF FORT WAINWRIGHT USA 64 50 15 N 147 36 52 W 139 64.837 -147.614 GAL PAGA EDWARD G PITKA SR GALENA USA 64 44 10 N 156 56 14 W 47 64.736 -156.937 GKN PAGK GULKANA GULKANA USA 62 9 17 N 145 27 23 W 482 62.155 -145.456 SGY PAGY SKAGWAY SKAGWAY USA 59 27 36 N 135 18 56 W 14 59.46 -135.316 HOM PAHO HOMER HOMER USA 59 38 44 N 151 28 35 W 26 59.646 -151.476 ILI PAIL ILIAMNA ILIAMNA USA 59 45 13 N 154 54 39 W 57 59.754 -154.911 UTO PAIM INDIAN MOUNTAIN LRRS INDIAN MOUNTAINS USA 65 59 34 N 153 42 15 W 372 65.993 -153.704 JNU PAJN JUNEAU INTERNATIONAL JUNEAU USA 58 21 17 N 134 34 34 W 6 58.355 -134.576 AKN PAKN KING SALMON KING SALMON USA 58 40 36 N 156 38 57 W 18 58.677 -156.649 KTN PAKT KETCHIKAN INTERNATIONAL KETCHIKAN USA 55 21 20 N 131 42 49 W 30 55.356 -131.714 LUR PALU CAPE LISBURNE LRRS CAPE LISBURNE USA 68 52 30 N 166 6 36 W 4 68.875 -166.11 MCG PAMC MC GRATH MCGRATH USA 62 57 10 N 155 36 20 W 103 62.953 -155.606 MRI PAMR MERRILL FLD ANCHORAGE USA 61 12 51 N 149 50 46 W 42 61.214 -149.846 ANC PANC TED STEVENS ANCHORAGE INTERNATIONAL ANCHORAGE USA 61 10 27 N 149 59 46 W 47 61.174 -149.996 OME PAOM NOME NOME USA 64 30 43 N 165 26 42 W 12 64.512 -165.445 ORT PAOR NORTHWAY NORTHWAY USA 62 57 40 N 141 55 44 W 524 62.961 -141.929 OTZ PAOT RALPH WIEN MEM KOTZEBUE USA 66 53 4 N 162 35 54 W 4 66.884 -162.598 PML PAPM PLATINUM PORT MOLLER USA 59 0 40 N 161 49 10 W 5 59.011 -161.819 SCC PASC DEADHORSE DEADHORSE USA 70 11 41 N 148 27 54 W 19 70.195 -148.465 SIT PASI SITKA ROCKY GUTIERREZ SITKA USA 57 2 49 N 135 21 41 W 8 57.047 -135.361 SNP PASN ST PAUL ISLAND ST. PAUL ISLAND USA 57 10 2 N 170 13 13 W 20 57.167 -170.22 SVW PASV SPARREVOHN LRRS SPARREVOHN USA 61 5 50 N 155 34 27 W 484 61.097 -155.574 SYA PASY EARECKSON AS SHEMYA USA 52 42 44 N 174 6 49 E 30 52.712 174.114 TAL PATA RALPH M CALHOUN TANANA USA 65 10 27 N 152 6 33 W 70 65.174 -152.109 TNC PATC TIN CITY LRRS TIN CITY USA 65 33 47 N 167 55 20 W 83 65.563 -167.922 TKA PATK TALKEETNA TALKEETNA USA 62 19 13 N 150 5 37 W 110 62.32 -150.094 TLJ PATL TATALINA LRRS TATALINA USA 62 53 39 N 155 58 35 W 294 62.894 -155.976 UNK PAUN UNALAKLEET UNALAKLEET USA 63 53 18 N 160 47 56 W 7 63.888 -160.799 VDZ PAVD VALDEZ PIONEER FIELD VALDEZ USA 61 8 2 N 146 14 54 W 37 61.134 -146.248 AIN PAWT WAINWRIGHT AS FORT WAINWRIGHT USA 70 36 48 N 159 51 37 W 11 70.613 -159.86 YAK PAYA YAKUTAT YAKUTAT USA 59 30 11 N 139 39 36 W 12 59.503 -139.66 FYU PFYU FORT YUKON FORT YUKON USA 66 34 17 N 145 15 1 W 132 66.571 -145.25 ROP PGRO ROTA INTERNATIONAL ROTA MARIANA ISLANDS 14 10 28 N 145 14 36 E 186 14.174 145.243 SPN PGSN SAIPAN INTERNATIONAL SAIPAN MARIANA ISLANDS 15 7 10 N 145 43 45 E 66 15.119 145.729 UAM PGUA ANDERSEN AFB ANDERSEN MARIANA ISLANDS 13 35 2 N 144 55 48 E 192 13.584 144.93 GUM PGUM GUAM INTERNATIONAL AGANA MARIANA ISLANDS 13 29 2 N 144 47 49 E 91 13.484 144.797 HNM PHHN HANA HANA USA 20 47 44 N 156 0 51 W 24 20.796 -156.014 JHM PHJH KAPALUA LAHANIA-KAPALUA USA 20 57 46 N 156 40 27 W 79 20.963 -156.674 KOA PHKO KONA INTERNATIONAL AT KEAHOLE KONA USA 19 44 19 N 156 2 44 W 15 19.739 -156.046 LIH PHLI LIHUE LIHUE USA 21 58 34 N 159 20 19 W 47 21.976 -159.339 MKK PHMK MOLOKAI MOLOKAI USA 21 9 10 N 157 5 46 W 139 21.153 -157.096 MUE PHMU WAIMEA KOHALA KAMUELA USA 20 0 4 N 155 40 5 W 815 20.001 -155.668 NGF PHNG KANEOHE BAY MCAF KANEOHE BAY USA 21 26 57 N 157 46 4 W 6 21.449 -157.768 HNL PHNL HONOLULU INTERNATIONAL HONOLULU USA 21 18 57 N 157 55 36 W 4 21.316 -157.927 LNY PHNY LANAI LANAI USA 20 47 8 N 156 57 5 W 399 20.786 -156.951 OGG PHOG KAHULUI KAHULUI USA 20 53 55 N 156 25 50 W 17 20.899 -156.431 ITO PHTO HILO INTERNATIONAL HILO USA 19 43 13 N 155 2 55 W 12 19.72 -155.049 PIZ PPIZ POINT LAY LRRS POINT LAY USA 69 43 58 N 163 0 19 W 8 69.733 -163.005 STT TIST CYRIL E KING ST. THOMAS VIRGIN ISL. 18 20 14 N 64 58 24 W 8 18.337 -64.973 STX TISX HENRY E ROHLSEN ST. CRIOX ISLAND VIRGIN ISL. 17 42 6 N 64 47 54 W 20 17.702 -64.798 BQN TJBQ RAFAEL HERNANDEZ AGUADILLA PUERTO RICO 18 29 41 N 67 7 46 W 73 18.495 -67.129 SIG TJIG FERNANDO LUIS RIBAS DOMINICCI SAN JUAN PUERTO RICO 18 27 24 N 66 5 53 W 4 18.457 -66.098 MAZ TJMZ EUGENIO MARIA DE HOSTOS MAYAGUEZ PUERTO RICO 18 15 20 N 67 8 54 W 9 18.256 -67.148 PSE TJPS MERCEDITA PONCE PUERTO RICO 18 0 29 N 66 33 46 W 8 18.008 -66.563 SJU TJSJ LUIS MUNOZ MARIN INTERNATIONAL SAN JUAN PUERTO RICO 18 26 21 N 66 0 6 W 3 18.439 -66.002 # Annotate graph with latitude and longitude no_gps = [] for n , d in pass_2015_network . nodes ( data = True ): try : pass_2015_network . nodes [ n ][ \"longitude\" ] = us_airports . loc [ n , \"LONGITUDE\" ] pass_2015_network . nodes [ n ][ \"latitude\" ] = us_airports . loc [ n , \"LATITUDE\" ] pass_2015_network . nodes [ n ][ \"degree\" ] = pass_2015_network . degree ( n ) # Some of the nodes are not represented except KeyError : no_gps . append ( n ) # Get subgraph of nodes that do have GPS coords has_gps = set ( pass_2015_network . nodes ()) . difference ( no_gps ) g = pass_2015_network . subgraph ( has_gps ) Let's first plot only the nodes, i.e airports. Places like Guam, US Virgin Islands are also included in this dataset as they are treated as domestic airports in this dataset. import nxviz as nv from nxviz import nodes , plots , edges plt . figure ( figsize = ( 20 , 9 )) pos = nodes . geo ( g , aesthetics_kwargs = { \"size_scale\" : 1 }) plots . aspect_equal () plots . despine () /home/runner/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.0 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.6.3, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( Let's also plot the routes(edges). import nxviz as nv from nxviz import nodes , plots , edges , annotate plt . figure ( figsize = ( 20 , 9 )) pos = nodes . geo ( g , color_by = \"degree\" , aesthetics_kwargs = { \"size_scale\" : 1 }) edges . line ( g , pos , aesthetics_kwargs = { \"alpha_scale\" : 0.1 }) annotate . node_colormapping ( g , color_by = \"degree\" ) plots . aspect_equal () plots . despine () Before we proceed further, let's take a detour to briefly discuss directed networks and PageRank.","title":"Visualise the airports"},{"location":"05-casestudies/02-airport/#directed-graphs-and-pagerank","text":"The figure below explains the basic idea behind the PageRank algorithm. The \"importance\" of the node depends on the incoming links to the node, i.e if an \"important\" node A points towards a node B it will increase the PageRank score of node B, and this is run iteratively. In the given figure, even though node C is only connected to one node it is considered \"important\" as the connection is to node B, which is an \"important\" node. Source: Wikipedia To better understand this let's work through an example. # Create an empty directed graph object G = nx . DiGraph () # Add an edge from 1 to 2 with weight 4 G . add_edge ( 1 , 2 , weight = 4 ) print ( G . edges ( data = True )) [(1, 2, {'weight': 4})] # Access edge from 1 to 2 G [ 1 ][ 2 ] {'weight': 4} What happens when we try to access the edge from 2 to 1? G [ 2 ][ 1 ] --------------------------------------------------------------------------- KeyError Traceback ( most recent call last ) < ipython - input - 137 - d6b8db3142ef > in < module > 1 # Access edge from 2 to 1 ----> 2 G [ 2 ][ 1 ] ~/ miniconda3 / envs / nams / lib / python3 . 7 / site - packages / networkx / classes / coreviews . py in __getitem__ ( self , key ) 52 53 def __getitem__ ( self , key ): ---> 54 return self . _atlas [ key ] 55 56 def copy ( self ): KeyError : 1 As expected we get an error when we try to access the edge between 2 to 1 as this is a directed graph. G . add_edges_from ([( 1 , 2 ), ( 3 , 2 ), ( 4 , 2 ), ( 5 , 2 ), ( 6 , 2 ), ( 7 , 2 )]) # nx.draw_spring(G, with_labels=True) nv . circos ( G , node_aes_kwargs = { \"size_scale\" : 0.3 }) <AxesSubplot:> Just by looking at the example above, we can conclude that node 2 should have the highest PageRank score as all the nodes are pointing towards it. This is confirmed by calculating the PageRank of this graph. nx . pagerank ( G ) {1: 0.0826448180198328, 2: 0.5041310918810031, 3: 0.0826448180198328, 4: 0.0826448180198328, 5: 0.0826448180198328, 6: 0.0826448180198328, 7: 0.0826448180198328} What happens when we add an edge from node 5 to node 6. G . add_edge ( 5 , 6 ) nv . circos ( G , node_aes_kwargs = { \"size_scale\" : 0.3 }) # nx.draw_spring(G, with_labels=True) <AxesSubplot:> nx . pagerank ( G ) {1: 0.08024854052495894, 2: 0.4844028780560986, 3: 0.08024854052495894, 4: 0.08024854052495894, 5: 0.08024854052495894, 6: 0.11435441931910648, 7: 0.08024854052495894} As expected there was some change in the scores (an increase for 6) but the overall trend stays the same, with node 2 leading the pack. G . add_edge ( 2 , 8 ) nv . circos ( G , node_aes_kwargs = { \"size_scale\" : 0.3 }) <AxesSubplot:> Now we have an added an edge from 2 to a new node 8. As node 2 already has a high PageRank score, this should be passed on node 8. Let's see how much difference this can make. nx . pagerank ( G ) {1: 0.05378612718073915, 2: 0.3246687852772877, 3: 0.05378612718073915, 4: 0.05378612718073915, 5: 0.05378612718073915, 6: 0.0766454192258098, 7: 0.05378612718073915, 8: 0.3297551595932067} In this example, node 8 is now even more \"important\" than node 2 even though node 8 has only incoming connection. Let's move back to Airports and use this knowledge to analyse the network.","title":"Directed Graphs and PageRank"},{"location":"05-casestudies/02-airport/#importants-hubs-in-the-airport-network","text":"So let's have a look at the important nodes in this network, i.e. important airports in this network. We'll use centrality measures like pagerank, betweenness centrality and degree centrality which we gone through in this book. Let's try to calculate the PageRank of passenger_graph . nx . pagerank ( passenger_graph ) --------------------------------------------------------------------------- NetworkXNotImplemented Traceback ( most recent call last ) < ipython - input - 144 - 15 a6f513bf9b > in < module > 1 # Let's try to calulate the PageRank measures of this graph. ----> 2 nx . pagerank ( passenger_graph ) < decorator - gen - 435 > in pagerank ( G , alpha , personalization , max_iter , tol , nstart , weight , dangling ) ~/ miniconda3 / envs / nams / lib / python3 . 7 / site - packages / networkx / utils / decorators . py in _not_implemented_for ( not_implement_for_func , * args , ** kwargs ) 78 if match : 79 msg = 'not implemented for %s type' % ' ' . join ( graph_types ) ---> 80 raise nx . NetworkXNotImplemented ( msg ) 81 else : 82 return not_implement_for_func ( * args , ** kwargs ) NetworkXNotImplemented : not implemented for multigraph type As PageRank isn't defined for a MultiGraph in NetworkX we need to use our extracted yearly sub networks. # As pagerank will take weighted measure # by default we pass in None to make this # calculation for unweighted network PR_2015_scores = nx . pagerank ( pass_2015_network , weight = None ) # Let's check the PageRank score for JFK PR_2015_scores [ 'JFK' ] 0.0036376572979606586 # top 10 airports according to unweighted PageRank top_10_pr = sorted ( PR_2015_scores . items (), key = lambda x : x [ 1 ], reverse = True )[: 10 ] # top 10 airports according to unweighted betweenness centrality top_10_bc = sorted ( nx . betweenness_centrality ( pass_2015_network , weight = None ) . items (), key = lambda x : x [ 1 ], reverse = True )[ 0 : 10 ] # top 10 airports according to degree centrality top_10_dc = sorted ( nx . degree_centrality ( pass_2015_network ) . items (), key = lambda x : x [ 1 ], reverse = True )[ 0 : 10 ] Before looking at the results do think about what we just calculated and try to guess which airports should come out at the top and be ready to be surprised :D # PageRank top_10_pr [('ANC', 0.010425531156396332), ('HPN', 0.008715287139161587), ('FAI', 0.007865131822111036), ('DFW', 0.007168038232113773), ('DEN', 0.006557279519803018), ('ATL', 0.006367579588749718), ('ORD', 0.006178836107660135), ('YIP', 0.005821525504523931), ('ADQ', 0.005482597083474197), ('MSP', 0.005481962582230961)] # Betweenness Centrality top_10_bc [('ANC', 0.28907458480586606), ('FAI', 0.08042857784594384), ('SEA', 0.06745549919241699), ('HPN', 0.06046810178534726), ('ORD', 0.045544143864829294), ('ADQ', 0.040170160000905696), ('DEN', 0.038543251364241436), ('BFI', 0.03811277548952854), ('MSP', 0.03774809342340624), ('TEB', 0.036229439542316354)] # Degree Centrality top_10_dc [('ATL', 0.3643595863166269), ('ORD', 0.354813046937152), ('DFW', 0.3420843277645187), ('MSP', 0.3261734287987271), ('DEN', 0.31821797931583135), ('ANC', 0.3046937151949085), ('MEM', 0.29196499602227527), ('LAX', 0.2840095465393795), ('IAH', 0.28082736674622116), ('DTW', 0.27446300715990457)] The Degree Centrality results do make sense at first glance, ATL is Atlanta, ORD is Chicago, these are defintely airports one would expect to be at the top of a list which calculates \"importance\" of an airport. But when we look at PageRank and Betweenness Centrality we have an unexpected airport 'ANC'. Do think about measures like PageRank and Betweenness Centrality and what they calculate. Do note that currently we have used the core structure of the network, no other metadata like number of passengers. These are calculations on the unweighted network. 'ANC' is the airport code of Anchorage airport, a place in Alaska, and according to pagerank and betweenness centrality it is the most important airport in this network. Isn't that weird? Thoughts? Looks like 'ANC' is essential to the core structure of the network, as it is the main airport connecting Alaska with other parts of US. This explains the high Betweenness Centrality score and there are flights from other major airports to 'ANC' which explains the high PageRank score. Related blog post: https://toreopsahl.com/2011/08/12/why-anchorage-is-not-that-important-binary-ties-and-sample-selection/ Let's look at weighted version, i.e taking into account the number of people flying to these places. # Recall from the last chapter we use weight_inv # while calculating betweenness centrality sorted ( nx . betweenness_centrality ( pass_2015_network , weight = 'weight_inv' ) . items (), key = lambda x : x [ 1 ], reverse = True )[ 0 : 10 ] [('SEA', 0.4192179843829966), ('ATL', 0.3589665389741017), ('ANC', 0.32425767084369994), ('LAX', 0.2668567170342895), ('ORD', 0.10008664852621497), ('DEN', 0.0964658422388763), ('MSP', 0.09300021788810685), ('DFW', 0.0926644126226465), ('FAI', 0.08824779747216016), ('BOS', 0.08259764427486331)] sorted ( nx . pagerank ( pass_2015_network , weight = 'weight' ) . items (), key = lambda x : x [ 1 ], reverse = True )[ 0 : 10 ] [('ATL', 0.037535963029303135), ('ORD', 0.028329766122739346), ('SEA', 0.028274564067008245), ('ANC', 0.027127866647567035), ('DFW', 0.02570050418889442), ('DEN', 0.025260024346433315), ('LAX', 0.02394043498608451), ('PHX', 0.018373176636420224), ('CLT', 0.01780703930063076), ('LAS', 0.017649683141049966)] When we adjust for number of passengers we see that we have a reshuffle in the \"importance\" rankings, and they do make a bit more sense now. According to weighted PageRank, Atlanta, Chicago, Seattle the top 3 airports while Anchorage is at 4th rank now. To get an even better picture of this we should do the analyse with more metadata about the routes not just the number of passengers.","title":"Importants Hubs in the Airport Network"},{"location":"05-casestudies/02-airport/#how-reachable-is-this-network","text":"Let's assume you are the Head of Data Science of an airline and your job is to make your airline network as \"connected\" as possible. To translate this problem statement to network science, we calculate the average shortest path length of this network, it gives us an idea about the number of jumps we need to make around the network to go from one airport to any other airport in this network on average. We can use the inbuilt networkx method average_shortest_path_length to find the average shortest path length of a network. nx . average_shortest_path_length ( pass_2015_network ) --------------------------------------------------------------------------- NetworkXError Traceback ( most recent call last ) < ipython - input - 157 - acfe9bf3572a > in < module > ----> 1 nx . average_shortest_path_length ( pass_2015_network ) ~/ miniconda3 / envs / nams / lib / python3 . 7 / site - packages / networkx / algorithms / shortest_paths / generic . py in average_shortest_path_length ( G , weight , method ) 401 # Shortest path length is undefined if the graph is disconnected. 402 if G . is_directed () and not nx . is_weakly_connected ( G ): --> 403 raise nx . NetworkXError ( \"Graph is not weakly connected.\" ) 404 if not G . is_directed () and not nx . is_connected ( G ): 405 raise nx . NetworkXError ( \"Graph is not connected.\" ) NetworkXError : Graph is not weakly connected . Wait, What? This network is not \"connected\" (ignore the term weakly for the moment). That seems weird. It means that there are nodes which aren't reachable from other set of nodes, which isn't good news in especially a transporation network. Let's have a look at these far flung airports which aren't reachable. components = list ( nx . weakly_connected_components ( pass_2015_network )) # There are 3 weakly connected components in the network. for c in components : print ( len ( c )) 1255 2 1 # Let's look at the component with 2 and 1 airports respectively. print ( components [ 1 ]) print ( components [ 2 ]) {'SPB', 'SSB'} {'AIK'} The airports 'SSB' and 'SPB' are codes for Seaplanes airports and they have flights to each other so it makes sense that they aren't connected to the larger network of airports. The airport is even more weird as it is in a component in itself, i.e there is a flight from AIK to AIK. After investigating further it just seems like an anomaly in this dataset. AIK_DEST_2015 = pass_air_data [ ( pass_air_data [ 'YEAR' ] == 2015 ) & ( pass_air_data [ 'DEST' ] == 'AIK' )] AIK_DEST_2015 . head () id YEAR ORIGIN DEST UNIQUE_CARRIER_NAME PASSENGERS 433338 2015 AIK AIK {'Wright Air Service'} 0 # Let's get rid of them, we don't like them pass_2015_network . remove_nodes_from ( [ 'SPB' , 'SSB' , 'AIK' ]) # Our network is now weakly connected nx . is_weakly_connected ( pass_2015_network ) True # It's not strongly connected nx . is_strongly_connected ( pass_2015_network ) False","title":"How reachable is this network?"},{"location":"05-casestudies/02-airport/#strongly-vs-weakly-connected-graphs","text":"Let's go through an example to understand weakly and strongly connected directed graphs. # NOTE: The notion of strongly and weakly exists only for directed graphs. G = nx . DiGraph () # Let's create a cycle directed graph, 1 -> 2 -> 3 -> 1 G . add_edge ( 1 , 2 ) G . add_edge ( 2 , 3 ) G . add_edge ( 3 , 1 ) nx . draw ( G , with_labels = True ) In the above example we can reach any node irrespective of where we start traversing the network, if we start from 2 we can reach 1 via 3. In this network every node is \"reachable\" from one another, i.e the network is strongly connected. nx . is_strongly_connected ( G ) True # Let's add a new connection G . add_edge ( 3 , 4 ) nx . draw ( G , with_labels = True ) It's evident from the example above that we can't traverse the network graph. If we start from node 4 we are stuck at the node, we don't have any way of leaving node 4. This is assuming we strictly follow the direction of edges. In this case the network isn't strongly connected but if we look at the structure and assume the directions of edges don't matter than we can go to any other node in the network even if we start from node 4. In the case an undirected copy of directed network is connected we call the directed network as weakly connected. nx . is_strongly_connected ( G ) False nx . is_weakly_connected ( G ) True Let's go back to our airport network of 2015. After removing those 3 airports the network is weakly connected. nx . is_weakly_connected ( pass_2015_network ) True nx . is_strongly_connected ( pass_2015_network ) False But our network is still not strongly connected, which essentially means there are airports in the network where you can fly into but not fly back, which doesn't really seem okay strongly_connected_components = list ( nx . strongly_connected_components ( pass_2015_network )) # Let's look at one of the examples of a strong connected component strongly_connected_components [ 0 ] {'BCE'} BCE_DEST_2015 = pass_air_data [ ( pass_air_data [ 'YEAR' ] == 2015 ) & ( pass_air_data [ 'DEST' ] == 'BCE' )] BCE_DEST_2015 . head () id YEAR ORIGIN DEST UNIQUE_CARRIER_NAME PASSENGERS 451074 2015 PGA BCE {'Grand Canyon Airlines, Inc. d/b/a Grand Canyo... 8 BCE_ORI_2015 = pass_air_data [ ( pass_air_data [ 'YEAR' ] == 2015 ) & ( pass_air_data [ 'ORIGIN' ] == 'BCE' )] BCE_ORI_2015 . head () --------------------------------------------------------------------------- ValueError Traceback (most recent call last) ~/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/IPython/core/formatters.py in __call__ (self, obj) 339 pass 340 else : --> 341 return printer ( obj ) 342 # Finally look for special method names 343 method = get_real_method ( obj , self . print_method ) ~/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/mknotebooks/pandas_output_formatter.py in to_md (df, max_colwidth) 24 # Truncate entries wider than max_colwidth 25 return ( ---> 26 df . astype ( str ) 27 .apply( 28 lambda x: [ ~/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/pandas/core/frame.py in apply (self, func, axis, raw, result_type, args, **kwds) 7766 kwds = kwds , 7767 ) -> 7768 return op . get_result ( ) 7769 7770 def applymap ( self , func , na_action : Optional [ str ] = None ) -> DataFrame : ~/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/pandas/core/apply.py in get_result (self) 177 # one axis empty 178 elif not all ( self . obj . shape ) : --> 179 return self . apply_empty_result ( ) 180 181 # raw ~/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/pandas/core/apply.py in apply_empty_result (self) 216 r = np . nan 217 --> 218 return self . obj . _constructor_sliced ( r , index = self . agg_axis ) 219 else : 220 return self . obj . copy ( ) ~/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/pandas/core/series.py in __init__ (self, data, index, dtype, name, copy, fastpath) 348 try : 349 if len ( index ) != len ( data ) : --> 350 raise ValueError( 351 f\"Length of passed values is {len(data)}, \" 352 f\"index implies {len(index)}.\" ValueError : Length of passed values is 0, index implies 5. --------------------------------------------------------------------------- ValueError Traceback (most recent call last) ~/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/IPython/core/formatters.py in __call__ (self, obj) 339 pass 340 else : --> 341 return printer ( obj ) 342 # Finally look for special method names 343 method = get_real_method ( obj , self . print_method ) ~/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/mknotebooks/pandas_output_formatter.py in to_md (df, max_colwidth) 24 # Truncate entries wider than max_colwidth 25 return ( ---> 26 df . astype ( str ) 27 .apply( 28 lambda x: [ ~/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/pandas/core/frame.py in apply (self, func, axis, raw, result_type, args, **kwds) 7766 kwds = kwds , 7767 ) -> 7768 return op . get_result ( ) 7769 7770 def applymap ( self , func , na_action : Optional [ str ] = None ) -> DataFrame : ~/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/pandas/core/apply.py in get_result (self) 177 # one axis empty 178 elif not all ( self . obj . shape ) : --> 179 return self . apply_empty_result ( ) 180 181 # raw ~/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/pandas/core/apply.py in apply_empty_result (self) 216 r = np . nan 217 --> 218 return self . obj . _constructor_sliced ( r , index = self . agg_axis ) 219 else : 220 return self . obj . copy ( ) ~/work/Network-Analysis-Made-Simple/Network-Analysis-Made-Simple/nams_env/lib/python3.8/site-packages/pandas/core/series.py in __init__ (self, data, index, dtype, name, copy, fastpath) 348 try : 349 if len ( index ) != len ( data ) : --> 350 raise ValueError( 351 f\"Length of passed values is {len(data)}, \" 352 f\"index implies {len(index)}.\" ValueError : Length of passed values is 0, index implies 5. Empty DataFrame Columns: [YEAR, ORIGIN, DEST, UNIQUE_CARRIER_NAME, PASSENGERS] Index: [] As we can see above you can fly into 'BCE' but can't fly out, weird indeed. These airport are small airports with one off schedules flights. For the purposes of our analyses we can ignore such airports. # Let's find the biggest strongly connected component pass_2015_strong_nodes = max ( strongly_connected_components , key = len ) # Create a subgraph with the nodes in the # biggest strongly connected component pass_2015_strong = pass_2015_network . subgraph ( nodes = pass_2015_strong_nodes ) nx . is_strongly_connected ( pass_2015_strong ) True After removing multiple airports we now have a strongly connected airport network. We can now travel from one airport to any other airport in the network. # We started with 1258 airports len ( pass_2015_strong ) 1190 nx . average_shortest_path_length ( pass_2015_strong ) 3.174661992635574 The 3.17 number above represents the average length between 2 airports in the network which means that it's possible to go from one airport to another in this network under 3 layovers, which sounds nice. A more reachable network is better, not necessearily in terms of revenue for the airline but for social health of the air transport network.","title":"Strongly vs weakly connected graphs."},{"location":"05-casestudies/02-airport/#exercise_1","text":"How can we decrease the average shortest path length of this network? Think of an effective way to add new edges to decrease the average shortest path length. Let's see if we can come up with a nice way to do this. The rules are simple: - You can't add more than 2% of the current edges( ~500 edges) from nams.solutions.airport import add_opinated_edges new_routes_network = add_opinated_edges ( pass_2015_strong ) nx . average_shortest_path_length ( new_routes_network ) 3.0888508809747615 Using an opinionated heuristic we were able to reduce the average shortest path length of the network. Check the solution below to understand the idea behind the heuristic, do try to come up with your own heuristics.","title":"Exercise"},{"location":"05-casestudies/02-airport/#can-we-find-airline-specific-reachability","text":"Let's see how we can use the airline metadata to calculate the reachability of a specific airline. # We have access to the airlines that fly the route in the edge attribute airlines pass_2015_network [ 'JFK' ][ 'SFO' ] {'weight': 1179941.0, 'weight_inv': 8.4750000211875e-07, 'airlines': \"{'Delta Air Lines Inc.', 'Virgin America', 'American Airlines Inc.', 'Sun Country Airlines d/b/a MN Airlines', 'JetBlue Airways', 'Vision Airlines', 'United Air Lines Inc.'}\"} # A helper function to extract the airlines names from the edge attribute def str_to_list ( a ): return a [ 1 : - 1 ] . split ( ', ' ) for origin , dest in pass_2015_network . edges (): pass_2015_network [ origin ][ dest ][ 'airlines_list' ] = str_to_list ( ( pass_2015_network [ origin ][ dest ][ 'airlines' ])) Let's extract the network of United Airlines from our airport network. united_network = nx . DiGraph () for origin , dest in pass_2015_network . edges (): if \"'United Air Lines Inc.'\" in pass_2015_network [ origin ][ dest ][ 'airlines_list' ]: united_network . add_edge ( origin , dest , weight = pass_2015_network [ origin ][ dest ][ 'weight' ]) # number of nodes -> airports # number of edges -> routes print ( nx . info ( united_network )) Name: Type: DiGraph Number of nodes: 194 Number of edges: 1894 Average in degree: 9.7629 Average out degree: 9.7629 # Let's find United Hubs according to PageRank sorted ( nx . pagerank ( united_network , weight = 'weight' ) . items (), key = lambda x : x [ 1 ], reverse = True )[ 0 : 5 ] [('ORD', 0.08385772266571424), ('DEN', 0.06816244850418422), ('LAX', 0.053065234147240105), ('IAH', 0.044410609028379185), ('SFO', 0.04326197030283029)] # Let's find United Hubs according to Degree Centrality sorted ( nx . degree_centrality ( united_network ) . items (), key = lambda x : x [ 1 ], reverse = True )[ 0 : 5 ] [('ORD', 1.0), ('IAH', 0.9274611398963731), ('DEN', 0.8756476683937824), ('EWR', 0.8134715025906736), ('SFO', 0.6839378238341969)]","title":"Can we find airline specific reachability?"},{"location":"05-casestudies/02-airport/#solutions","text":"Here are the solutions to the exercises above. from nams.solutions import airport import inspect print ( inspect . getsource ( airport )) import networkx as nx import pandas as pd def busiest_route(pass_air_data, year): return pass_air_data[ pass_air_data.groupby([\"YEAR\"])[\"PASSENGERS\"].transform(max) == pass_air_data[\"PASSENGERS\"] ].query(f\"YEAR == {year}\") def plot_time_series(pass_air_data, origin, dest): pass_air_data.query(f\"ORIGIN == '{origin}' and DEST == '{dest}'\").plot( \"YEAR\", \"PASSENGERS\" ) def add_opinated_edges(G): G = nx.DiGraph(G) sort_degree = sorted( nx.degree_centrality(G).items(), key=lambda x: x[1], reverse=True ) top_count = 0 for n, v in sort_degree: count = 0 for node, val in sort_degree: if node != n: if node not in G._adj[n]: G.add_edge(n, node) count += 1 if count == 25: break top_count += 1 if top_count == 20: break return G","title":"Solutions"},{"location":"devdocs/style/","text":"This is the style guide for writing notebooks and markdown files for the book. Intended as a guide when there is ambiguity in how to format something. Updated it when new decisions are made for uncertain circumstances. Notebooks Headers Jupyter notebook headers should begin at the 2nd level. In other words: ## Introdction (this is correct!) should be the first header, and not: # Introdction (this is wrong!) This allows mkdocs to insert the \"Chapter X\" heading at the top of the compiled Markdown document. Exercises Exercises should be at the 3rd level of headers. For exercises that yield a plot, allow the exercise cell to be executed. For exercises that modify an object that is used later, allow the exercise cell to be executed. For exercises that are implementation-oriented, and do not affect notebook state, it is recommended that the execution be commented out to save on execution time. For exercises that require answering a question, wrap the answer in a triple quote string, use the markdown package to parse it into HTML, and then use IPython's HTML display facility to show the answer in beautiful HTML. A convenience function called render_html is provided. Here's an example: from nams.functions import render_html def bipartite_degree_centrality_denominator (): ans = \"\"\" Some answer goes here! Written in **Markdown**. \"\"\" return render_html ( ans ) Indentation is super important! Left indentation on the answer string cannot be present, otherwise the answer will not render correctly in HTML form! Solutions Exercise solutions should be placed in the corresponding nams.solutions.<notebook_name_without_extension> Python submodule. Code solutions should always be present at the bottom of the notebook. Use the following code block to help: import inspect from nams.solutions import {{ notebook_name }} print ( inspect ({{ notebook_name }})) Execution Notebooks should run from top-to-bottom without erroring out. Notebooks ideally should run in under 10 seconds. However, if a notebook needs up to 30 seconds to finish execution, that is acceptable. No notebook should take on the order of minutes to finish.","title":"Style Guide"},{"location":"devdocs/style/#notebooks","text":"","title":"Notebooks"},{"location":"devdocs/style/#headers","text":"Jupyter notebook headers should begin at the 2nd level. In other words: ## Introdction (this is correct!) should be the first header, and not: # Introdction (this is wrong!) This allows mkdocs to insert the \"Chapter X\" heading at the top of the compiled Markdown document.","title":"Headers"},{"location":"devdocs/style/#exercises","text":"Exercises should be at the 3rd level of headers. For exercises that yield a plot, allow the exercise cell to be executed. For exercises that modify an object that is used later, allow the exercise cell to be executed. For exercises that are implementation-oriented, and do not affect notebook state, it is recommended that the execution be commented out to save on execution time. For exercises that require answering a question, wrap the answer in a triple quote string, use the markdown package to parse it into HTML, and then use IPython's HTML display facility to show the answer in beautiful HTML. A convenience function called render_html is provided. Here's an example: from nams.functions import render_html def bipartite_degree_centrality_denominator (): ans = \"\"\" Some answer goes here! Written in **Markdown**. \"\"\" return render_html ( ans ) Indentation is super important! Left indentation on the answer string cannot be present, otherwise the answer will not render correctly in HTML form!","title":"Exercises"},{"location":"devdocs/style/#solutions","text":"Exercise solutions should be placed in the corresponding nams.solutions.<notebook_name_without_extension> Python submodule. Code solutions should always be present at the bottom of the notebook. Use the following code block to help: import inspect from nams.solutions import {{ notebook_name }} print ( inspect ({{ notebook_name }}))","title":"Solutions"},{"location":"devdocs/style/#execution","text":"Notebooks should run from top-to-bottom without erroring out. Notebooks ideally should run in under 10 seconds. However, if a notebook needs up to 30 seconds to finish execution, that is acceptable. No notebook should take on the order of minutes to finish.","title":"Execution"}]}